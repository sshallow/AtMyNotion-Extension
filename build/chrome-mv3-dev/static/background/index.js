(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"66OA4":[function(require,module,exports) {
var u = typeof globalThis.process < "u" ? globalThis.process.argv : [];
var h = ()=>typeof globalThis.process < "u" ? globalThis.process.env : {};
var B = new Set(u), _ = (e)=>B.has(e), G = u.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var U = _("--dry-run"), g = ()=>_("--verbose") || h().VERBOSE === "true", N = g();
var m = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var y = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), b = (...e)=>m("\uD83D\uDD35 INFO", ...e), f = (...e)=>m("\uD83D\uDFE0 WARN", ...e), M = 0, i = (...e)=>g() && m(`\u{1F7E1} ${M++}`, ...e);
var v = ()=>{
    let e = globalThis.browser?.runtime || globalThis.chrome?.runtime, t = ()=>setInterval(e.getPlatformInfo, 24e3);
    e.onStartup.addListener(t), t();
};
var n = {
    "isContentScript": false,
    "isBackground": true,
    "isReact": false,
    "runtimes": [
        "background-service-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "/Users/shangshy/Developer/code/chrome extension/AtMyNotion-ChromeExtension/.plasmo/static/background/index.ts",
    "bundleId": "c338908e704c91f1",
    "envHash": "d99a5ffa57acd638",
    "verbose": "false",
    "secure": false,
    "serverPort": 55704
};
module.bundle.HMR_BUNDLE_ID = n.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: n.verbose
    }
};
var D = module.bundle.Module;
function H(e) {
    D.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = H;
module.bundle.hotData = {};
var c = globalThis.browser || globalThis.chrome || null;
function R() {
    return !n.host || n.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : n.host;
}
function x() {
    return !n.host || n.host === "0.0.0.0" ? "localhost" : n.host;
}
function d() {
    return n.port || location.port;
}
var P = "__plasmo_runtime_page_", S = "__plasmo_runtime_script_";
var O = `${n.secure ? "https" : "http"}://${R()}:${d()}/`;
async function k(e = 1470) {
    for(;;)try {
        await fetch(O);
        break;
    } catch  {
        await new Promise((o)=>setTimeout(o, e));
    }
}
if (c.runtime.getManifest().manifest_version === 3) {
    let e = c.runtime.getURL("/__plasmo_hmr_proxy__?url=");
    globalThis.addEventListener("fetch", function(t) {
        let o = t.request.url;
        if (o.startsWith(e)) {
            let s = new URL(decodeURIComponent(o.slice(e.length)));
            s.hostname === n.host && s.port === `${n.port}` ? (s.searchParams.set("t", Date.now().toString()), t.respondWith(fetch(s).then((r)=>new Response(r.body, {
                    headers: {
                        "Content-Type": r.headers.get("Content-Type") ?? "text/javascript"
                    }
                })))) : t.respondWith(new Response("Plasmo HMR", {
                status: 200,
                statusText: "Testing"
            }));
        }
    });
}
function E(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function C(e = d()) {
    let t = x();
    return `${n.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function T(e) {
    typeof e.message == "string" && y("[plasmo/parcel-runtime]: " + e.message);
}
function L(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C(Number(d()) + 1));
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        await e(s);
    }), t.addEventListener("error", T), t;
}
function A(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C());
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        if (s.type === "update" && await e(s.assets), s.type === "error") for (let r of s.diagnostics.ansi){
            let l = r.codeframe || r.stack;
            f("[plasmo/parcel-runtime]: " + r.message + `
` + l + `

` + r.hints.join(`
`));
        }
    }), t.addEventListener("error", T), t.addEventListener("open", ()=>{
        b(`[plasmo/parcel-runtime]: Connected to HMR server for ${n.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        f(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${n.entryFilePath}`);
    }), t;
}
var w = module.bundle.parent, a = {
    buildReady: !1,
    bgChanged: !1,
    csChanged: !1,
    pageChanged: !1,
    scriptPorts: new Set,
    pagePorts: new Set
};
async function p(e = !1) {
    if (e || a.buildReady && a.pageChanged) {
        i("BGSW Runtime - reloading Page");
        for (let t of a.pagePorts)t.postMessage(null);
    }
    if (e || a.buildReady && (a.bgChanged || a.csChanged)) {
        i("BGSW Runtime - reloading CS");
        let t = await c?.tabs.query({
            active: !0
        });
        for (let o of a.scriptPorts){
            let s = t.some((r)=>r.id === o.sender.tab?.id);
            o.postMessage({
                __plasmo_cs_active_tab__: s
            });
        }
        c.runtime.reload();
    }
}
if (!w || !w.isParcelRequire) {
    v();
    let e = A(async (t)=>{
        i("BGSW Runtime - On HMR Update"), a.bgChanged ||= t.filter((s)=>s.envHash === n.envHash).some((s)=>E(module.bundle, s.id));
        let o = t.find((s)=>s.type === "json");
        if (o) {
            let s = new Set(t.map((l)=>l.id)), r = Object.values(o.depsByBundle).map((l)=>Object.values(l)).flat();
            a.bgChanged ||= r.every((l)=>s.has(l));
        }
        p();
    });
    e.addEventListener("open", ()=>{
        let t = setInterval(()=>e.send("ping"), 24e3);
        e.addEventListener("close", ()=>clearInterval(t));
    }), e.addEventListener("close", async ()=>{
        await k(), p(!0);
    });
}
L(async (e)=>{
    switch(i("BGSW Runtime - On Build Repackaged"), e.type){
        case "build_ready":
            a.buildReady ||= !0, p();
            break;
        case "cs_changed":
            a.csChanged ||= !0, p();
            break;
    }
});
c.runtime.onConnect.addListener(function(e) {
    let t = e.name.startsWith(P), o = e.name.startsWith(S);
    if (t || o) {
        let s = t ? a.pagePorts : a.scriptPorts;
        s.add(e), e.onDisconnect.addListener(()=>{
            s.delete(e);
        }), e.onMessage.addListener(function(r) {
            i("BGSW Runtime - On source changed", r), r.__plasmo_cs_changed__ && (a.csChanged ||= !0), r.__plasmo_page_changed__ && (a.pageChanged ||= !0), p();
        });
    }
});
c.runtime.onMessage.addListener(function(t) {
    return t.__plasmo_full_reload__ && (i("BGSW Runtime - On top-level code changed"), p()), !0;
});

},{}],"8oeFb":[function(require,module,exports) {
var _messaging = require("./messaging");
var _index = require("../../../src/background/index");

},{"./messaging":"gGuoe","../../../src/background/index":"kB65o"}],"gGuoe":[function(require,module,exports) {
// @ts-nocheck
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _backgroundCrosNotionImage = require("~background/messages/background-cros-notion-image");
var _backgroundCrosNotionImageDefault = parcelHelpers.interopDefault(_backgroundCrosNotionImage);
var _backgroundGetSpaces = require("~background/messages/background-get-spaces");
var _backgroundGetSpacesDefault = parcelHelpers.interopDefault(_backgroundGetSpaces);
var _backgroundNotionSearch = require("~background/messages/background-notion-search");
var _backgroundNotionSearchDefault = parcelHelpers.interopDefault(_backgroundNotionSearch);
globalThis.__plasmoInternalPortMap = new Map();
chrome.runtime.onMessageExternal.addListener((request, sender, sendResponse)=>{
    switch(request.name){
        case "background-cros-notion-image":
            (0, _backgroundCrosNotionImageDefault.default)({
                sender,
                ...request
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        case "background-get-spaces":
            (0, _backgroundGetSpacesDefault.default)({
                sender,
                ...request
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        case "background-notion-search":
            (0, _backgroundNotionSearchDefault.default)({
                sender,
                ...request
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        default:
            break;
    }
    return true;
});
chrome.runtime.onMessage.addListener((request, sender, sendResponse)=>{
    switch(request.name){
        case "background-cros-notion-image":
            (0, _backgroundCrosNotionImageDefault.default)({
                sender,
                ...request
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        case "background-get-spaces":
            (0, _backgroundGetSpacesDefault.default)({
                sender,
                ...request
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        case "background-notion-search":
            (0, _backgroundNotionSearchDefault.default)({
                sender,
                ...request
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        default:
            break;
    }
    return true;
});
chrome.runtime.onConnect.addListener(function(port) {
    globalThis.__plasmoInternalPortMap.set(port.name, port);
    port.onMessage.addListener(function(request) {
        port.name;
    });
});

},{"~background/messages/background-cros-notion-image":"h3P3W","~background/messages/background-get-spaces":"3vqFZ","~background/messages/background-notion-search":"9H1h2","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"h3P3W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const handler = async (req, res)=>{
    console.log(new Date().getTime(), "background \u5f00\u59cb\u8bf7\u6c42 NotionSearchMenu Notion \u56fe\u7247", req.body.page_icon);
    const response = await fetch(req.body.page_icon, {
        headers: {
            "Content-Type": "application/json"
        }
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const blob = await response.blob(); // \u5c06\u54cd\u5e94\u4f53\u8f6c\u6362\u4e3ablob
    console.log(new Date().getTime(), "background \u8bf7\u6c42\u5230 NotionSearchMenu \u56fe\u7247", blob);
    // \u5c06\u56fe\u7247\u4f5c\u4e3aBlob\u53d1\u9001\u56de\u524d\u7aef
    res.send({
        blob: blob
    });
};
exports.default = handler;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"5G9Z5":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"3vqFZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fetch = require("~fetch/fetch");
var _fetchDefault = parcelHelpers.interopDefault(_fetch);
const handler = async (req, res)=>{
    // \u8bf7\u6c42 getSpaces
    const response = await (0, _fetchDefault.default)({
        url: "https://www.notion.so/api/v3/getSpaces",
        method: "POST"
    });
    const spacesResponse = Object.values(response)[0];
    const spaceIdList = Object.keys(spacesResponse.space);
    // \u8bf7\u6c42 getPublicSpaceData
    const requestBody = {
        type: "space-ids",
        spaceIds: spaceIdList
    };
    const spaceDataResponse = await (0, _fetchDefault.default)({
        url: "https://www.notion.so/api/v3/getPublicSpaceData",
        method: "POST",
        body: requestBody
    });
    // \u54cd\u5e94
    res.send({
        response,
        spaceDataResponse
    });
};
exports.default = handler;

},{"~fetch/fetch":"f5DRC","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"f5DRC":[function(require,module,exports) {
// fetch.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
async function fetchClient(fetchConfig) {
    const { url, method = "POST", headers = {}, body = null } = fetchConfig;
    try {
        const response = await fetch(url, {
            method,
            headers: {
                "Content-Type": "application/json",
                ...headers
            },
            body: body ? JSON.stringify(body) : null
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        // \u6839\u636e\u9700\u8981\u5904\u7406\u548c\u8fd4\u56de\u54cd\u5e94\uff0c\u4f8b\u5982 JSON \u6216\u5176\u4ed6\u683c\u5f0f
        return await response.json();
    } catch (error) {
        console.error("Error making a fetch:", error);
        throw error;
    }
}
exports.default = fetchClient;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"9H1h2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fetch = require("~fetch/fetch");
var _fetchDefault = parcelHelpers.interopDefault(_fetch);
console.log("background-notion-search");
const handler = async (req, res)=>{
    const { user, userPreferences, query } = req.body;
    if (!user || !userPreferences || !query) throw new Error("Missing required parameters: user, userPreferences, or query");
    // \u83b7\u53d6\u6700\u8fd1\u9875\u9762\u8bbf\u95ee\u6570\u636e
    const recentPagesResponse = await (0, _fetchDefault.default)({
        url: "https://www.notion.so/api/v3/getRecentPageVisits",
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "X-Notion-Active-User-Header": user.id,
            "X-Notion-Space-Id": userPreferences.currentSpace.id
        },
        body: {
            userId: user.id,
            spaceId: userPreferences.currentSpace.id
        }
    });
    if (!recentPagesResponse) {
        console.log("recentPagesResponse \u5931\u8d25");
        throw new Error("Network response was not ok");
    }
    // \u4fee\u6539 recentPagesForBoosting
    recentPagesResponse.pages = recentPagesResponse.pages.map((item)=>({
            visitedAt: item.visitedAt,
            pageId: item.id
        }));
    // \u6784\u5efa\u65b0\u7684\u8bf7\u6c42\u4f53\uff0c\u5c06\u6700\u8fd1\u9875\u9762\u8bbf\u95ee\u6570\u636e\u63d2\u5165\u5230 recentPagesForBoosting \u5b57\u6bb5\u4e2d
    const requestBody = {
        source: "quick_find_input_change",
        sort: {
            field: "relevance"
        },
        filters: {
            lastEditedTime: {},
            excludeTemplates: false,
            navigableBlockContentOnly: false,
            ancestors: [],
            editedBy: [],
            requireEditPermissions: false,
            createdBy: [],
            isDeletedOnly: false,
            createdTime: {},
            inTeams: [],
            includePublicPagesWithoutExplicitAccess: false
        },
        excludedBlockIds: [],
        query: query,
        limit: 8,
        recentPagesForBoosting: recentPagesResponse.pages,
        type: "BlocksInSpace",
        searchSessionId: "edd8ad05-fa6e-411b-8478-98378c024e3b",
        searchSessionFlowNumber: 3,
        searchExperimentOverrides: {},
        spaceId: userPreferences.currentSpace.id
    };
    // \u5f00\u59cb\u641c\u7d22
    const response = await (0, _fetchDefault.default)({
        url: "https://www.notion.so/api/v3/search",
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "X-Notion-Active-User-Header": user.id,
            "X-Notion-Space-Id": userPreferences.currentSpace.id
        },
        body: requestBody
    });
    // \u89e3\u6790 \u4e3a\u6bcf\u4e2a\u7ed3\u679c\u6dfb\u52a0 title\uff0cpath\uff0cicon
    const resultsWithIcon = await Promise.all(response.results.map(async (item)=>{
        const recordBlock = response.recordMap.block[item.id];
        let updatedItem = item;
        debugger;
        // \u5904\u7406 title, pathText
        if (item.highlight?.title && item.highlight.title.includes("<gzkNfoUU>")) {
            updatedItem.highlight.pathText = item.highlight.pathText.replace(item.highlight.title, "");
            updatedItem = {
                ...updatedItem,
                title: item.highlight?.title
            };
        }
        if (!updatedItem.highlight?.title) {
            const titleText = recordBlock.value.properties.title[0][0];
            updatedItem = {
                ...updatedItem,
                title: titleText
            };
        }
        // \u5904\u7406 icon
        if (recordBlock?.value?.format?.page_icon) {
            let pageIcon = recordBlock?.value?.format?.page_icon;
            if (pageIcon.includes("amazonaws.com")) {
                const encodedUrl = encodeURIComponent(pageIcon);
                const tableIdQuery = item.id ? `?table=block&id=${item.id}&width=40&cache=v2` : "";
                const iconUrl = `https://www.notion.so/image/${encodedUrl}${tableIdQuery}`;
                const response = await fetch(iconUrl, {
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const imageBlob = await response.blob();
                //
                const base64String = await new Promise((resolve)=>{
                    const reader = new FileReader();
                    reader.onloadend = ()=>resolve(reader.result);
                    reader.readAsDataURL(imageBlob);
                });
                console.log("\u6210\u529f\u8f6c\u4e3a\u4e86 blob \u56fe\u7247 base64String ", base64String);
                updatedItem = {
                    ...updatedItem,
                    pageIcon: base64String
                };
            } else if (pageIcon.includes("sinaimg.c")) {
                const replacedIconUrl = pageIcon.replace(/^(https?:\/\/)([^\/]+)(\/.*)$/, "$1i1.wp.com/$2$3");
                updatedItem = {
                    ...updatedItem,
                    pageIcon: replacedIconUrl
                };
            } else updatedItem = {
                ...updatedItem,
                pageIcon
            };
        }
        return updatedItem;
    }));
    console.log("resultsWithIcon", resultsWithIcon);
    res.send({
        response: resultsWithIcon
    });
};
exports.default = handler;

},{"~fetch/fetch":"f5DRC","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"kB65o":[function(require,module,exports) {
var _store = require("~store");
console.log("Live now; make now always the most precious time. Now will never come again.");
// \u76d1\u542c cookies \u7684\u53d8\u5316
chrome.cookies.onChanged.addListener((changeInfo)=>{
    // .notion.so \u7684 cookie \u53d8\u5316
    if (changeInfo.cookie.domain === ".notion.so") {
        console.log(".notion.so \u7684 cookie \u53d8\u5316", changeInfo.cookie);
        // explicit + overwrite + file_token \u767b\u5f55\u64cd\u4f5c\u4e0b\u53d8\u5316
        if ((changeInfo.cause === "explicit" || changeInfo.cause === "overwrite") && changeInfo.cookie.name === "file_token") {
            const date = new Date();
            const formattedDate = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")} ${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}`;
            console.log(formattedDate, "\u76d1\u542c\u5230 .notion.so \u7684 file_token \u7684\u53d8\u5316", changeInfo);
            // \u53d1\u9001\u6d88\u606f\u5230popup\u9875\u9762
            chrome.runtime.sendMessage({
                type: "notion_cookies_onChanged",
                payload: changeInfo
            }, function(res) {
                if (res) console.log("\u56de\u8c03\u51fd\u6570:", res);
                else if (res && res.error) console.log("\u56de\u8c03\u51fd\u6570 Error:", res);
            });
        }
    }
});
(0, _store.persistor).subscribe(()=>{
    console.log("background index.ts subscribe State: ", (0, _store.store)?.getState());
});

},{"~store":"9BEzi"}],"9BEzi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "store", ()=>store);
parcelHelpers.export(exports, "persistor", ()=>persistor);
parcelHelpers.export(exports, "useAppDispatch", ()=>useAppDispatch);
parcelHelpers.export(exports, "useAppSelector", ()=>useAppSelector);
var _toolkit = require("@reduxjs/toolkit");
var _reactRedux = require("react-redux");
var _reduxPersistWebextensionStorage = require("redux-persist-webextension-storage");
var _reduxPersist = require("@plasmohq/redux-persist");
var _storage = require("@plasmohq/storage");
var _notionSlice = require("~notion/notion-slice");
var _notionSliceDefault = parcelHelpers.interopDefault(_notionSlice);
const combinedReducers = (0, _toolkit.combineReducers)({
    notion: (0, _notionSliceDefault.default)
});
const persistConfig = {
    key: "root",
    version: 1,
    storage: (0, _reduxPersistWebextensionStorage.syncStorage)
};
const persistedReducer = (0, _reduxPersist.persistReducer)(persistConfig, combinedReducers);
const mockStore = (0, _toolkit.configureStore)({
    reducer: combinedReducers
});
const store = (0, _toolkit.configureStore)({
    reducer: persistedReducer,
    middleware: (getDefaultMiddleware)=>getDefaultMiddleware({
            serializableCheck: {
                ignoredActions: [
                    (0, _reduxPersist.FLUSH),
                    (0, _reduxPersist.REHYDRATE),
                    (0, _reduxPersist.PAUSE),
                    (0, _reduxPersist.PERSIST),
                    (0, _reduxPersist.PURGE),
                    (0, _reduxPersist.REGISTER),
                    (0, _reduxPersist.RESYNC)
                ]
            }
        })
});
const persistor = (0, _reduxPersist.persistStore)(store);
new (0, _storage.Storage)().watch({
    [`persist:${persistConfig.key}`]: (change)=>{
        const { oldValue, newValue } = change;
        const updatedKeys = [];
        for(const key in oldValue)if (oldValue[key] !== newValue?.[key]) updatedKeys.push(key);
        for(const key in newValue)if (oldValue?.[key] !== newValue[key]) updatedKeys.push(key);
        if (updatedKeys.length > 0) persistor.resync();
    }
});
const useAppDispatch = (0, _reactRedux.useDispatch);
const useAppSelector = (0, _reactRedux.useSelector);

},{"@reduxjs/toolkit":"NXNwC","react-redux":"jnLXV","redux-persist-webextension-storage":"2MS7Z","@plasmohq/redux-persist":"ljLcS","@plasmohq/storage":"9NURi","~notion/notion-slice":"8xFUL","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"NXNwC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReducerType", ()=>ReducerType);
parcelHelpers.export(exports, "SHOULD_AUTOBATCH", ()=>SHOULD_AUTOBATCH);
parcelHelpers.export(exports, "TaskAbortError", ()=>TaskAbortError);
parcelHelpers.export(exports, "Tuple", ()=>Tuple);
parcelHelpers.export(exports, "addListener", ()=>addListener);
parcelHelpers.export(exports, "asyncThunkCreator", ()=>asyncThunkCreator);
parcelHelpers.export(exports, "autoBatchEnhancer", ()=>autoBatchEnhancer);
parcelHelpers.export(exports, "buildCreateSlice", ()=>buildCreateSlice);
parcelHelpers.export(exports, "clearAllListeners", ()=>clearAllListeners);
parcelHelpers.export(exports, "combineSlices", ()=>combineSlices);
parcelHelpers.export(exports, "configureStore", ()=>configureStore);
parcelHelpers.export(exports, "createAction", ()=>createAction);
parcelHelpers.export(exports, "createActionCreatorInvariantMiddleware", ()=>createActionCreatorInvariantMiddleware);
parcelHelpers.export(exports, "createAsyncThunk", ()=>createAsyncThunk);
parcelHelpers.export(exports, "createDraftSafeSelector", ()=>createDraftSafeSelector);
parcelHelpers.export(exports, "createDraftSafeSelectorCreator", ()=>createDraftSafeSelectorCreator);
parcelHelpers.export(exports, "createDynamicMiddleware", ()=>createDynamicMiddleware);
parcelHelpers.export(exports, "createEntityAdapter", ()=>createEntityAdapter);
parcelHelpers.export(exports, "createImmutableStateInvariantMiddleware", ()=>createImmutableStateInvariantMiddleware);
parcelHelpers.export(exports, "createListenerMiddleware", ()=>createListenerMiddleware);
parcelHelpers.export(exports, "createNextState", ()=>(0, _immer.produce));
parcelHelpers.export(exports, "createReducer", ()=>createReducer);
parcelHelpers.export(exports, "createSelector", ()=>(0, _reselect.createSelector));
parcelHelpers.export(exports, "createSelectorCreator", ()=>(0, _reselect.createSelectorCreator));
parcelHelpers.export(exports, "createSerializableStateInvariantMiddleware", ()=>createSerializableStateInvariantMiddleware);
parcelHelpers.export(exports, "createSlice", ()=>createSlice);
parcelHelpers.export(exports, "current", ()=>(0, _immer.current));
parcelHelpers.export(exports, "findNonSerializableValue", ()=>findNonSerializableValue);
parcelHelpers.export(exports, "formatProdErrorMessage", ()=>formatProdErrorMessage);
parcelHelpers.export(exports, "freeze", ()=>(0, _immer.freeze));
parcelHelpers.export(exports, "isActionCreator", ()=>isActionCreator);
parcelHelpers.export(exports, "isAllOf", ()=>isAllOf);
parcelHelpers.export(exports, "isAnyOf", ()=>isAnyOf);
parcelHelpers.export(exports, "isAsyncThunkAction", ()=>isAsyncThunkAction);
parcelHelpers.export(exports, "isDraft", ()=>(0, _immer.isDraft));
parcelHelpers.export(exports, "isFluxStandardAction", ()=>isFSA);
parcelHelpers.export(exports, "isFulfilled", ()=>isFulfilled);
parcelHelpers.export(exports, "isImmutableDefault", ()=>isImmutableDefault);
parcelHelpers.export(exports, "isPending", ()=>isPending);
parcelHelpers.export(exports, "isPlain", ()=>isPlain);
parcelHelpers.export(exports, "isRejected", ()=>isRejected);
parcelHelpers.export(exports, "isRejectedWithValue", ()=>isRejectedWithValue);
parcelHelpers.export(exports, "lruMemoize", ()=>(0, _reselect.lruMemoize));
parcelHelpers.export(exports, "miniSerializeError", ()=>miniSerializeError);
parcelHelpers.export(exports, "nanoid", ()=>nanoid);
parcelHelpers.export(exports, "original", ()=>(0, _immer.original));
parcelHelpers.export(exports, "prepareAutoBatched", ()=>prepareAutoBatched);
parcelHelpers.export(exports, "removeListener", ()=>removeListener);
parcelHelpers.export(exports, "unwrapResult", ()=>unwrapResult);
parcelHelpers.export(exports, "weakMapMemoize", ()=>(0, _reselect.weakMapMemoize));
// src/index.ts
var _redux = require("redux");
parcelHelpers.exportAll(_redux, exports);
var _immer = require("immer");
var _reselect = require("reselect");
// src/getDefaultMiddleware.ts
var _reduxThunk = require("redux-thunk");
var process = require("5843e4dc16d6aaa3");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(source))if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
var createDraftSafeSelectorCreator = (...args)=>{
    const createSelector2 = (0, _reselect.createSelectorCreator)(...args);
    const createDraftSafeSelector2 = Object.assign((...args2)=>{
        const selector = createSelector2(...args2);
        const wrappedSelector = (value, ...rest)=>selector((0, _immer.isDraft)(value) ? (0, _immer.current)(value) : value, ...rest);
        Object.assign(wrappedSelector, selector);
        return wrappedSelector;
    }, {
        withTypes: ()=>createDraftSafeSelector2
    });
    return createDraftSafeSelector2;
};
var createDraftSafeSelector = createDraftSafeSelectorCreator((0, _reselect.weakMapMemoize));
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0) return void 0;
    if (typeof arguments[0] === "object") return 0, _redux.compose;
    return (0, _redux.compose).apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
    return function(noop3) {
        return noop3;
    };
};
// src/tsHelpers.ts
var hasMatchFunction = (v)=>{
    return v && typeof v.match === "function";
};
// src/createAction.ts
function createAction(type, prepareAction) {
    function actionCreator(...args) {
        if (prepareAction) {
            let prepared = prepareAction(...args);
            if (!prepared) throw new Error("prepareAction did not return an object");
            return __spreadValues(__spreadValues({
                type,
                payload: prepared.payload
            }, "meta" in prepared && {
                meta: prepared.meta
            }), "error" in prepared && {
                error: prepared.error
            });
        }
        return {
            type,
            payload: args[0]
        };
    }
    actionCreator.toString = ()=>`${type}`;
    actionCreator.type = type;
    actionCreator.match = (action)=>(0, _redux.isAction)(action) && action.type === type;
    return actionCreator;
}
function isActionCreator(action) {
    return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
    hasMatchFunction(action);
}
function isFSA(action) {
    return (0, _redux.isAction)(action) && Object.keys(action).every(isValidKey);
}
function isValidKey(key) {
    return [
        "type",
        "payload",
        "error",
        "meta"
    ].indexOf(key) > -1;
}
// src/actionCreatorInvariantMiddleware.ts
function getMessage(type) {
    const splitType = type ? `${type}`.split("/") : [];
    const actionName = splitType[splitType.length - 1] || "actionCreator";
    return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options = {}) {
    var next, action;
    const { isActionCreator: isActionCreator2 = isActionCreator } = options;
    return ()=>(next)=>(action)=>{
                if (isActionCreator2(action)) console.warn(getMessage(action.type));
                return next(action);
            };
}
function getTimeMeasureUtils(maxDelay, fnName) {
    let elapsed = 0;
    return {
        measureTime (fn) {
            const started = Date.now();
            try {
                return fn();
            } finally{
                const finished = Date.now();
                elapsed += finished - started;
            }
        },
        warnIfExceeded () {
            if (elapsed > maxDelay) console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
        }
    };
}
function find(iterable, comparator) {
    for (const entry of iterable){
        if (comparator(entry)) return entry;
    }
    return void 0;
}
var Tuple = class _Tuple extends Array {
    constructor(...items){
        super(...items);
        Object.setPrototypeOf(this, _Tuple.prototype);
    }
    static get [Symbol.species]() {
        return _Tuple;
    }
    concat(...arr) {
        return super.concat.apply(this, arr);
    }
    prepend(...arr) {
        if (arr.length === 1 && Array.isArray(arr[0])) return new _Tuple(...arr[0].concat(this));
        return new _Tuple(...arr.concat(this));
    }
};
function freezeDraftable(val) {
    return (0, _immer.isDraftable)(val) ? (0, _immer.produce)(val, ()=>{}) : val;
}
function emplace(map, key, handler) {
    if (map.has(key)) {
        let value = map.get(key);
        if (handler.update) {
            value = handler.update(value, key, map);
            map.set(key, value);
        }
        return value;
    }
    if (!handler.insert) throw new Error("No insert provided for key not already in map");
    const inserted = handler.insert(key, map);
    map.set(key, inserted);
    return inserted;
}
// src/immutableStateInvariantMiddleware.ts
function isImmutableDefault(value) {
    return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
        detectMutations () {
            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
        }
    };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
    const tracked = {
        value: obj
    };
    if (!isImmutable(obj) && !checkedObjects.has(obj)) {
        checkedObjects.add(obj);
        tracked.children = {};
        for(const key in obj){
            const childPath = path ? path + "." + key : key;
            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) continue;
            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
        }
    }
    return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
    const prevObj = trackedProperty ? trackedProperty.value : void 0;
    const sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) return {
        wasMutated: true,
        path
    };
    if (isImmutable(prevObj) || isImmutable(obj)) return {
        wasMutated: false
    };
    const keysToDetect = {};
    for(let key in trackedProperty.children)keysToDetect[key] = true;
    for(let key in obj)keysToDetect[key] = true;
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for(let key in keysToDetect){
        const nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths) {
            const hasMatches = ignoredPaths.some((ignored)=>{
                if (ignored instanceof RegExp) return ignored.test(nestedPath);
                return nestedPath === ignored;
            });
            if (hasMatches) continue;
        }
        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
        if (result.wasMutated) return result;
    }
    return {
        wasMutated: false
    };
}
function createImmutableStateInvariantMiddleware(options = {}) {
    var next, action;
    {
        let stringify2 = function(obj, serializer, indent, decycler) {
            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
        }, getSerialize2 = function(serializer, decycler) {
            let stack = [], keys = [];
            if (!decycler) decycler = function(_, value) {
                if (stack[0] === value) return "[Circular ~]";
                return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
            };
            return function(key, value) {
                if (stack.length > 0) {
                    var thisPos = stack.indexOf(this);
                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);
                } else stack.push(value);
                return serializer == null ? value : serializer.call(this, key, value);
            };
        };
        var stringify = stringify2, getSerialize = getSerialize2;
        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;
        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
        return ({ getState })=>{
            let state = getState();
            let tracker = track(state);
            let result;
            return (next)=>(action)=>{
                    const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
                    measureUtils.measureTime(()=>{
                        state = getState();
                        result = tracker.detectMutations();
                        tracker = track(state);
                        if (result.wasMutated) throw new Error(`A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
                    });
                    const dispatchedAction = next(action);
                    measureUtils.measureTime(()=>{
                        state = getState();
                        result = tracker.detectMutations();
                        tracker = track(state);
                        if (result.wasMutated) throw new Error(`A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
                    });
                    measureUtils.warnIfExceeded();
                    return dispatchedAction;
                };
        };
    }
}
function isPlain(val) {
    const type = typeof val;
    return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || (0, _redux.isPlainObject)(val);
}
function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {
    let foundNestedSerializable;
    if (!isSerializable(value)) return {
        keyPath: path || "<root>",
        value
    };
    if (typeof value !== "object" || value === null) return false;
    if (cache == null ? void 0 : cache.has(value)) return false;
    const entries = getEntries != null ? getEntries(value) : Object.entries(value);
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for (const [key, nestedValue] of entries){
        const nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths) {
            const hasMatches = ignoredPaths.some((ignored)=>{
                if (ignored instanceof RegExp) return ignored.test(nestedPath);
                return nestedPath === ignored;
            });
            if (hasMatches) continue;
        }
        if (!isSerializable(nestedValue)) return {
            keyPath: nestedPath,
            value: nestedValue
        };
        if (typeof nestedValue === "object") {
            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
            if (foundNestedSerializable) return foundNestedSerializable;
        }
    }
    if (cache && isNestedFrozen(value)) cache.add(value);
    return false;
}
function isNestedFrozen(value) {
    if (!Object.isFrozen(value)) return false;
    for (const nestedValue of Object.values(value)){
        if (typeof nestedValue !== "object" || nestedValue === null) continue;
        if (!isNestedFrozen(nestedValue)) return false;
    }
    return true;
}
function createSerializableStateInvariantMiddleware(options = {}) {
    var next, action;
    {
        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [
            "meta.arg",
            "meta.baseQueryMeta"
        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;
        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
        return (storeAPI)=>(next)=>(action)=>{
                    if (!(0, _redux.isAction)(action)) return next(action);
                    const result = next(action);
                    const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) measureUtils.measureTime(()=>{
                        const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
                        if (foundActionNonSerializableValue) {
                            const { keyPath, value } = foundActionNonSerializableValue;
                            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
                        }
                    });
                    if (!ignoreState) {
                        measureUtils.measureTime(()=>{
                            const state = storeAPI.getState();
                            const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
                            if (foundStateNonSerializableValue) {
                                const { keyPath, value } = foundStateNonSerializableValue;
                                console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
                            }
                        });
                        measureUtils.warnIfExceeded();
                    }
                    return result;
                };
    }
}
// src/getDefaultMiddleware.ts
function isBoolean(x) {
    return typeof x === "boolean";
}
var buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {
        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options != null ? options : {};
        let middlewareArray = new Tuple();
        if (thunk) {
            if (isBoolean(thunk)) middlewareArray.push((0, _reduxThunk.thunk));
            else middlewareArray.push((0, _reduxThunk.withExtraArgument)(thunk.extraArgument));
        }
        if (immutableCheck) {
            let immutableOptions = {};
            if (!isBoolean(immutableCheck)) immutableOptions = immutableCheck;
            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
        }
        if (serializableCheck) {
            let serializableOptions = {};
            if (!isBoolean(serializableCheck)) serializableOptions = serializableCheck;
            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
        }
        if (actionCreatorCheck) {
            let actionCreatorOptions = {};
            if (!isBoolean(actionCreatorCheck)) actionCreatorOptions = actionCreatorCheck;
            middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
        }
        return middlewareArray;
    };
// src/autoBatchEnhancer.ts
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = ()=>(payload)=>({
            payload,
            meta: {
                [SHOULD_AUTOBATCH]: true
            }
        });
var createQueueWithTimer = (timeout)=>{
    return (notify)=>{
        setTimeout(notify, timeout);
    };
};
var rAF = typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);
var autoBatchEnhancer = (options = {
    type: "raf"
})=>(next)=>(...args)=>{
            const store = next(...args);
            let notifying = true;
            let shouldNotifyAtEndOfTick = false;
            let notificationQueued = false;
            const listeners = /* @__PURE__ */ new Set();
            const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? rAF : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
            const notifyListeners = ()=>{
                notificationQueued = false;
                if (shouldNotifyAtEndOfTick) {
                    shouldNotifyAtEndOfTick = false;
                    listeners.forEach((l)=>l());
                }
            };
            return Object.assign({}, store, {
                // Override the base `store.subscribe` method to keep original listeners
                // from running if we're delaying notifications
                subscribe (listener2) {
                    const wrappedListener = ()=>notifying && listener2();
                    const unsubscribe = store.subscribe(wrappedListener);
                    listeners.add(listener2);
                    return ()=>{
                        unsubscribe();
                        listeners.delete(listener2);
                    };
                },
                // Override the base `store.dispatch` method so that we can check actions
                // for the `shouldAutoBatch` flag and determine if batching is active
                dispatch (action) {
                    var _a;
                    try {
                        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
                        shouldNotifyAtEndOfTick = !notifying;
                        if (shouldNotifyAtEndOfTick) {
                            if (!notificationQueued) {
                                notificationQueued = true;
                                queueCallback(notifyListeners);
                            }
                        }
                        return store.dispatch(action);
                    } finally{
                        notifying = true;
                    }
                }
            });
        };
// src/getDefaultEnhancers.ts
var buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {
        const { autoBatch = true } = options != null ? options : {};
        let enhancerArray = new Tuple(middlewareEnhancer);
        if (autoBatch) enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
        return enhancerArray;
    };
// src/configureStore.ts
var IS_PRODUCTION = false;
function configureStore(options) {
    const getDefaultMiddleware = buildGetDefaultMiddleware();
    const { reducer, middleware, devTools = true, preloadedState, enhancers } = options || {};
    let rootReducer;
    if (typeof reducer === "function") rootReducer = reducer;
    else if ((0, _redux.isPlainObject)(reducer)) rootReducer = (0, _redux.combineReducers)(reducer);
    else throw new Error("`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
    if (!IS_PRODUCTION && middleware && typeof middleware !== "function") throw new Error("`middleware` field must be a callback");
    let finalMiddleware;
    if (typeof middleware === "function") {
        finalMiddleware = middleware(getDefaultMiddleware);
        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) throw new Error("when using a middleware builder function, an array of middleware must be returned");
    } else finalMiddleware = getDefaultMiddleware();
    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== "function")) throw new Error("each middleware provided to configureStore must be a function");
    let finalCompose = (0, _redux.compose);
    if (devTools) finalCompose = composeWithDevTools(__spreadValues({
        // Enable capture of stack traces for dispatched Redux actions
        trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
    const middlewareEnhancer = (0, _redux.applyMiddleware)(...finalMiddleware);
    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
    if (!IS_PRODUCTION && enhancers && typeof enhancers !== "function") throw new Error("`enhancers` field must be a callback");
    let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) throw new Error("`enhancers` callback must return an array");
    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== "function")) throw new Error("each enhancer provided to configureStore must be a function");
    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
    const composedEnhancer = finalCompose(...storeEnhancers);
    return (0, _redux.createStore)(rootReducer, preloadedState, composedEnhancer);
}
// src/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
    const actionsMap = {};
    const actionMatchers = [];
    let defaultCaseReducer;
    const builder = {
        addCase (typeOrActionCreator, reducer) {
            if (actionMatchers.length > 0) throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
            if (defaultCaseReducer) throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
            const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (!type) throw new Error("`builder.addCase` cannot be called with an empty action type");
            if (type in actionsMap) throw new Error(`\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
            actionsMap[type] = reducer;
            return builder;
        },
        addMatcher (matcher, reducer) {
            if (defaultCaseReducer) throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
            actionMatchers.push({
                matcher,
                reducer
            });
            return builder;
        },
        addDefaultCase (reducer) {
            if (defaultCaseReducer) throw new Error("`builder.addDefaultCase` can only be called once");
            defaultCaseReducer = reducer;
            return builder;
        }
    };
    builderCallback(builder);
    return [
        actionsMap,
        actionMatchers,
        defaultCaseReducer
    ];
}
// src/createReducer.ts
function isStateFunction(x) {
    return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback) {
    if (typeof mapOrBuilderCallback === "object") throw new Error("The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
    let getInitialState;
    if (isStateFunction(initialState)) getInitialState = ()=>freezeDraftable(initialState());
    else {
        const frozenInitialState = freezeDraftable(initialState);
        getInitialState = ()=>frozenInitialState;
    }
    function reducer(state = getInitialState(), action) {
        let caseReducers = [
            actionsMap[action.type],
            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)
        ];
        if (caseReducers.filter((cr)=>!!cr).length === 0) caseReducers = [
            finalDefaultCaseReducer
        ];
        return caseReducers.reduce((previousState, caseReducer)=>{
            if (caseReducer) {
                if ((0, _immer.isDraft)(previousState)) {
                    const draft = previousState;
                    const result = caseReducer(draft, action);
                    if (result === void 0) return previousState;
                    return result;
                } else if (!(0, _immer.isDraftable)(previousState)) {
                    const result = caseReducer(previousState, action);
                    if (result === void 0) {
                        if (previousState === null) return previousState;
                        throw new Error("A case reducer on a non-draftable value must not return undefined");
                    }
                    return result;
                } else return (0, _immer.produce)(previousState, (draft)=>{
                    return caseReducer(draft, action);
                });
            }
            return previousState;
        }, state);
    }
    reducer.getInitialState = getInitialState;
    return reducer;
}
// src/nanoid.ts
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21)=>{
    let id = "";
    let i = size;
    while(i--)id += urlAlphabet[Math.random() * 64 | 0];
    return id;
};
// src/matchers.ts
var matches = (matcher, action)=>{
    if (hasMatchFunction(matcher)) return matcher.match(action);
    else return matcher(action);
};
function isAnyOf(...matchers) {
    return (action)=>{
        return matchers.some((matcher)=>matches(matcher, action));
    };
}
function isAllOf(...matchers) {
    return (action)=>{
        return matchers.every((matcher)=>matches(matcher, action));
    };
}
function hasExpectedRequestMetadata(action, validStatus) {
    if (!action || !action.meta) return false;
    const hasValidRequestId = typeof action.meta.requestId === "string";
    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
    return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a) {
    return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
}
function isPending(...asyncThunks) {
    if (asyncThunks.length === 0) return (action)=>hasExpectedRequestMetadata(action, [
            "pending"
        ]);
    if (!isAsyncThunkArray(asyncThunks)) return isPending()(asyncThunks[0]);
    return (action)=>{
        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);
        const combinedMatcher = isAnyOf(...matchers);
        return combinedMatcher(action);
    };
}
function isRejected(...asyncThunks) {
    if (asyncThunks.length === 0) return (action)=>hasExpectedRequestMetadata(action, [
            "rejected"
        ]);
    if (!isAsyncThunkArray(asyncThunks)) return isRejected()(asyncThunks[0]);
    return (action)=>{
        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);
        const combinedMatcher = isAnyOf(...matchers);
        return combinedMatcher(action);
    };
}
function isRejectedWithValue(...asyncThunks) {
    const hasFlag = (action)=>{
        return action && action.meta && action.meta.rejectedWithValue;
    };
    if (asyncThunks.length === 0) return (action)=>{
        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);
        return combinedMatcher(action);
    };
    if (!isAsyncThunkArray(asyncThunks)) return isRejectedWithValue()(asyncThunks[0]);
    return (action)=>{
        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);
        return combinedMatcher(action);
    };
}
function isFulfilled(...asyncThunks) {
    if (asyncThunks.length === 0) return (action)=>hasExpectedRequestMetadata(action, [
            "fulfilled"
        ]);
    if (!isAsyncThunkArray(asyncThunks)) return isFulfilled()(asyncThunks[0]);
    return (action)=>{
        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);
        const combinedMatcher = isAnyOf(...matchers);
        return combinedMatcher(action);
    };
}
function isAsyncThunkAction(...asyncThunks) {
    if (asyncThunks.length === 0) return (action)=>hasExpectedRequestMetadata(action, [
            "pending",
            "fulfilled",
            "rejected"
        ]);
    if (!isAsyncThunkArray(asyncThunks)) return isAsyncThunkAction()(asyncThunks[0]);
    return (action)=>{
        const matchers = [];
        for (const asyncThunk of asyncThunks)matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);
        const combinedMatcher = isAnyOf(...matchers);
        return combinedMatcher(action);
    };
}
// src/createAsyncThunk.ts
var commonProperties = [
    "name",
    "message",
    "stack",
    "code"
];
var RejectWithValue = class {
    constructor(payload, meta){
        this.payload = payload;
        this.meta = meta;
        /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */ __publicField(this, "_type");
    }
};
var FulfillWithMeta = class {
    constructor(payload, meta){
        this.payload = payload;
        this.meta = meta;
        /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */ __publicField(this, "_type");
    }
};
var miniSerializeError = (value)=>{
    if (typeof value === "object" && value !== null) {
        const simpleError = {};
        for (const property of commonProperties)if (typeof value[property] === "string") simpleError[property] = value[property];
        return simpleError;
    }
    return {
        message: String(value)
    };
};
var createAsyncThunk = /* @__PURE__ */ (()=>{
    function createAsyncThunk2(typePrefix, payloadCreator, options) {
        const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta)=>({
                payload,
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                    arg,
                    requestId,
                    requestStatus: "fulfilled"
                })
            }));
        const pending = createAction(typePrefix + "/pending", (requestId, arg, meta)=>({
                payload: void 0,
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                    arg,
                    requestId,
                    requestStatus: "pending"
                })
            }));
        const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta)=>({
                payload,
                error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                    arg,
                    requestId,
                    rejectedWithValue: !!payload,
                    requestStatus: "rejected",
                    aborted: (error == null ? void 0 : error.name) === "AbortError",
                    condition: (error == null ? void 0 : error.name) === "ConditionError"
                })
            }));
        function actionCreator(arg) {
            return (dispatch, getState, extra)=>{
                const requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
                const abortController = new AbortController();
                let abortHandler;
                let abortReason;
                function abort(reason) {
                    abortReason = reason;
                    abortController.abort();
                }
                const promise = async function() {
                    var _a, _b;
                    let finalAction;
                    try {
                        let conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {
                            getState,
                            extra
                        });
                        if (isThenable(conditionResult)) conditionResult = await conditionResult;
                        if (conditionResult === false || abortController.signal.aborted) throw {
                            name: "ConditionError",
                            message: "Aborted due to condition callback returning false."
                        };
                        const abortedPromise = new Promise((_, reject)=>{
                            abortHandler = ()=>{
                                reject({
                                    name: "AbortError",
                                    message: abortReason || "Aborted"
                                });
                            };
                            abortController.signal.addEventListener("abort", abortHandler);
                        });
                        dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {
                            requestId,
                            arg
                        }, {
                            getState,
                            extra
                        })));
                        finalAction = await Promise.race([
                            abortedPromise,
                            Promise.resolve(payloadCreator(arg, {
                                dispatch,
                                getState,
                                extra,
                                requestId,
                                signal: abortController.signal,
                                abort,
                                rejectWithValue: (value, meta)=>{
                                    return new RejectWithValue(value, meta);
                                },
                                fulfillWithValue: (value, meta)=>{
                                    return new FulfillWithMeta(value, meta);
                                }
                            })).then((result)=>{
                                if (result instanceof RejectWithValue) throw result;
                                if (result instanceof FulfillWithMeta) return fulfilled(result.payload, requestId, arg, result.meta);
                                return fulfilled(result, requestId, arg);
                            })
                        ]);
                    } catch (err) {
                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
                    } finally{
                        if (abortHandler) abortController.signal.removeEventListener("abort", abortHandler);
                    }
                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                    if (!skipDispatch) dispatch(finalAction);
                    return finalAction;
                }();
                return Object.assign(promise, {
                    abort,
                    requestId,
                    arg,
                    unwrap () {
                        return promise.then(unwrapResult);
                    }
                });
            };
        }
        return Object.assign(actionCreator, {
            pending,
            rejected,
            fulfilled,
            settled: isAnyOf(rejected, fulfilled),
            typePrefix
        });
    }
    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;
    return createAsyncThunk2;
})();
function unwrapResult(action) {
    if (action.meta && action.meta.rejectedWithValue) throw action.payload;
    if (action.error) throw action.error;
    return action.payload;
}
function isThenable(value) {
    return value !== null && typeof value === "object" && typeof value.then === "function";
}
// src/createSlice.ts
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = {
    [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = /* @__PURE__ */ ((ReducerType2)=>{
    ReducerType2["reducer"] = "reducer";
    ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
    ReducerType2["asyncThunk"] = "asyncThunk";
    return ReducerType2;
})(ReducerType || {});
function getType(slice, actionKey) {
    return `${slice}/${actionKey}`;
}
function buildCreateSlice({ creators } = {}) {
    var _a;
    const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
    return function createSlice2(options) {
        const { name, reducerPath = name } = options;
        if (!name) throw new Error("`name` is a required option for createSlice");
        if (typeof process !== "undefined" && true) {
            if (options.initialState === void 0) console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
        const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
        const reducerNames = Object.keys(reducers);
        const context = {
            sliceCaseReducersByName: {},
            sliceCaseReducersByType: {},
            actionCreators: {},
            sliceMatchers: []
        };
        const contextMethods = {
            addCase (typeOrActionCreator, reducer2) {
                const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
                if (!type) throw new Error("`context.addCase` cannot be called with an empty action type");
                if (type in context.sliceCaseReducersByType) throw new Error("`context.addCase` cannot be called with two reducers for the same action type: " + type);
                context.sliceCaseReducersByType[type] = reducer2;
                return contextMethods;
            },
            addMatcher (matcher, reducer2) {
                context.sliceMatchers.push({
                    matcher,
                    reducer: reducer2
                });
                return contextMethods;
            },
            exposeAction (name2, actionCreator) {
                context.actionCreators[name2] = actionCreator;
                return contextMethods;
            },
            exposeCaseReducer (name2, reducer2) {
                context.sliceCaseReducersByName[name2] = reducer2;
                return contextMethods;
            }
        };
        reducerNames.forEach((reducerName)=>{
            const reducerDefinition = reducers[reducerName];
            const reducerDetails = {
                reducerName,
                type: getType(name, reducerName),
                createNotation: typeof options.reducers === "function"
            };
            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
            else handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
        });
        function buildReducer() {
            if (typeof options.extraReducers === "object") throw new Error("The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [
                options.extraReducers
            ];
            const finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), context.sliceCaseReducersByType);
            return createReducer(options.initialState, (builder)=>{
                for(let key in finalCaseReducers)builder.addCase(key, finalCaseReducers[key]);
                for (let sM of context.sliceMatchers)builder.addMatcher(sM.matcher, sM.reducer);
                for (let m of actionMatchers)builder.addMatcher(m.matcher, m.reducer);
                if (defaultCaseReducer) builder.addDefaultCase(defaultCaseReducer);
            });
        }
        const selectSelf = (state)=>state;
        const injectedSelectorCache = /* @__PURE__ */ new Map();
        let _reducer;
        function reducer(state, action) {
            if (!_reducer) _reducer = buildReducer();
            return _reducer(state, action);
        }
        function getInitialState() {
            if (!_reducer) _reducer = buildReducer();
            return _reducer.getInitialState();
        }
        function makeSelectorProps(reducerPath2, injected = false) {
            function selectSlice(state) {
                let sliceState = state[reducerPath2];
                if (typeof sliceState === "undefined") {
                    if (injected) sliceState = getInitialState();
                    else throw new Error("selectSlice returned undefined for an uninjected slice reducer");
                }
                return sliceState;
            }
            function getSelectors(selectState = selectSelf) {
                const selectorCache = emplace(injectedSelectorCache, injected, {
                    insert: ()=>/* @__PURE__ */ new WeakMap()
                });
                return emplace(selectorCache, selectState, {
                    insert: ()=>{
                        var _a2;
                        const map = {};
                        for (const [name2, selector] of Object.entries((_a2 = options.selectors) != null ? _a2 : {}))map[name2] = wrapSelector(selector, selectState, getInitialState, injected);
                        return map;
                    }
                });
            }
            return {
                reducerPath: reducerPath2,
                getSelectors,
                get selectors () {
                    return getSelectors(selectSlice);
                },
                selectSlice
            };
        }
        const slice = __spreadProps(__spreadValues({
            name,
            reducer,
            actions: context.actionCreators,
            caseReducers: context.sliceCaseReducersByName,
            getInitialState
        }, makeSelectorProps(reducerPath)), {
            injectInto (injectable, _a2 = {}) {
                var _b = _a2, { reducerPath: pathOpt } = _b, config = __objRest(_b, [
                    "reducerPath"
                ]);
                const newReducerPath = pathOpt != null ? pathOpt : reducerPath;
                injectable.inject({
                    reducerPath: newReducerPath,
                    reducer
                }, config);
                return __spreadValues(__spreadValues({}, slice), makeSelectorProps(newReducerPath, true));
            }
        });
        return slice;
    };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
    function wrapper(rootState, ...args) {
        let sliceState = selectState(rootState);
        if (typeof sliceState === "undefined") {
            if (injected) sliceState = getInitialState();
            else throw new Error("selectState returned undefined for an uninjected slice reducer");
        }
        return selector(sliceState, ...args);
    }
    wrapper.unwrapped = selector;
    return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
    function asyncThunk(payloadCreator, config) {
        return __spreadValues({
            _reducerDefinitionType: "asyncThunk" /* asyncThunk */ ,
            payloadCreator
        }, config);
    }
    asyncThunk.withTypes = ()=>asyncThunk;
    return {
        reducer (caseReducer) {
            return Object.assign({
                // hack so the wrapping function has the same name as the original
                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
                [caseReducer.name] (...args) {
                    return caseReducer(...args);
                }
            }[caseReducer.name], {
                _reducerDefinitionType: "reducer" /* reducer */ 
            });
        },
        preparedReducer (prepare, reducer) {
            return {
                _reducerDefinitionType: "reducerWithPrepare" /* reducerWithPrepare */ ,
                prepare,
                reducer
            };
        },
        asyncThunk
    };
}
function handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) throw new Error("Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
        caseReducer = maybeReducerWithPrepare.reducer;
        prepareCallback = maybeReducerWithPrepare.prepare;
    } else caseReducer = maybeReducerWithPrepare;
    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "asyncThunk" /* asyncThunk */ ;
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "reducerWithPrepare" /* reducerWithPrepare */ ;
}
function handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {
    if (!cAT) throw new Error("Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;
    const thunk = cAT(type, payloadCreator, options);
    context.exposeAction(reducerName, thunk);
    if (fulfilled) context.addCase(thunk.fulfilled, fulfilled);
    if (pending) context.addCase(thunk.pending, pending);
    if (rejected) context.addCase(thunk.rejected, rejected);
    if (settled) context.addMatcher(thunk.settled, settled);
    context.exposeCaseReducer(reducerName, {
        fulfilled: fulfilled || noop,
        pending: pending || noop,
        rejected: rejected || noop,
        settled: settled || noop
    });
}
function noop() {}
// src/entities/entity_state.ts
function getInitialEntityState() {
    return {
        ids: [],
        entities: {}
    };
}
function createInitialStateFactory(stateAdapter) {
    function getInitialState(additionalState = {}, entities) {
        const state = Object.assign(getInitialEntityState(), additionalState);
        return entities ? stateAdapter.setAll(state, entities) : state;
    }
    return {
        getInitialState
    };
}
// src/entities/state_selectors.ts
function createSelectorsFactory() {
    function getSelectors(selectState, options = {}) {
        const { createSelector: createSelector2 = createDraftSafeSelector } = options;
        const selectIds = (state)=>state.ids;
        const selectEntities = (state)=>state.entities;
        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));
        const selectId = (_, id)=>id;
        const selectById = (entities, id)=>entities[id];
        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);
        if (!selectState) return {
            selectIds,
            selectEntities,
            selectAll,
            selectTotal,
            selectById: createSelector2(selectEntities, selectId, selectById)
        };
        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);
        return {
            selectIds: createSelector2(selectState, selectIds),
            selectEntities: selectGlobalizedEntities,
            selectAll: createSelector2(selectState, selectAll),
            selectTotal: createSelector2(selectState, selectTotal),
            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)
        };
    }
    return {
        getSelectors
    };
}
var isDraftTyped = (0, _immer.isDraft);
function createSingleArgumentStateOperator(mutator) {
    const operator = createStateOperator((_, state)=>mutator(state));
    return function operation(state) {
        return operator(state, void 0);
    };
}
function createStateOperator(mutator) {
    return function operation(state, arg) {
        function isPayloadActionArgument(arg2) {
            return isFSA(arg2);
        }
        const runMutator = (draft)=>{
            if (isPayloadActionArgument(arg)) mutator(arg.payload, draft);
            else mutator(arg, draft);
        };
        if (isDraftTyped(state)) {
            runMutator(state);
            return state;
        }
        return (0, _immer.produce)(state, runMutator);
    };
}
// src/entities/utils.ts
function selectIdValue(entity, selectId) {
    const key = selectId(entity);
    if (key === void 0) console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", entity, "The `selectId` implementation:", selectId.toString());
    return key;
}
function ensureEntitiesArray(entities) {
    if (!Array.isArray(entities)) entities = Object.values(entities);
    return entities;
}
function splitAddedUpdatedEntities(newEntities, selectId, state) {
    newEntities = ensureEntitiesArray(newEntities);
    const added = [];
    const updated = [];
    for (const entity of newEntities){
        const id = selectIdValue(entity, selectId);
        if (id in state.entities) updated.push({
            id,
            changes: entity
        });
        else added.push(entity);
    }
    return [
        added,
        updated
    ];
}
// src/entities/unsorted_state_adapter.ts
function createUnsortedStateAdapter(selectId) {
    function addOneMutably(entity, state) {
        const key = selectIdValue(entity, selectId);
        if (key in state.entities) return;
        state.ids.push(key);
        state.entities[key] = entity;
    }
    function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (const entity of newEntities)addOneMutably(entity, state);
    }
    function setOneMutably(entity, state) {
        const key = selectIdValue(entity, selectId);
        if (!(key in state.entities)) state.ids.push(key);
        state.entities[key] = entity;
    }
    function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (const entity of newEntities)setOneMutably(entity, state);
    }
    function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.ids = [];
        state.entities = {};
        addManyMutably(newEntities, state);
    }
    function removeOneMutably(key, state) {
        return removeManyMutably([
            key
        ], state);
    }
    function removeManyMutably(keys, state) {
        let didMutate = false;
        keys.forEach((key)=>{
            if (key in state.entities) {
                delete state.entities[key];
                didMutate = true;
            }
        });
        if (didMutate) state.ids = state.ids.filter((id)=>id in state.entities);
    }
    function removeAllMutably(state) {
        Object.assign(state, {
            ids: [],
            entities: {}
        });
    }
    function takeNewKey(keys, update, state) {
        const original3 = state.entities[update.id];
        if (original3 === void 0) return false;
        const updated = Object.assign({}, original3, update.changes);
        const newKey = selectIdValue(updated, selectId);
        const hasNewKey = newKey !== update.id;
        if (hasNewKey) {
            keys[update.id] = newKey;
            delete state.entities[update.id];
        }
        state.entities[newKey] = updated;
        return hasNewKey;
    }
    function updateOneMutably(update, state) {
        return updateManyMutably([
            update
        ], state);
    }
    function updateManyMutably(updates, state) {
        const newKeys = {};
        const updatesPerEntity = {};
        updates.forEach((update)=>{
            if (update.id in state.entities) updatesPerEntity[update.id] = {
                id: update.id,
                // Spreads ignore falsy values, so this works even if there isn't
                // an existing update already at this key
                changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)
            };
        });
        updates = Object.values(updatesPerEntity);
        const didMutateEntities = updates.length > 0;
        if (didMutateEntities) {
            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;
            if (didMutateIds) state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));
        }
    }
    function upsertOneMutably(entity, state) {
        return upsertManyMutably([
            entity
        ], state);
    }
    function upsertManyMutably(newEntities, state) {
        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
        updateManyMutably(updated, state);
        addManyMutably(added, state);
    }
    return {
        removeAll: createSingleArgumentStateOperator(removeAllMutably),
        addOne: createStateOperator(addOneMutably),
        addMany: createStateOperator(addManyMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        updateOne: createStateOperator(updateOneMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        upsertMany: createStateOperator(upsertManyMutably),
        removeOne: createStateOperator(removeOneMutably),
        removeMany: createStateOperator(removeManyMutably)
    };
}
// src/entities/sorted_state_adapter.ts
function createSortedStateAdapter(selectId, sort) {
    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);
    function addOneMutably(entity, state) {
        return addManyMutably([
            entity
        ], state);
    }
    function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));
        if (models.length !== 0) merge(models, state);
    }
    function setOneMutably(entity, state) {
        return setManyMutably([
            entity
        ], state);
    }
    function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        if (newEntities.length !== 0) merge(newEntities, state);
    }
    function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.entities = {};
        state.ids = [];
        addManyMutably(newEntities, state);
    }
    function updateOneMutably(update, state) {
        return updateManyMutably([
            update
        ], state);
    }
    function updateManyMutably(updates, state) {
        let appliedUpdates = false;
        for (let update of updates){
            const entity = state.entities[update.id];
            if (!entity) continue;
            appliedUpdates = true;
            Object.assign(entity, update.changes);
            const newId = selectId(entity);
            if (update.id !== newId) {
                delete state.entities[update.id];
                state.entities[newId] = entity;
            }
        }
        if (appliedUpdates) resortEntities(state);
    }
    function upsertOneMutably(entity, state) {
        return upsertManyMutably([
            entity
        ], state);
    }
    function upsertManyMutably(newEntities, state) {
        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
        updateManyMutably(updated, state);
        addManyMutably(added, state);
    }
    function areArraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length && i < b.length; i++){
            if (a[i] === b[i]) continue;
            return false;
        }
        return true;
    }
    function merge(models, state) {
        models.forEach((model)=>{
            state.entities[selectId(model)] = model;
        });
        resortEntities(state);
    }
    function resortEntities(state) {
        const allEntities = Object.values(state.entities);
        allEntities.sort(sort);
        const newSortedIds = allEntities.map(selectId);
        const { ids } = state;
        if (!areArraysEqual(ids, newSortedIds)) state.ids = newSortedIds;
    }
    return {
        removeOne,
        removeMany,
        removeAll,
        addOne: createStateOperator(addOneMutably),
        updateOne: createStateOperator(updateOneMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        addMany: createStateOperator(addManyMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertMany: createStateOperator(upsertManyMutably)
    };
}
// src/entities/create_adapter.ts
function createEntityAdapter(options = {}) {
    const { selectId, sortComparer } = __spreadValues({
        sortComparer: false,
        selectId: (instance)=>instance.id
    }, options);
    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
    const stateFactory = createInitialStateFactory(stateAdapter);
    const selectorsFactory = createSelectorsFactory();
    return __spreadValues(__spreadValues(__spreadValues({
        selectId,
        sortComparer
    }, stateFactory), selectorsFactory), stateAdapter);
}
// src/listenerMiddleware/exceptions.ts
var task = "task";
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = `task-${cancelled}`;
var taskCompleted = `task-${completed}`;
var listenerCancelled = `${listener}-${cancelled}`;
var listenerCompleted = `${listener}-${completed}`;
var TaskAbortError = class {
    constructor(code){
        this.code = code;
        __publicField(this, "name", "TaskAbortError");
        __publicField(this, "message");
        this.message = `${task} ${cancelled} (reason: ${code})`;
    }
};
// src/listenerMiddleware/utils.ts
var assertFunction = (func, expected)=>{
    if (typeof func !== "function") throw new Error(`${expected} is not a function`);
};
var noop2 = ()=>{};
var catchRejection = (promise, onError = noop2)=>{
    promise.catch(onError);
    return promise;
};
var addAbortSignalListener = (abortSignal, callback)=>{
    abortSignal.addEventListener("abort", callback, {
        once: true
    });
    return ()=>abortSignal.removeEventListener("abort", callback);
};
var abortControllerWithReason = (abortController, reason)=>{
    const signal = abortController.signal;
    if (signal.aborted) return;
    if (!("reason" in signal)) Object.defineProperty(signal, "reason", {
        enumerable: true,
        value: reason,
        configurable: true,
        writable: true
    });
    abortController.abort(reason);
};
// src/listenerMiddleware/task.ts
var validateActive = (signal)=>{
    if (signal.aborted) {
        const { reason } = signal;
        throw new TaskAbortError(reason);
    }
};
function raceWithSignal(signal, promise) {
    let cleanup = noop2;
    return new Promise((resolve, reject)=>{
        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));
        if (signal.aborted) {
            notifyRejection();
            return;
        }
        cleanup = addAbortSignalListener(signal, notifyRejection);
        promise.finally(()=>cleanup()).then(resolve, reject);
    }).finally(()=>{
        cleanup = noop2;
    });
}
var runTask = async (task2, cleanUp)=>{
    try {
        await Promise.resolve();
        const value = await task2();
        return {
            status: "ok",
            value
        };
    } catch (error) {
        return {
            status: error instanceof TaskAbortError ? "cancelled" : "rejected",
            error
        };
    } finally{
        cleanUp == null || cleanUp();
    }
};
var createPause = (signal)=>{
    return (promise)=>{
        return catchRejection(raceWithSignal(signal, promise).then((output)=>{
            validateActive(signal);
            return output;
        }));
    };
};
var createDelay = (signal)=>{
    const pause = createPause(signal);
    return (timeoutMs)=>{
        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));
    };
};
// src/listenerMiddleware/index.ts
var { assign } = Object;
var INTERNAL_NIL_TOKEN = {};
var alm = "listenerMiddleware";
var createFork = (parentAbortSignal, parentBlockingPromises)=>{
    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));
    return (taskExecutor, opts)=>{
        assertFunction(taskExecutor, "taskExecutor");
        const childAbortController = new AbortController();
        linkControllers(childAbortController);
        const result = runTask(async ()=>{
            validateActive(parentAbortSignal);
            validateActive(childAbortController.signal);
            const result2 = await taskExecutor({
                pause: createPause(childAbortController.signal),
                delay: createDelay(childAbortController.signal),
                signal: childAbortController.signal
            });
            validateActive(childAbortController.signal);
            return result2;
        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));
        if (opts == null ? void 0 : opts.autoJoin) parentBlockingPromises.push(result.catch(noop2));
        return {
            result: createPause(parentAbortSignal)(result),
            cancel () {
                abortControllerWithReason(childAbortController, taskCancelled);
            }
        };
    };
};
var createTakePattern = (startListening, signal)=>{
    const take = async (predicate, timeout)=>{
        validateActive(signal);
        let unsubscribe = ()=>{};
        const tuplePromise = new Promise((resolve, reject)=>{
            let stopListening = startListening({
                predicate,
                effect: (action, listenerApi)=>{
                    listenerApi.unsubscribe();
                    resolve([
                        action,
                        listenerApi.getState(),
                        listenerApi.getOriginalState()
                    ]);
                }
            });
            unsubscribe = ()=>{
                stopListening();
                reject();
            };
        });
        const promises = [
            tuplePromise
        ];
        if (timeout != null) promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));
        try {
            const output = await raceWithSignal(signal, Promise.race(promises));
            validateActive(signal);
            return output;
        } finally{
            unsubscribe();
        }
    };
    return (predicate, timeout)=>catchRejection(take(predicate, timeout));
};
var getListenerEntryPropsFrom = (options)=>{
    let { type, actionCreator, matcher, predicate, effect } = options;
    if (type) predicate = createAction(type).match;
    else if (actionCreator) {
        type = actionCreator.type;
        predicate = actionCreator.match;
    } else if (matcher) predicate = matcher;
    else if (predicate) ;
    else throw new Error("Creating or removing a listener requires one of the known fields for matching an action");
    assertFunction(effect, "options.listener");
    return {
        predicate,
        type,
        effect
    };
};
var createListenerEntry = Object.assign((options)=>{
    const { type, predicate, effect } = getListenerEntryPropsFrom(options);
    const id = nanoid();
    const entry = {
        id,
        effect,
        type,
        predicate,
        pending: /* @__PURE__ */ new Set(),
        unsubscribe: ()=>{
            throw new Error("Unsubscribe not initialized");
        }
    };
    return entry;
}, {
    withTypes: ()=>createListenerEntry
});
var cancelActiveListeners = (entry)=>{
    entry.pending.forEach((controller)=>{
        abortControllerWithReason(controller, listenerCancelled);
    });
};
var createClearListenerMiddleware = (listenerMap)=>{
    return ()=>{
        listenerMap.forEach(cancelActiveListeners);
        listenerMap.clear();
    };
};
var safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{
    try {
        errorHandler(errorToNotify, errorInfo);
    } catch (errorHandlerError) {
        setTimeout(()=>{
            throw errorHandlerError;
        }, 0);
    }
};
var addListener = Object.assign(createAction(`${alm}/add`), {
    withTypes: ()=>addListener
});
var clearAllListeners = createAction(`${alm}/removeAll`);
var removeListener = Object.assign(createAction(`${alm}/remove`), {
    withTypes: ()=>removeListener
});
var defaultErrorHandler = (...args)=>{
    console.error(`${alm}/error`, ...args);
};
var createListenerMiddleware = (middlewareOptions = {})=>{
    const listenerMap = /* @__PURE__ */ new Map();
    const { extra, onError = defaultErrorHandler } = middlewareOptions;
    assertFunction(onError, "onError");
    const insertEntry = (entry)=>{
        entry.unsubscribe = ()=>listenerMap.delete(entry.id);
        listenerMap.set(entry.id, entry);
        return (cancelOptions)=>{
            entry.unsubscribe();
            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) cancelActiveListeners(entry);
        };
    };
    const startListening = (options)=>{
        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);
        if (!entry) entry = createListenerEntry(options);
        return insertEntry(entry);
    };
    Object.assign(startListening, {
        withTypes: ()=>startListening
    });
    const stopListening = (options)=>{
        const { type, effect, predicate } = getListenerEntryPropsFrom(options);
        const entry = find(Array.from(listenerMap.values()), (entry2)=>{
            const matchPredicateOrType = typeof type === "string" ? entry2.type === type : entry2.predicate === predicate;
            return matchPredicateOrType && entry2.effect === effect;
        });
        if (entry) {
            entry.unsubscribe();
            if (options.cancelActive) cancelActiveListeners(entry);
        }
        return !!entry;
    };
    Object.assign(stopListening, {
        withTypes: ()=>stopListening
    });
    const notifyListener = async (entry, action, api, getOriginalState)=>{
        const internalTaskController = new AbortController();
        const take = createTakePattern(startListening, internalTaskController.signal);
        const autoJoinPromises = [];
        try {
            entry.pending.add(internalTaskController);
            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle
            assign({}, api, {
                getOriginalState,
                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),
                take,
                delay: createDelay(internalTaskController.signal),
                pause: createPause(internalTaskController.signal),
                extra,
                signal: internalTaskController.signal,
                fork: createFork(internalTaskController.signal, autoJoinPromises),
                unsubscribe: entry.unsubscribe,
                subscribe: ()=>{
                    listenerMap.set(entry.id, entry);
                },
                cancelActiveListeners: ()=>{
                    entry.pending.forEach((controller, _, set)=>{
                        if (controller !== internalTaskController) {
                            abortControllerWithReason(controller, listenerCancelled);
                            set.delete(controller);
                        }
                    });
                },
                cancel: ()=>{
                    abortControllerWithReason(internalTaskController, listenerCancelled);
                    entry.pending.delete(internalTaskController);
                },
                throwIfCancelled: ()=>{
                    validateActive(internalTaskController.signal);
                }
            })));
        } catch (listenerError) {
            if (!(listenerError instanceof TaskAbortError)) safelyNotifyError(onError, listenerError, {
                raisedBy: "effect"
            });
        } finally{
            await Promise.all(autoJoinPromises);
            abortControllerWithReason(internalTaskController, listenerCompleted);
            entry.pending.delete(internalTaskController);
        }
    };
    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
    const middleware = (api)=>(next)=>(action)=>{
                if (!(0, _redux.isAction)(action)) return next(action);
                if (addListener.match(action)) return startListening(action.payload);
                if (clearAllListeners.match(action)) {
                    clearListenerMiddleware();
                    return;
                }
                if (removeListener.match(action)) return stopListening(action.payload);
                let originalState = api.getState();
                const getOriginalState = ()=>{
                    if (originalState === INTERNAL_NIL_TOKEN) throw new Error(`${alm}: getOriginalState can only be called synchronously`);
                    return originalState;
                };
                let result;
                try {
                    result = next(action);
                    if (listenerMap.size > 0) {
                        const currentState = api.getState();
                        const listenerEntries = Array.from(listenerMap.values());
                        for (const entry of listenerEntries){
                            let runListener = false;
                            try {
                                runListener = entry.predicate(action, currentState, originalState);
                            } catch (predicateError) {
                                runListener = false;
                                safelyNotifyError(onError, predicateError, {
                                    raisedBy: "predicate"
                                });
                            }
                            if (!runListener) continue;
                            notifyListener(entry, action, api, getOriginalState);
                        }
                    }
                } finally{
                    originalState = INTERNAL_NIL_TOKEN;
                }
                return result;
            };
    return {
        middleware,
        startListening,
        stopListening,
        clearListeners: clearListenerMiddleware
    };
};
var createMiddlewareEntry = (middleware)=>({
        id: nanoid(),
        middleware,
        applied: /* @__PURE__ */ new Map()
    });
var matchInstance = (instanceId)=>(action)=>{
        var _a;
        return ((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.instanceId) === instanceId;
    };
var createDynamicMiddleware = ()=>{
    const instanceId = nanoid();
    const middlewareMap = /* @__PURE__ */ new Map();
    const withMiddleware = Object.assign(createAction("dynamicMiddleware/add", (...middlewares)=>({
            payload: middlewares,
            meta: {
                instanceId
            }
        })), {
        withTypes: ()=>withMiddleware
    });
    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {
        middlewares.forEach((middleware2)=>{
            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);
            if (!entry) entry = createMiddlewareEntry(middleware2);
            middlewareMap.set(entry.id, entry);
        });
    }, {
        withTypes: ()=>addMiddleware
    });
    const getFinalMiddleware = (api)=>{
        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {
                insert: ()=>entry.middleware(api)
            }));
        return (0, _redux.compose)(...appliedMiddleware);
    };
    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));
    const middleware = (api)=>(next)=>(action)=>{
                if (isWithMiddleware(action)) {
                    addMiddleware(...action.payload);
                    return api.dispatch;
                }
                return getFinalMiddleware(api)(next)(action);
            };
    return {
        middleware,
        addMiddleware,
        withMiddleware,
        instanceId
    };
};
var isSliceLike = (maybeSliceLike)=>"reducerPath" in maybeSliceLike && typeof maybeSliceLike.reducerPath === "string";
var getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [
            [
                sliceOrMap.reducerPath,
                sliceOrMap.reducer
            ]
        ] : Object.entries(sliceOrMap));
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");
var isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];
var stateProxyMap = /* @__PURE__ */ new WeakMap();
var createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {
        insert: ()=>new Proxy(state, {
                get: (target, prop, receiver)=>{
                    if (prop === ORIGINAL_STATE) return target;
                    const result = Reflect.get(target, prop, receiver);
                    if (typeof result === "undefined") {
                        const reducer = reducerMap[prop.toString()];
                        if (reducer) {
                            const reducerResult = reducer(void 0, {
                                type: nanoid()
                            });
                            if (typeof reducerResult === "undefined") throw new Error(`The slice reducer for key "${prop.toString()}" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
                            return reducerResult;
                        }
                    }
                    return result;
                }
            })
    });
var original = (state)=>{
    if (!isStateProxy(state)) throw new Error("original must be used on state Proxy");
    return state[ORIGINAL_STATE];
};
var noopReducer = (state = {})=>state;
function combineSlices(...slices) {
    const reducerMap = Object.fromEntries(getReducers(slices));
    const getReducer = ()=>Object.keys(reducerMap).length ? (0, _redux.combineReducers)(reducerMap) : noopReducer;
    let reducer = getReducer();
    function combinedReducer(state, action) {
        return reducer(state, action);
    }
    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;
    const inject = (slice, config = {})=>{
        const { reducerPath, reducer: reducerToInject } = slice;
        const currentReducer = reducerMap[reducerPath];
        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {
            if (typeof process !== "undefined" && true) console.error(`called \`inject\` to override already-existing reducer ${reducerPath} without specifying \`overrideExisting: true\``);
            return combinedReducer;
        }
        reducerMap[reducerPath] = reducerToInject;
        reducer = getReducer();
        return combinedReducer;
    };
    const selector = Object.assign(function makeSelector(selectorFn, selectState) {
        return function selector2(state, ...args) {
            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);
        };
    }, {
        original
    });
    return Object.assign(combinedReducer, {
        inject,
        selector
    });
}
// src/formatProdErrorMessage.ts
function formatProdErrorMessage(code) {
    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}

},{"5843e4dc16d6aaa3":"hY920","redux":"ghKXw","immer":"kHawi","reselect":"idxJP","redux-thunk":"3sGpV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"hY920":[function(require,module,exports) {
var q = Object.create;
var p = Object.defineProperty;
var A = Object.getOwnPropertyDescriptor;
var I = Object.getOwnPropertyNames;
var Q = Object.getPrototypeOf, S = Object.prototype.hasOwnProperty;
var N = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports), O = (e, t)=>{
    for(var n in t)p(e, n, {
        get: t[n],
        enumerable: !0
    });
}, m = (e, t, n, w)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let f of I(t))!S.call(e, f) && f !== n && p(e, f, {
        get: ()=>t[f],
        enumerable: !(w = A(t, f)) || w.enumerable
    });
    return e;
}, h = (e, t, n)=>(m(e, t, "default"), n && m(n, t, "default")), y = (e, t, n)=>(n = e != null ? q(Q(e)) : {}, m(t || !e || !e.__esModule ? p(n, "default", {
        value: e,
        enumerable: !0
    }) : n, e)), U = (e)=>m(p({}, "__esModule", {
        value: !0
    }), e);
var v = N((F, E)=>{
    var r = E.exports = {}, i, u;
    function T() {
        throw new Error("setTimeout has not been defined");
    }
    function g() {
        throw new Error("clearTimeout has not been defined");
    }
    (function() {
        try {
            typeof setTimeout == "function" ? i = setTimeout : i = T;
        } catch (e) {
            i = T;
        }
        try {
            typeof clearTimeout == "function" ? u = clearTimeout : u = g;
        } catch (e) {
            u = g;
        }
    })();
    function b(e) {
        if (i === setTimeout) return setTimeout(e, 0);
        if ((i === T || !i) && setTimeout) return i = setTimeout, setTimeout(e, 0);
        try {
            return i(e, 0);
        } catch (t) {
            try {
                return i.call(null, e, 0);
            } catch (n) {
                return i.call(this, e, 0);
            }
        }
    }
    function j(e) {
        if (u === clearTimeout) return clearTimeout(e);
        if ((u === g || !u) && clearTimeout) return u = clearTimeout, clearTimeout(e);
        try {
            return u(e);
        } catch (t) {
            try {
                return u.call(null, e);
            } catch (n) {
                return u.call(this, e);
            }
        }
    }
    var o = [], s = !1, a, d = -1;
    function z() {
        !s || !a || (s = !1, a.length ? o = a.concat(o) : d = -1, o.length && x());
    }
    function x() {
        if (!s) {
            var e = b(z);
            s = !0;
            for(var t = o.length; t;){
                for(a = o, o = []; ++d < t;)a && a[d].run();
                d = -1, t = o.length;
            }
            a = null, s = !1, j(e);
        }
    }
    r.nextTick = function(e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];
        o.push(new L(e, t)), o.length === 1 && !s && b(x);
    };
    function L(e, t) {
        this.fun = e, this.array = t;
    }
    L.prototype.run = function() {
        this.fun.apply(null, this.array);
    };
    r.title = "browser";
    r.browser = !0;
    r.env = {};
    r.argv = [];
    r.version = "";
    r.versions = {};
    function c() {}
    r.on = c;
    r.addListener = c;
    r.once = c;
    r.off = c;
    r.removeListener = c;
    r.removeAllListeners = c;
    r.emit = c;
    r.prependListener = c;
    r.prependOnceListener = c;
    r.listeners = function(e) {
        return [];
    };
    r.binding = function(e) {
        throw new Error("process.binding is not supported");
    };
    r.cwd = function() {
        return "/";
    };
    r.chdir = function(e) {
        throw new Error("process.chdir is not supported");
    };
    r.umask = function() {
        return 0;
    };
});
var l = {};
O(l, {
    default: ()=>B
});
module.exports = U(l);
var C = y(v());
h(l, y(v()), module.exports);
var B = C.default;

},{}],"ghKXw":[function(require,module,exports) {
// src/utils/formatProdErrorMessage.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__DO_NOT_USE__ActionTypes", ()=>actionTypes_default);
parcelHelpers.export(exports, "applyMiddleware", ()=>applyMiddleware);
parcelHelpers.export(exports, "bindActionCreators", ()=>bindActionCreators);
parcelHelpers.export(exports, "combineReducers", ()=>combineReducers);
parcelHelpers.export(exports, "compose", ()=>compose);
parcelHelpers.export(exports, "createStore", ()=>createStore);
parcelHelpers.export(exports, "isAction", ()=>isAction);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "legacy_createStore", ()=>legacy_createStore);
function formatProdErrorMessage(code) {
    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
// src/utils/symbol-observable.ts
var $$observable = /* @__PURE__ */ (()=>typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
// src/utils/actionTypes.ts
var randomString = ()=>Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
    INIT: `@@redux/INIT${randomString()}`,
    REPLACE: `@@redux/REPLACE${randomString()}`,
    PROBE_UNKNOWN_ACTION: ()=>`@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
// src/utils/isPlainObject.ts
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    let proto = obj;
    while(Object.getPrototypeOf(proto) !== null)proto = Object.getPrototypeOf(proto);
    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
// src/utils/kindOf.ts
function miniKindOf(val) {
    if (val === void 0) return "undefined";
    if (val === null) return "null";
    const type = typeof val;
    switch(type){
        case "boolean":
        case "string":
        case "number":
        case "symbol":
        case "function":
            return type;
    }
    if (Array.isArray(val)) return "array";
    if (isDate(val)) return "date";
    if (isError(val)) return "error";
    const constructorName = ctorName(val);
    switch(constructorName){
        case "Symbol":
        case "Promise":
        case "WeakMap":
        case "WeakSet":
        case "Map":
        case "Set":
            return constructorName;
    }
    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
    let typeOfVal = typeof val;
    typeOfVal = miniKindOf(val);
    return typeOfVal;
}
// src/createStore.ts
function createStore(reducer, preloadedState, enhancer) {
    if (typeof reducer !== "function") throw new Error(`Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") throw new Error(`Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
        return enhancer(createStore)(reducer, preloadedState);
    }
    let currentReducer = reducer;
    let currentState = preloadedState;
    let currentListeners = /* @__PURE__ */ new Map();
    let nextListeners = currentListeners;
    let listenerIdCounter = 0;
    let isDispatching = false;
    function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
            nextListeners = /* @__PURE__ */ new Map();
            currentListeners.forEach((listener, key)=>{
                nextListeners.set(key, listener);
            });
        }
    }
    function getState() {
        if (isDispatching) throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
        return currentState;
    }
    function subscribe(listener) {
        if (typeof listener !== "function") throw new Error(`Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
        if (isDispatching) throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
        let isSubscribed = true;
        ensureCanMutateNextListeners();
        const listenerId = listenerIdCounter++;
        nextListeners.set(listenerId, listener);
        return function unsubscribe() {
            if (!isSubscribed) return;
            if (isDispatching) throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
            isSubscribed = false;
            ensureCanMutateNextListeners();
            nextListeners.delete(listenerId);
            currentListeners = null;
        };
    }
    function dispatch(action) {
        if (!isPlainObject(action)) throw new Error(`Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
        if (typeof action.type === "undefined") throw new Error('Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
        if (typeof action.type !== "string") throw new Error(`Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
        if (isDispatching) throw new Error("Reducers may not dispatch actions.");
        try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
        } finally{
            isDispatching = false;
        }
        const listeners = currentListeners = nextListeners;
        listeners.forEach((listener)=>{
            listener();
        });
        return action;
    }
    function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") throw new Error(`Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
        currentReducer = nextReducer;
        dispatch({
            type: actionTypes_default.REPLACE
        });
    }
    function observable() {
        const outerSubscribe = subscribe;
        return {
            /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */ subscribe (observer) {
                if (typeof observer !== "object" || observer === null) throw new Error(`Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
                function observeState() {
                    const observerAsObserver = observer;
                    if (observerAsObserver.next) observerAsObserver.next(getState());
                }
                observeState();
                const unsubscribe = outerSubscribe(observeState);
                return {
                    unsubscribe
                };
            },
            [symbol_observable_default] () {
                return this;
            }
        };
    }
    dispatch({
        type: actionTypes_default.INIT
    });
    const store = {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [symbol_observable_default]: observable
    };
    return store;
}
function legacy_createStore(reducer, preloadedState, enhancer) {
    return createStore(reducer, preloadedState, enhancer);
}
// src/utils/warning.ts
function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") console.error(message);
    try {
        throw new Error(message);
    } catch (e) {}
}
// src/combineReducers.ts
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    const reducerKeys = Object.keys(reducers);
    const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
    if (reducerKeys.length === 0) return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
    if (!isPlainObject(inputState)) return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
    const unexpectedKeys = Object.keys(inputState).filter((key)=>!reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
    unexpectedKeys.forEach((key)=>{
        unexpectedKeyCache[key] = true;
    });
    if (action && action.type === actionTypes_default.REPLACE) return;
    if (unexpectedKeys.length > 0) return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
}
function assertReducerShape(reducers) {
    Object.keys(reducers).forEach((key)=>{
        const reducer = reducers[key];
        const initialState = reducer(void 0, {
            type: actionTypes_default.INIT
        });
        if (typeof initialState === "undefined") throw new Error(`The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
        if (typeof reducer(void 0, {
            type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) === "undefined") throw new Error(`The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    });
}
function combineReducers(reducers) {
    const reducerKeys = Object.keys(reducers);
    const finalReducers = {};
    for(let i = 0; i < reducerKeys.length; i++){
        const key = reducerKeys[i];
        if (typeof reducers[key] === "undefined") warning(`No reducer provided for key "${key}"`);
        if (typeof reducers[key] === "function") finalReducers[key] = reducers[key];
    }
    const finalReducerKeys = Object.keys(finalReducers);
    let unexpectedKeyCache;
    unexpectedKeyCache = {};
    let shapeAssertionError;
    try {
        assertReducerShape(finalReducers);
    } catch (e) {
        shapeAssertionError = e;
    }
    return function combination(state = {}, action) {
        if (shapeAssertionError) throw shapeAssertionError;
        {
            const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
            if (warningMessage) warning(warningMessage);
        }
        let hasChanged = false;
        const nextState = {};
        for(let i = 0; i < finalReducerKeys.length; i++){
            const key = finalReducerKeys[i];
            const reducer = finalReducers[key];
            const previousStateForKey = state[key];
            const nextStateForKey = reducer(previousStateForKey, action);
            if (typeof nextStateForKey === "undefined") {
                const actionType = action && action.type;
                throw new Error(`When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
            }
            nextState[key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
    };
}
// src/bindActionCreators.ts
function bindActionCreator(actionCreator, dispatch) {
    return function(...args) {
        return dispatch(actionCreator.apply(this, args));
    };
}
function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === "function") return bindActionCreator(actionCreators, dispatch);
    if (typeof actionCreators !== "object" || actionCreators === null) throw new Error(`bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
    const boundActionCreators = {};
    for(const key in actionCreators){
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
    return boundActionCreators;
}
// src/compose.ts
function compose(...funcs) {
    if (funcs.length === 0) return (arg)=>arg;
    if (funcs.length === 1) return funcs[0];
    return funcs.reduce((a, b)=>(...args)=>a(b(...args)));
}
// src/applyMiddleware.ts
function applyMiddleware(...middlewares) {
    return (createStore2)=>(reducer, preloadedState)=>{
            const store = createStore2(reducer, preloadedState);
            let dispatch = ()=>{
                throw new Error("Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
            };
            const middlewareAPI = {
                getState: store.getState,
                dispatch: (action, ...args)=>dispatch(action, ...args)
            };
            const chain = middlewares.map((middleware)=>middleware(middlewareAPI));
            dispatch = compose(...chain)(store.dispatch);
            return {
                ...store,
                dispatch
            };
        };
}
// src/utils/isAction.ts
function isAction(action) {
    return isPlainObject(action) && "type" in action && typeof action.type === "string";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"kHawi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Immer", ()=>Immer2);
parcelHelpers.export(exports, "applyPatches", ()=>applyPatches);
parcelHelpers.export(exports, "castDraft", ()=>castDraft);
parcelHelpers.export(exports, "castImmutable", ()=>castImmutable);
parcelHelpers.export(exports, "createDraft", ()=>createDraft);
parcelHelpers.export(exports, "current", ()=>current);
parcelHelpers.export(exports, "enableMapSet", ()=>enableMapSet);
parcelHelpers.export(exports, "enablePatches", ()=>enablePatches);
parcelHelpers.export(exports, "finishDraft", ()=>finishDraft);
parcelHelpers.export(exports, "freeze", ()=>freeze);
parcelHelpers.export(exports, "immerable", ()=>DRAFTABLE);
parcelHelpers.export(exports, "isDraft", ()=>isDraft);
parcelHelpers.export(exports, "isDraftable", ()=>isDraftable);
parcelHelpers.export(exports, "nothing", ()=>NOTHING);
parcelHelpers.export(exports, "original", ()=>original);
parcelHelpers.export(exports, "produce", ()=>produce);
parcelHelpers.export(exports, "produceWithPatches", ()=>produceWithPatches);
parcelHelpers.export(exports, "setAutoFreeze", ()=>setAutoFreeze);
parcelHelpers.export(exports, "setUseStrictShallowCopy", ()=>setUseStrictShallowCopy);
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
// src/utils/env.ts
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
// src/utils/errors.ts
var errors = [
    // All error codes, starting by 0:
    function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
    },
    function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return `'current' expects a draft, got: ${thing}`;
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return `'original' expects a draft, got: ${thing}`;
    }
];
function die(error, ...args) {
    {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error(`[Immer] ${msg}`);
    }
    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
}
// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
    var _a;
    if (!value) return false;
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
    if (!value || typeof value !== "object") return false;
    const proto = getPrototypeOf(value);
    if (proto === null) return true;
    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object) return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
    if (!isDraft(value)) die(15, value);
    return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
    if (getArchtype(obj) === 0 /* Object */ ) Reflect.ownKeys(obj).forEach((key)=>{
        iter(key, obj[key], obj);
    });
    else obj.forEach((entry, index)=>iter(index, entry, obj));
}
function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;
}
function has(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
    const t = getArchtype(thing);
    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);
    else if (t === 3 /* Set */ ) thing.add(value);
    else thing[propOrOldValue] = value;
}
function is(x, y) {
    if (x === y) return x !== 0 || 1 / x === 1 / y;
    else return x !== x && y !== y;
}
function isMap(target) {
    return target instanceof Map;
}
function isSet(target) {
    return target instanceof Set;
}
function latest(state) {
    return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
    if (isMap(base)) return new Map(base);
    if (isSet(base)) return new Set(base);
    if (Array.isArray(base)) return Array.prototype.slice.call(base);
    if (!strict && isPlainObject(base)) {
        if (!getPrototypeOf(base)) {
            const obj = /* @__PURE__ */ Object.create(null);
            return Object.assign(obj, base);
        }
        return __spreadValues({}, base);
    }
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const desc = descriptors[key];
        if (desc.writable === false) {
            desc.writable = true;
            desc.configurable = true;
        }
        if (desc.get || desc.set) descriptors[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
}
function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    Object.freeze(obj);
    if (deep) Object.entries(obj).forEach(([key, value])=>freeze(value, true));
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
function isFrozen(obj) {
    return Object.isFrozen(obj);
}
// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) die(0, pluginKey);
    return plugin;
}
function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
// src/core/scope.ts
var currentScope;
function getCurrentScope() {
    return currentScope;
}
function createScope(parent_, immer_) {
    return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
    };
}
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) currentScope = scope.parent_;
}
function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();
    else state.revoked_ = true;
}
// src/core/finalize.ts
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
            if (!scope.parent_) maybeFreeze(scope, result);
        }
        if (scope.patches_) getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    } else result = finalize(scope, baseDraft, []);
    revokeScope(scope);
    if (scope.patches_) scope.patchListener_(scope.patches_, scope.inversePatches_);
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
    if (isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    if (!state) {
        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path));
        return value;
    }
    if (state.scope_ !== rootScope) return value;
    if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
    }
    if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3 /* Set */ ) {
            resultEach = new Set(result);
            result.clear();
            isSet2 = true;
        }
        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
    return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (childValue === targetObject) die(5);
    if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) rootScope.canAutoFreeze_ = false;
        else return;
    } else if (targetIsSet) targetObject.add(childValue);
    if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) return;
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);
    }
}
function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) freeze(value, deep);
}
// src/core/proxy.ts
function createProxyProxy(base, parent) {
    const isArray = Array.isArray(base);
    const state = {
        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
}
var objectTraps = {
    get (state, prop) {
        if (prop === DRAFT_STATE) return state;
        const source = latest(state);
        if (!has(source, prop)) return readPropFromProto(state, source, prop);
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) return value;
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            return state.copy_[prop] = createProxy(value, state);
        }
        return value;
    },
    has (state, prop) {
        return prop in latest(state);
    },
    ownKeys (state) {
        return Reflect.ownKeys(latest(state));
    },
    set (state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc == null ? void 0 : desc.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            const current2 = peek(latest(state), prop);
            const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
    },
    deleteProperty (state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_[prop] = false;
            prepareCopy(state);
            markChanged(state);
        } else delete state.assigned_[prop];
        if (state.copy_) delete state.copy_[prop];
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor (state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        return {
            writable: true,
            configurable: state.type_ !== 1 /* Array */  || prop !== "length",
            enumerable: desc.enumerable,
            value: owner[prop]
        };
    },
    defineProperty () {
        die(11);
    },
    getPrototypeOf (state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf () {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, (key, fn)=>{
    arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    var _a;
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    let proto = getPrototypeOf(source);
    while(proto){
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) markChanged(state.parent_);
    }
}
function prepareCopy(state) {
    if (!state.copy_) state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
}
// src/core/immerClass.ts
var Immer2 = class {
    constructor(config){
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */ this.produce = (base, recipe, patchListener)=>{
            if (typeof base === "function" && typeof recipe !== "function") {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce(base2 = defaultBase, ...args) {
                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));
                };
            }
            if (typeof recipe !== "function") die(6);
            if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
            let result;
            if (isDraftable(base)) {
                const scope = enterScope(this);
                const proxy = createProxy(base, void 0);
                let hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || typeof base !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    const p = [];
                    const ip = [];
                    getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = (base, recipe)=>{
            if (typeof base === "function") return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));
            let patches, inversePatches;
            const result = this.produce(base, recipe, (p, ip)=>{
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
        if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
    }
    createDraft(base) {
        if (!isDraftable(base)) die(8);
        if (isDraft(base)) base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
    }
    finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_) die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
    }
    /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ setAutoFreeze(value) {
        this.autoFreeze_ = value;
    }
    /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
        let i;
        for(i = patches.length - 1; i >= 0; i--){
            const patch = patches[i];
            if (patch.path.length === 0 && patch.op === "replace") {
                base = patch.value;
                break;
            }
        }
        if (i > -1) patches = patches.slice(i + 1);
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) return applyPatchesImpl(base, patches);
        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));
    }
};
function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
}
// src/core/current.ts
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    let copy;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else copy = shallowCopy(value, true);
    each(copy, (key, childValue)=>{
        set(copy, key, currentImpl(childValue));
    });
    if (state) state.finalized_ = false;
    return copy;
}
// src/plugins/patches.ts
function enablePatches() {
    const errorOffset = 16;
    errors.push('Sets cannot have "replace" patches.', function(op) {
        return "Unsupported patch operation: " + op;
    }, function(path) {
        return "Cannot apply patch, path doesn't resolve: " + path;
    }, "Patching reserved attributes like __proto__, prototype and constructor is not allowed");
    const REPLACE = "replace";
    const ADD = "add";
    const REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
        switch(state.type_){
            case 0 /* Object */ :
            case 2 /* Map */ :
                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
            case 1 /* Array */ :
                return generateArrayPatches(state, basePath, patches, inversePatches);
            case 3 /* Set */ :
                return generateSetPatches(state, basePath, patches, inversePatches);
        }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
        let { base_, assigned_ } = state;
        let copy_ = state.copy_;
        if (copy_.length < base_.length) {
            [base_, copy_] = [
                copy_,
                base_
            ];
            [patches, inversePatches] = [
                inversePatches,
                patches
            ];
        }
        for(let i = 0; i < base_.length; i++)if (assigned_[i] && copy_[i] !== base_[i]) {
            const path = basePath.concat([
                i
            ]);
            patches.push({
                op: REPLACE,
                path,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i])
            });
            inversePatches.push({
                op: REPLACE,
                path,
                value: clonePatchValueIfNeeded(base_[i])
            });
        }
        for(let i = base_.length; i < copy_.length; i++){
            const path = basePath.concat([
                i
            ]);
            patches.push({
                op: ADD,
                path,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i])
            });
        }
        for(let i = copy_.length - 1; base_.length <= i; --i){
            const path = basePath.concat([
                i
            ]);
            inversePatches.push({
                op: REMOVE,
                path
            });
        }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        const { base_, copy_ } = state;
        each(state.assigned_, (key, assignedValue)=>{
            const origValue = get(base_, key);
            const value = get(copy_, key);
            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
            if (origValue === value && op === REPLACE) return;
            const path = basePath.concat(key);
            patches.push(op === REMOVE ? {
                op,
                path
            } : {
                op,
                path,
                value
            });
            inversePatches.push(op === ADD ? {
                op: REMOVE,
                path
            } : op === REMOVE ? {
                op: ADD,
                path,
                value: clonePatchValueIfNeeded(origValue)
            } : {
                op: REPLACE,
                path,
                value: clonePatchValueIfNeeded(origValue)
            });
        });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
        let { base_, copy_ } = state;
        let i = 0;
        base_.forEach((value)=>{
            if (!copy_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REMOVE,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: ADD,
                    path,
                    value
                });
            }
            i++;
        });
        i = 0;
        copy_.forEach((value)=>{
            if (!base_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: ADD,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: REMOVE,
                    path,
                    value
                });
            }
            i++;
        });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
            op: REPLACE,
            path: [],
            value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
            op: REPLACE,
            path: [],
            value: baseValue
        });
    }
    function applyPatches_(draft, patches) {
        patches.forEach((patch)=>{
            const { path, op } = patch;
            let base = draft;
            for(let i = 0; i < path.length - 1; i++){
                const parentType = getArchtype(base);
                let p = path[i];
                if (typeof p !== "string" && typeof p !== "number") p = "" + p;
                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
                if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
                base = get(base, p);
                if (typeof base !== "object") die(errorOffset + 2, path.join("/"));
            }
            const type = getArchtype(base);
            const value = deepClonePatchValue(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case REPLACE:
                    switch(type){
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            die(errorOffset);
                        default:
                            return base[key] = value;
                    }
                case ADD:
                    switch(type){
                        case 1 /* Array */ :
                            return key === "-" ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case REMOVE:
                    switch(type){
                        case 1 /* Array */ :
                            return base.splice(key, 1);
                        case 2 /* Map */ :
                            return base.delete(key);
                        case 3 /* Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    die(errorOffset + 1, op);
            }
        });
        return draft;
    }
    function deepClonePatchValue(obj) {
        if (!isDraftable(obj)) return obj;
        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(([k, v])=>[
                k,
                deepClonePatchValue(v)
            ]));
        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
        const cloned = Object.create(getPrototypeOf(obj));
        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) return deepClonePatchValue(obj);
        else return obj;
    }
    loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
    });
}
// src/plugins/mapset.ts
function enableMapSet() {
    class DraftMap extends Map {
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 2 /* Map */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                assigned_: void 0,
                base_: target,
                draft_: this,
                isManual_: false,
                revoked_: false
            };
        }
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(key) {
            return latest(this[DRAFT_STATE]).has(key);
        }
        set(key, value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!latest(state).has(key) || latest(state).get(key) !== value) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_.set(key, true);
                state.copy_.set(key, value);
                state.assigned_.set(key, true);
            }
            return this;
        }
        delete(key) {
            if (!this.has(key)) return false;
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareMapCopy(state);
            markChanged(state);
            if (state.base_.has(key)) state.assigned_.set(key, false);
            else state.assigned_.delete(key);
            state.copy_.delete(key);
            return true;
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_ = /* @__PURE__ */ new Map();
                each(state.base_, (key)=>{
                    state.assigned_.set(key, false);
                });
                state.copy_.clear();
            }
        }
        forEach(cb, thisArg) {
            const state = this[DRAFT_STATE];
            latest(state).forEach((_value, key, _map)=>{
                cb.call(thisArg, this.get(key), key, this);
            });
        }
        get(key) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            const value = latest(state).get(key);
            if (state.finalized_ || !isDraftable(value)) return value;
            if (value !== state.base_.get(key)) return value;
            const draft = createProxy(value, state);
            prepareMapCopy(state);
            state.copy_.set(key, draft);
            return draft;
        }
        keys() {
            return latest(this[DRAFT_STATE]).keys();
        }
        values() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.values(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value
                    };
                }
            };
        }
        entries() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.entries(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value: [
                            r.value,
                            value
                        ]
                    };
                }
            };
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.entries();
        }
    }
    function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
    }
    function prepareMapCopy(state) {
        if (!state.copy_) {
            state.assigned_ = /* @__PURE__ */ new Map();
            state.copy_ = new Map(state.base_);
        }
    }
    class DraftSet extends Set {
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 3 /* Set */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                base_: target,
                draft_: this,
                drafts_: /* @__PURE__ */ new Map(),
                revoked_: false,
                isManual_: false
            };
        }
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!state.copy_) return state.base_.has(value);
            if (state.copy_.has(value)) return true;
            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
            return false;
        }
        add(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!this.has(value)) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.add(value);
            }
            return this;
        }
        delete(value) {
            if (!this.has(value)) return false;
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            markChanged(state);
            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.clear();
            }
        }
        values() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.values();
        }
        entries() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.entries();
        }
        keys() {
            return this.values();
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.values();
        }
        forEach(cb, thisArg) {
            const iterator = this.values();
            let result = iterator.next();
            while(!result.done){
                cb.call(thisArg, result.value, result.value, this);
                result = iterator.next();
            }
        }
    }
    function proxySet_(target, parent) {
        return new DraftSet(target, parent);
    }
    function prepareSetCopy(state) {
        if (!state.copy_) {
            state.copy_ = /* @__PURE__ */ new Set();
            state.base_.forEach((value)=>{
                if (isDraftable(value)) {
                    const draft = createProxy(value, state);
                    state.drafts_.set(value, draft);
                    state.copy_.add(draft);
                } else state.copy_.add(value);
            });
        }
    }
    function assertUnrevoked(state) {
        if (state.revoked_) die(3, JSON.stringify(latest(state)));
    }
    loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
    });
}
// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(immer);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
    return value;
}
function castImmutable(value) {
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"idxJP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSelector", ()=>createSelector);
parcelHelpers.export(exports, "createSelectorCreator", ()=>createSelectorCreator);
parcelHelpers.export(exports, "createStructuredSelector", ()=>createStructuredSelector);
parcelHelpers.export(exports, "lruMemoize", ()=>lruMemoize);
parcelHelpers.export(exports, "referenceEqualityCheck", ()=>referenceEqualityCheck);
parcelHelpers.export(exports, "setGlobalDevModeChecks", ()=>setGlobalDevModeChecks);
parcelHelpers.export(exports, "unstable_autotrackMemoize", ()=>autotrackMemoize);
parcelHelpers.export(exports, "weakMapMemoize", ()=>weakMapMemoize);
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
// src/devModeChecks/identityFunctionCheck.ts
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult)=>{
    if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
        let isInputSameAsOutput = false;
        try {
            const emptyObject = {};
            if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;
        } catch (e) {}
        if (isInputSameAsOutput) {
            let stack = void 0;
            try {
                throw new Error();
            } catch (e) {
                ({ stack } = e);
            }
            console.warn("The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.", {
                stack
            });
        }
    }
};
// src/devModeChecks/inputStabilityCheck.ts
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs)=>{
    const { memoize, memoizeOptions } = options;
    const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
    const createAnEmptyObject = memoize(()=>({}), ...memoizeOptions);
    const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
    if (!areInputSelectorResultsEqual) {
        let stack = void 0;
        try {
            throw new Error();
        } catch (e) {
            ({ stack } = e);
        }
        console.warn("An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`", {
            arguments: inputSelectorArgs,
            firstInputs: inputSelectorResults,
            secondInputs: inputSelectorResultsCopy,
            stack
        });
    }
};
// src/devModeChecks/setGlobalDevModeChecks.ts
var globalDevModeChecks = {
    inputStabilityCheck: "once",
    identityFunctionCheck: "once"
};
var setGlobalDevModeChecks = (devModeChecks)=>{
    Object.assign(globalDevModeChecks, devModeChecks);
};
// src/utils.ts
var NOT_FOUND = "NOT_FOUND";
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
    if (typeof func !== "function") throw new TypeError(errorMessage);
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
    if (typeof object !== "object") throw new TypeError(errorMessage);
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
    if (!array.every((item)=>typeof item === "function")) {
        const itemTypes = array.map((item)=>typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item).join(", ");
        throw new TypeError(`${errorMessage}[${itemTypes}]`);
    }
}
var ensureIsArray = (item)=>{
    return Array.isArray(item) ? item : [
        item
    ];
};
function getDependencies(createSelectorArgs) {
    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
    assertIsArrayOfFunctions(dependencies, `createSelector expects all input-selectors to be functions, but received the following types: `);
    return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
    const inputSelectorResults = [];
    const { length } = dependencies;
    for(let i = 0; i < length; i++)inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
    return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks)=>{
    const { identityFunctionCheck, inputStabilityCheck } = __spreadValues(__spreadValues({}, globalDevModeChecks), devModeChecks);
    return {
        identityFunctionCheck: {
            shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
            run: runIdentityFunctionCheck
        },
        inputStabilityCheck: {
            shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
            run: runInputStabilityCheck
        }
    };
};
// src/autotrackMemoize/autotracking.ts
var $REVISION = 0;
var CURRENT_TRACKER = null;
var Cell = class {
    constructor(initialValue, isEqual = tripleEq){
        __publicField(this, "revision", $REVISION);
        __publicField(this, "_value");
        __publicField(this, "_lastValue");
        __publicField(this, "_isEqual", tripleEq);
        this._value = this._lastValue = initialValue;
        this._isEqual = isEqual;
    }
    // Whenever a storage value is read, it'll add itself to the current tracker if
    // one exists, entangling its state with that cache.
    get value() {
        CURRENT_TRACKER == null || CURRENT_TRACKER.add(this);
        return this._value;
    }
    // Whenever a storage value is updated, we bump the global revision clock,
    // assign the revision for this storage to the new value, _and_ we schedule a
    // rerender. This is important, and it's what makes autotracking  _pull_
    // based. We don't actively tell the caches which depend on the storage that
    // anything has happened. Instead, we recompute the caches when needed.
    set value(newValue) {
        if (this.value === newValue) return;
        this._value = newValue;
        this.revision = ++$REVISION;
    }
};
function tripleEq(a, b) {
    return a === b;
}
var TrackingCache = class {
    constructor(fn){
        __publicField(this, "_cachedValue");
        __publicField(this, "_cachedRevision", -1);
        __publicField(this, "_deps", []);
        __publicField(this, "hits", 0);
        __publicField(this, "fn");
        this.fn = fn;
    }
    clear() {
        this._cachedValue = void 0;
        this._cachedRevision = -1;
        this._deps = [];
        this.hits = 0;
    }
    get value() {
        if (this.revision > this._cachedRevision) {
            const { fn } = this;
            const currentTracker = /* @__PURE__ */ new Set();
            const prevTracker = CURRENT_TRACKER;
            CURRENT_TRACKER = currentTracker;
            this._cachedValue = fn();
            CURRENT_TRACKER = prevTracker;
            this.hits++;
            this._deps = Array.from(currentTracker);
            this._cachedRevision = this.revision;
        }
        CURRENT_TRACKER == null || CURRENT_TRACKER.add(this);
        return this._cachedValue;
    }
    get revision() {
        return Math.max(...this._deps.map((d)=>d.revision), 0);
    }
};
function getValue(cell) {
    if (!(cell instanceof Cell)) console.warn("Not a valid cell! ", cell);
    return cell.value;
}
function setValue(storage, value) {
    if (!(storage instanceof Cell)) throw new TypeError("setValue must be passed a tracked store created with `createStorage`.");
    storage.value = storage._lastValue = value;
}
function createCell(initialValue, isEqual = tripleEq) {
    return new Cell(initialValue, isEqual);
}
function createCache(fn) {
    assertIsFunction(fn, "the first parameter to `createCache` must be a function");
    return new TrackingCache(fn);
}
// src/autotrackMemoize/tracking.ts
var neverEq = (a, b)=>false;
function createTag() {
    return createCell(null, neverEq);
}
function dirtyTag(tag, value) {
    setValue(tag, value);
}
var consumeCollection = (node)=>{
    let tag = node.collectionTag;
    if (tag === null) tag = node.collectionTag = createTag();
    getValue(tag);
};
var dirtyCollection = (node)=>{
    const tag = node.collectionTag;
    if (tag !== null) dirtyTag(tag, null);
};
// src/autotrackMemoize/proxy.ts
var REDUX_PROXY_LABEL = Symbol();
var nextId = 0;
var proto = Object.getPrototypeOf({});
var ObjectTreeNode = class {
    constructor(value){
        this.value = value;
        __publicField(this, "proxy", new Proxy(this, objectProxyHandler));
        __publicField(this, "tag", createTag());
        __publicField(this, "tags", {});
        __publicField(this, "children", {});
        __publicField(this, "collectionTag", null);
        __publicField(this, "id", nextId++);
        this.value = value;
        this.tag.value = value;
    }
};
var objectProxyHandler = {
    get (node, key) {
        function calculateResult() {
            const { value } = node;
            const childValue = Reflect.get(value, key);
            if (typeof key === "symbol") return childValue;
            if (key in proto) return childValue;
            if (typeof childValue === "object" && childValue !== null) {
                let childNode = node.children[key];
                if (childNode === void 0) childNode = node.children[key] = createNode(childValue);
                if (childNode.tag) getValue(childNode.tag);
                return childNode.proxy;
            } else {
                let tag = node.tags[key];
                if (tag === void 0) {
                    tag = node.tags[key] = createTag();
                    tag.value = childValue;
                }
                getValue(tag);
                return childValue;
            }
        }
        const res = calculateResult();
        return res;
    },
    ownKeys (node) {
        consumeCollection(node);
        return Reflect.ownKeys(node.value);
    },
    getOwnPropertyDescriptor (node, prop) {
        return Reflect.getOwnPropertyDescriptor(node.value, prop);
    },
    has (node, prop) {
        return Reflect.has(node.value, prop);
    }
};
var ArrayTreeNode = class {
    constructor(value){
        this.value = value;
        __publicField(this, "proxy", new Proxy([
            this
        ], arrayProxyHandler));
        __publicField(this, "tag", createTag());
        __publicField(this, "tags", {});
        __publicField(this, "children", {});
        __publicField(this, "collectionTag", null);
        __publicField(this, "id", nextId++);
        this.value = value;
        this.tag.value = value;
    }
};
var arrayProxyHandler = {
    get ([node], key) {
        if (key === "length") consumeCollection(node);
        return objectProxyHandler.get(node, key);
    },
    ownKeys ([node]) {
        return objectProxyHandler.ownKeys(node);
    },
    getOwnPropertyDescriptor ([node], prop) {
        return objectProxyHandler.getOwnPropertyDescriptor(node, prop);
    },
    has ([node], prop) {
        return objectProxyHandler.has(node, prop);
    }
};
function createNode(value) {
    if (Array.isArray(value)) return new ArrayTreeNode(value);
    return new ObjectTreeNode(value);
}
function updateNode(node, newValue) {
    const { value, tags, children } = node;
    node.value = newValue;
    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) dirtyCollection(node);
    else if (value !== newValue) {
        let oldKeysSize = 0;
        let newKeysSize = 0;
        let anyKeysAdded = false;
        for(const _key in value)oldKeysSize++;
        for(const key in newValue){
            newKeysSize++;
            if (!(key in value)) {
                anyKeysAdded = true;
                break;
            }
        }
        const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;
        if (isDifferent) dirtyCollection(node);
    }
    for(const key in tags){
        const childValue = value[key];
        const newChildValue = newValue[key];
        if (childValue !== newChildValue) {
            dirtyCollection(node);
            dirtyTag(tags[key], newChildValue);
        }
        if (typeof newChildValue === "object" && newChildValue !== null) delete tags[key];
    }
    for(const key in children){
        const childNode = children[key];
        const newChildValue = newValue[key];
        const childValue = childNode.value;
        if (childValue === newChildValue) continue;
        else if (typeof newChildValue === "object" && newChildValue !== null) updateNode(childNode, newChildValue);
        else {
            deleteNode(childNode);
            delete children[key];
        }
    }
}
function deleteNode(node) {
    if (node.tag) dirtyTag(node.tag, null);
    dirtyCollection(node);
    for(const key in node.tags)dirtyTag(node.tags[key], null);
    for(const key in node.children)deleteNode(node.children[key]);
}
// src/lruMemoize.ts
function createSingletonCache(equals) {
    let entry;
    return {
        get (key) {
            if (entry && equals(entry.key, key)) return entry.value;
            return NOT_FOUND;
        },
        put (key, value) {
            entry = {
                key,
                value
            };
        },
        getEntries () {
            return entry ? [
                entry
            ] : [];
        },
        clear () {
            entry = void 0;
        }
    };
}
function createLruCache(maxSize, equals) {
    let entries = [];
    function get(key) {
        const cacheIndex = entries.findIndex((entry)=>equals(key, entry.key));
        if (cacheIndex > -1) {
            const entry = entries[cacheIndex];
            if (cacheIndex > 0) {
                entries.splice(cacheIndex, 1);
                entries.unshift(entry);
            }
            return entry.value;
        }
        return NOT_FOUND;
    }
    function put(key, value) {
        if (get(key) === NOT_FOUND) {
            entries.unshift({
                key,
                value
            });
            if (entries.length > maxSize) entries.pop();
        }
    }
    function getEntries() {
        return entries;
    }
    function clear() {
        entries = [];
    }
    return {
        get,
        put,
        getEntries,
        clear
    };
}
var referenceEqualityCheck = (a, b)=>a === b;
function createCacheKeyComparator(equalityCheck) {
    return function areArgumentsShallowlyEqual(prev, next) {
        if (prev === null || next === null || prev.length !== next.length) return false;
        const { length } = prev;
        for(let i = 0; i < length; i++){
            if (!equalityCheck(prev[i], next[i])) return false;
        }
        return true;
    };
}
function lruMemoize(func, equalityCheckOrOptions) {
    const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
        equalityCheck: equalityCheckOrOptions
    };
    const { equalityCheck = referenceEqualityCheck, maxSize = 1, resultEqualityCheck } = providedOptions;
    const comparator = createCacheKeyComparator(equalityCheck);
    let resultsCount = 0;
    const cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
    function memoized() {
        let value = cache.get(arguments);
        if (value === NOT_FOUND) {
            value = func.apply(null, arguments);
            resultsCount++;
            if (resultEqualityCheck) {
                const entries = cache.getEntries();
                const matchingEntry = entries.find((entry)=>resultEqualityCheck(entry.value, value));
                if (matchingEntry) {
                    value = matchingEntry.value;
                    resultsCount !== 0 && resultsCount--;
                }
            }
            cache.put(arguments, value);
        }
        return value;
    }
    memoized.clearCache = ()=>{
        cache.clear();
        memoized.resetResultsCount();
    };
    memoized.resultsCount = ()=>resultsCount;
    memoized.resetResultsCount = ()=>{
        resultsCount = 0;
    };
    return memoized;
}
// src/autotrackMemoize/autotrackMemoize.ts
function autotrackMemoize(func) {
    const node = createNode([]);
    let lastArgs = null;
    const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);
    const cache = createCache(()=>{
        const res = func.apply(null, node.proxy);
        return res;
    });
    function memoized() {
        if (!shallowEqual(lastArgs, arguments)) {
            updateNode(node, arguments);
            lastArgs = arguments;
        }
        return cache.value;
    }
    memoized.clearCache = ()=>{
        return cache.clear();
    };
    return memoized;
}
// src/weakMapMemoize.ts
var StrongRef = class {
    constructor(value){
        this.value = value;
    }
    deref() {
        return this.value;
    }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
    return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
    };
}
function weakMapMemoize(func, options = {}) {
    let fnNode = createCacheNode();
    const { resultEqualityCheck } = options;
    let lastResult;
    let resultsCount = 0;
    function memoized() {
        var _a, _b;
        let cacheNode = fnNode;
        const { length } = arguments;
        for(let i = 0, l = length; i < l; i++){
            const arg = arguments[i];
            if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
                let objectCache = cacheNode.o;
                if (objectCache === null) cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
                const objectNode = objectCache.get(arg);
                if (objectNode === void 0) {
                    cacheNode = createCacheNode();
                    objectCache.set(arg, cacheNode);
                } else cacheNode = objectNode;
            } else {
                let primitiveCache = cacheNode.p;
                if (primitiveCache === null) cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
                const primitiveNode = primitiveCache.get(arg);
                if (primitiveNode === void 0) {
                    cacheNode = createCacheNode();
                    primitiveCache.set(arg, cacheNode);
                } else cacheNode = primitiveNode;
            }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) result = cacheNode.v;
        else {
            result = func.apply(null, arguments);
            resultsCount++;
        }
        terminatedNode.s = TERMINATED;
        if (resultEqualityCheck) {
            const lastResultValue = (_b = (_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) != null ? _b : lastResult;
            if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
                result = lastResultValue;
                resultsCount !== 0 && resultsCount--;
            }
            const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
            lastResult = needsWeakRef ? new Ref(result) : result;
        }
        terminatedNode.v = result;
        return result;
    }
    memoized.clearCache = ()=>{
        fnNode = createCacheNode();
        memoized.resetResultsCount();
    };
    memoized.resultsCount = ()=>resultsCount;
    memoized.resetResultsCount = ()=>{
        resultsCount = 0;
    };
    return memoized;
}
// src/createSelectorCreator.ts
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
    const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
        memoize: memoizeOrOptions,
        memoizeOptions: memoizeOptionsFromArgs
    } : memoizeOrOptions;
    const createSelector2 = (...createSelectorArgs)=>{
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
            directlyPassedOptions = resultFunc;
            resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(resultFunc, `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);
        const combinedOptions = __spreadValues(__spreadValues({}, createSelectorCreatorOptions), directlyPassedOptions);
        const { memoize, memoizeOptions = [], argsMemoize = weakMapMemoize, argsMemoizeOptions = [], devModeChecks = {} } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize(function recomputationWrapper() {
            recomputations++;
            return resultFunc.apply(null, arguments);
        }, ...finalMemoizeOptions);
        let firstRun = true;
        const selector = argsMemoize(function dependenciesChecker() {
            dependencyRecomputations++;
            const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
            lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
            {
                const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
                if (identityFunctionCheck.shouldRun) identityFunctionCheck.run(resultFunc, inputSelectorResults, lastResult);
                if (inputStabilityCheck.shouldRun) {
                    const inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);
                    inputStabilityCheck.run({
                        inputSelectorResults,
                        inputSelectorResultsCopy
                    }, {
                        memoize,
                        memoizeOptions: finalMemoizeOptions
                    }, arguments);
                }
                if (firstRun) firstRun = false;
            }
            return lastResult;
        }, ...finalArgsMemoizeOptions);
        return Object.assign(selector, {
            resultFunc,
            memoizedResultFunc,
            dependencies,
            dependencyRecomputations: ()=>dependencyRecomputations,
            resetDependencyRecomputations: ()=>{
                dependencyRecomputations = 0;
            },
            lastResult: ()=>lastResult,
            recomputations: ()=>recomputations,
            resetRecomputations: ()=>{
                recomputations = 0;
            },
            memoize,
            argsMemoize
        });
    };
    Object.assign(createSelector2, {
        withTypes: ()=>createSelector2
    });
    return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
// src/createStructuredSelector.ts
var createStructuredSelector = Object.assign((inputSelectorsObject, selectorCreator = createSelector)=>{
    assertIsObject(inputSelectorsObject, `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`);
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map((key)=>inputSelectorsObject[key]);
    const structuredSelector = selectorCreator(dependencies, (...inputSelectorResults)=>{
        return inputSelectorResults.reduce((composition, value, index)=>{
            composition[inputSelectorKeys[index]] = value;
            return composition;
        }, {});
    });
    return structuredSelector;
}, {
    withTypes: ()=>createStructuredSelector
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"3sGpV":[function(require,module,exports) {
// src/index.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "thunk", ()=>thunk);
parcelHelpers.export(exports, "withExtraArgument", ()=>withExtraArgument);
function createThunkMiddleware(extraArgument) {
    const middleware = ({ dispatch, getState })=>(next)=>(action)=>{
                if (typeof action === "function") return action(dispatch, getState, extraArgument);
                return next(action);
            };
    return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"jnLXV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Provider", ()=>Provider_default);
parcelHelpers.export(exports, "ReactReduxContext", ()=>ReactReduxContext);
parcelHelpers.export(exports, "batch", ()=>batch);
parcelHelpers.export(exports, "connect", ()=>connect_default);
parcelHelpers.export(exports, "createDispatchHook", ()=>createDispatchHook);
parcelHelpers.export(exports, "createSelectorHook", ()=>createSelectorHook);
parcelHelpers.export(exports, "createStoreHook", ()=>createStoreHook);
parcelHelpers.export(exports, "shallowEqual", ()=>shallowEqual);
parcelHelpers.export(exports, "useDispatch", ()=>useDispatch);
parcelHelpers.export(exports, "useSelector", ()=>useSelector);
parcelHelpers.export(exports, "useStore", ()=>useStore);
// src/index.ts
var _react = require("react");
var _withSelectorJs = require("use-sync-external-store/with-selector.js");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(source))if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
var React = // prettier-ignore
// @ts-ignore
"default" in _react ? _react["default"] : _react;
// src/components/Context.ts
var ContextKey = Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};
function getContext() {
    var _a;
    if (!React.createContext) return {};
    const contextMap = (_a = gT[ContextKey]) != null ? _a : gT[ContextKey] = /* @__PURE__ */ new Map();
    let realContext = contextMap.get(React.createContext);
    if (!realContext) {
        realContext = React.createContext(null);
        realContext.displayName = "ReactRedux";
        contextMap.set(React.createContext, realContext);
    }
    return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
// src/utils/useSyncExternalStore.ts
var notInitialized = ()=>{
    throw new Error("uSES not initialized!");
};
// src/hooks/useReduxContext.ts
function createReduxContextHook(context = ReactReduxContext) {
    return function useReduxContext2() {
        const contextValue = React.useContext(context);
        if (!contextValue) throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
        return contextValue;
    };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
// src/hooks/useSelector.ts
var useSyncExternalStoreWithSelector = notInitialized;
var initializeUseSelector = (fn)=>{
    useSyncExternalStoreWithSelector = fn;
};
var refEquality = (a, b)=>a === b;
function createSelectorHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
    const useSelector2 = (selector, equalityFnOrOptions = {})=>{
        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {
            equalityFn: equalityFnOrOptions
        } : equalityFnOrOptions;
        if (!selector) throw new Error(`You must pass a selector to useSelector`);
        if (typeof selector !== "function") throw new Error(`You must pass a function as a selector to useSelector`);
        if (typeof equalityFn !== "function") throw new Error(`You must pass a function as an equality function to useSelector`);
        const { store, subscription, getServerState, stabilityCheck, identityFunctionCheck } = useReduxContext2();
        const firstRun = React.useRef(true);
        const wrappedSelector = React.useCallback({
            [selector.name] (state) {
                const selected = selector(state);
                {
                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = __spreadValues({
                        stabilityCheck,
                        identityFunctionCheck
                    }, devModeChecks);
                    if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
                        const toCompare = selector(state);
                        if (!equalityFn(selected, toCompare)) {
                            let stack = void 0;
                            try {
                                throw new Error();
                            } catch (e) {
                                ({ stack } = e);
                            }
                            console.warn("Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization", {
                                state,
                                selected,
                                selected2: toCompare,
                                stack
                            });
                        }
                    }
                    if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
                        if (selected === state) {
                            let stack = void 0;
                            try {
                                throw new Error();
                            } catch (e) {
                                ({ stack } = e);
                            }
                            console.warn("Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.", {
                                stack
                            });
                        }
                    }
                    if (firstRun.current) firstRun.current = false;
                }
                return selected;
            }
        }[selector.name], [
            selector,
            stabilityCheck,
            devModeChecks.stabilityCheck
        ]);
        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
        React.useDebugValue(selectedState);
        return selectedState;
    };
    Object.assign(useSelector2, {
        withTypes: ()=>useSelector2
    });
    return useSelector2;
}
var useSelector = /* @__PURE__ */ createSelectorHook();
// src/utils/react-is.ts
var REACT_ELEMENT_TYPE = Symbol.for("react.element");
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type) {
    if (typeof type === "string" || typeof type === "function") return true;
    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) return true;
    if (typeof type === "object" && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) return true;
    }
    return false;
}
function typeOf(object) {
    if (typeof object === "object" && object !== null) {
        const $$typeof = object.$$typeof;
        switch($$typeof){
            case REACT_ELEMENT_TYPE:
                {
                    const type = object.type;
                    switch(type){
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                        case REACT_SUSPENSE_LIST_TYPE:
                            return type;
                        default:
                            {
                                const $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_SERVER_CONTEXT_TYPE:
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                            }
                    }
                }
            case REACT_PORTAL_TYPE:
                return $$typeof;
        }
    }
    return void 0;
}
function isContextConsumer(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isMemo(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
}
// src/utils/warning.ts
function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") console.error(message);
    try {
        throw new Error(message);
    } catch (e) {}
}
// src/connect/verifySubselectors.ts
function verify(selector, methodName) {
    if (!selector) throw new Error(`Unexpected value for ${methodName} in connect.`);
    else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
        if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);
    }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {
    verify(mapStateToProps, "mapStateToProps");
    verify(mapDispatchToProps, "mapDispatchToProps");
    verify(mergeProps, "mergeProps");
}
// src/connect/selectorFactory.ts
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {
    let hasRunAtLeastOnce = false;
    let state;
    let ownProps;
    let stateProps;
    let dispatchProps;
    let mergedProps;
    function handleFirstCall(firstState, firstOwnProps) {
        state = firstState;
        ownProps = firstOwnProps;
        stateProps = mapStateToProps(state, ownProps);
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        hasRunAtLeastOnce = true;
        return mergedProps;
    }
    function handleNewPropsAndNewState() {
        stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleNewProps() {
        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleNewState() {
        const nextStateProps = mapStateToProps(state, ownProps);
        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
        stateProps = nextStateProps;
        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleSubsequentCalls(nextState, nextOwnProps) {
        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
        state = nextState;
        ownProps = nextOwnProps;
        if (propsChanged && stateChanged) return handleNewPropsAndNewState();
        if (propsChanged) return handleNewProps();
        if (stateChanged) return handleNewState();
        return mergedProps;
    }
    return function pureFinalPropsSelector(nextState, nextOwnProps) {
        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
}
function finalPropsSelectorFactory(dispatch, _a) {
    var _b = _a, { initMapStateToProps, initMapDispatchToProps, initMergeProps } = _b, options = __objRest(_b, [
        "initMapStateToProps",
        "initMapDispatchToProps",
        "initMergeProps"
    ]);
    const mapStateToProps = initMapStateToProps(dispatch, options);
    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    const mergeProps = initMergeProps(dispatch, options);
    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);
    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
// src/utils/bindActionCreators.ts
function bindActionCreators(actionCreators, dispatch) {
    const boundActionCreators = {};
    for(const key in actionCreators){
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));
    }
    return boundActionCreators;
}
// src/utils/isPlainObject.ts
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    const proto = Object.getPrototypeOf(obj);
    if (proto === null) return true;
    let baseProto = proto;
    while(Object.getPrototypeOf(baseProto) !== null)baseProto = Object.getPrototypeOf(baseProto);
    return proto === baseProto;
}
// src/utils/verifyPlainObject.ts
function verifyPlainObject(value, displayName, methodName) {
    if (!isPlainObject(value)) warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);
}
// src/connect/wrapMapToProps.ts
function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch) {
        const constant = getConstant(dispatch);
        function constantSelector() {
            return constant;
        }
        constantSelector.dependsOnOwnProps = false;
        return constantSelector;
    };
}
function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, { displayName }) {
        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
        };
        proxy.dependsOnOwnProps = true;
        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
            proxy.mapToProps = mapToProps;
            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
            let props = proxy(stateOrDispatch, ownProps);
            if (typeof props === "function") {
                proxy.mapToProps = props;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                props = proxy(stateOrDispatch, ownProps);
            }
            verifyPlainObject(props, displayName, methodName);
            return props;
        };
        return proxy;
    };
}
// src/connect/invalidArgFactory.ts
function createInvalidArgFactory(arg, name) {
    return (dispatch, options)=>{
        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);
    };
}
// src/connect/mapDispatchToProps.ts
function mapDispatchToPropsFactory(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore
        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({
            dispatch
        })) : typeof mapDispatchToProps === "function" ? // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}
// src/connect/mapStateToProps.ts
function mapStateToPropsFactory(mapStateToProps) {
    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === "function" ? // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
// src/connect/mergeProps.ts
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return __spreadValues(__spreadValues(__spreadValues({}, ownProps), stateProps), dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
        let hasRunOnce = false;
        let mergedProps;
        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            if (hasRunOnce) {
                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
            } else {
                hasRunOnce = true;
                mergedProps = nextMergedProps;
                verifyPlainObject(mergedProps, displayName, "mergeProps");
            }
            return mergedProps;
        };
    };
}
function mergePropsFactory(mergeProps) {
    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
// src/utils/batch.ts
function defaultNoopBatch(callback) {
    callback();
}
// src/utils/Subscription.ts
function createListenerCollection() {
    let first = null;
    let last = null;
    return {
        clear () {
            first = null;
            last = null;
        },
        notify () {
            defaultNoopBatch(()=>{
                let listener = first;
                while(listener){
                    listener.callback();
                    listener = listener.next;
                }
            });
        },
        get () {
            const listeners = [];
            let listener = first;
            while(listener){
                listeners.push(listener);
                listener = listener.next;
            }
            return listeners;
        },
        subscribe (callback) {
            let isSubscribed = true;
            const listener = last = {
                callback,
                next: null,
                prev: last
            };
            if (listener.prev) listener.prev.next = listener;
            else first = listener;
            return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) listener.next.prev = listener.prev;
                else last = listener.prev;
                if (listener.prev) listener.prev.next = listener.next;
                else first = listener.next;
            };
        }
    };
}
var nullListeners = {
    notify () {},
    get: ()=>[]
};
function createSubscription(store, parentSub) {
    let unsubscribe;
    let listeners = nullListeners;
    let subscriptionsAmount = 0;
    let selfSubscribed = false;
    function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return ()=>{
            if (!removed) {
                removed = true;
                cleanupListener();
                tryUnsubscribe();
            }
        };
    }
    function notifyNestedSubs() {
        listeners.notify();
    }
    function handleChangeWrapper() {
        if (subscription.onStateChange) subscription.onStateChange();
    }
    function isSubscribed() {
        return selfSubscribed;
    }
    function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
            listeners = createListenerCollection();
        }
    }
    function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
            unsubscribe();
            unsubscribe = void 0;
            listeners.clear();
            listeners = nullListeners;
        }
    }
    function trySubscribeSelf() {
        if (!selfSubscribed) {
            selfSubscribed = true;
            trySubscribe();
        }
    }
    function tryUnsubscribeSelf() {
        if (selfSubscribed) {
            selfSubscribed = false;
            tryUnsubscribe();
        }
    }
    const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: ()=>listeners
    };
    return subscription;
}
// src/utils/useIsomorphicLayoutEffect.ts
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;
// src/utils/shallowEqual.ts
function is(x, y) {
    if (x === y) return x !== 0 || y !== 0 || 1 / x === 1 / y;
    else return x !== x && y !== y;
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return false;
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for(let i = 0; i < keysA.length; i++){
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) return false;
    }
    return true;
}
// src/utils/hoistStatics.ts
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};
var TYPE_STATICS = {
    [ForwardRef]: FORWARD_REF_STATICS,
    [Memo]: MEMO_STATICS
};
function getStatics(component) {
    if (isMemo(component)) return MEMO_STATICS;
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
    if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
            const inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) hoistNonReactStatics(targetComponent, inheritedComponent);
        }
        let keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        const targetStatics = getStatics(targetComponent);
        const sourceStatics = getStatics(sourceComponent);
        for(let i = 0; i < keys.length; ++i){
            const key = keys[i];
            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }
    }
    return targetComponent;
}
// src/components/connect.tsx
var useSyncExternalStore = notInitialized;
var initializeConnect = (fn)=>{
    useSyncExternalStore = fn;
};
var NO_SUBSCRIPTION_ARRAY = [
    null,
    null
];
var stringifyComponent = (Comp)=>{
    try {
        return JSON.stringify(Comp);
    } catch (err) {
        return String(Comp);
    }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
    lastWrapperProps.current = wrapperProps;
    renderIsScheduled.current = false;
    if (childPropsFromStoreUpdate.current) {
        childPropsFromStoreUpdate.current = null;
        notifyNestedSubs();
    }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
    if (!shouldHandleStateChanges) return ()=>{};
    let didUnsubscribe = false;
    let lastThrownError = null;
    const checkForUpdates = ()=>{
        if (didUnsubscribe || !isMounted.current) return;
        const latestStoreState = store.getState();
        let newChildProps, error;
        try {
            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
        } catch (e) {
            error = e;
            lastThrownError = e;
        }
        if (!error) lastThrownError = null;
        if (newChildProps === lastChildProps.current) {
            if (!renderIsScheduled.current) notifyNestedSubs();
        } else {
            lastChildProps.current = newChildProps;
            childPropsFromStoreUpdate.current = newChildProps;
            renderIsScheduled.current = true;
            additionalSubscribeListener();
        }
    };
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    const unsubscribeWrapper = ()=>{
        didUnsubscribe = true;
        subscription.tryUnsubscribe();
        subscription.onStateChange = null;
        if (lastThrownError) throw lastThrownError;
    };
    return unsubscribeWrapper;
}
function strictEqual(a, b) {
    return a === b;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
// @ts-ignore
pure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component
forwardRef = false, // the context consumer to use
context = ReactReduxContext } = {}) {
    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
        hasWarnedAboutDeprecatedPureOption = true;
        warning('The `pure` option has been removed. `connect` is now always a "pure/memoized" component');
    }
    const Context = context;
    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
    const initMergeProps = mergePropsFactory(mergeProps);
    const shouldHandleStateChanges = Boolean(mapStateToProps);
    const wrapWithConnect = (WrappedComponent)=>{
        {
            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);
            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);
        }
        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
        const displayName = `Connect(${wrappedComponentName})`;
        const selectorFactoryOptions = {
            shouldHandleStateChanges,
            displayName,
            wrappedComponentName,
            WrappedComponent,
            // @ts-ignore
            initMapStateToProps,
            // @ts-ignore
            initMapDispatchToProps,
            initMergeProps,
            areStatesEqual,
            areStatePropsEqual,
            areOwnPropsEqual,
            areMergedPropsEqual
        };
        function ConnectFunction(props) {
            const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(()=>{
                const _a = props, { reactReduxForwardedRef: reactReduxForwardedRef2 } = _a, wrapperProps2 = __objRest(_a, [
                    "reactReduxForwardedRef"
                ]);
                return [
                    props.context,
                    reactReduxForwardedRef2,
                    wrapperProps2
                ];
            }, [
                props
            ]);
            const ContextToUse = React.useMemo(()=>{
                let ResultContext = Context;
                if (propsContext == null ? void 0 : propsContext.Consumer) {
                    const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore
                    /* @__PURE__ */ React.createElement(propsContext.Consumer, null));
                    if (!isValid) throw new Error("You must pass a valid React context consumer as `props.context`");
                    ResultContext = propsContext;
                }
                return ResultContext;
            }, [
                propsContext,
                Context
            ]);
            const contextValue = React.useContext(ContextToUse);
            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
            if (!didStoreComeFromProps && !didStoreComeFromContext) throw new Error(`Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);
            const store = didStoreComeFromProps ? props.store : contextValue.store;
            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
            const childPropsSelector = React.useMemo(()=>{
                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
            }, [
                store
            ]);
            const [subscription, notifyNestedSubs] = React.useMemo(()=>{
                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);
                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
                return [
                    subscription2,
                    notifyNestedSubs2
                ];
            }, [
                store,
                didStoreComeFromProps,
                contextValue
            ]);
            const overriddenContextValue = React.useMemo(()=>{
                if (didStoreComeFromProps) return contextValue;
                return __spreadProps(__spreadValues({}, contextValue), {
                    subscription
                });
            }, [
                didStoreComeFromProps,
                contextValue,
                subscription
            ]);
            const lastChildProps = React.useRef();
            const lastWrapperProps = React.useRef(wrapperProps);
            const childPropsFromStoreUpdate = React.useRef();
            const renderIsScheduled = React.useRef(false);
            const isProcessingDispatch = React.useRef(false);
            const isMounted = React.useRef(false);
            const latestSubscriptionCallbackError = React.useRef();
            useIsomorphicLayoutEffect(()=>{
                isMounted.current = true;
                return ()=>{
                    isMounted.current = false;
                };
            }, []);
            const actualChildPropsSelector = React.useMemo(()=>{
                const selector = ()=>{
                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) return childPropsFromStoreUpdate.current;
                    return childPropsSelector(store.getState(), wrapperProps);
                };
                return selector;
            }, [
                store,
                wrapperProps
            ]);
            const subscribeForReact = React.useMemo(()=>{
                const subscribe = (reactListener)=>{
                    if (!subscription) return ()=>{};
                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore
                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);
                };
                return subscribe;
            }, [
                subscription
            ]);
            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
                lastWrapperProps,
                lastChildProps,
                renderIsScheduled,
                wrapperProps,
                childPropsFromStoreUpdate,
                notifyNestedSubs
            ]);
            let actualChildProps;
            try {
                actualChildProps = useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);
            } catch (err) {
                if (latestSubscriptionCallbackError.current) err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
                throw err;
            }
            useIsomorphicLayoutEffect(()=>{
                latestSubscriptionCallbackError.current = void 0;
                childPropsFromStoreUpdate.current = void 0;
                lastChildProps.current = actualChildProps;
            });
            const renderedWrappedComponent = React.useMemo(()=>{
                return(// @ts-ignore
                /* @__PURE__ */ React.createElement(WrappedComponent, __spreadProps(__spreadValues({}, actualChildProps), {
                    ref: reactReduxForwardedRef
                })));
            }, [
                reactReduxForwardedRef,
                WrappedComponent,
                actualChildProps
            ]);
            const renderedChild = React.useMemo(()=>{
                if (shouldHandleStateChanges) return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {
                    value: overriddenContextValue
                }, renderedWrappedComponent);
                return renderedWrappedComponent;
            }, [
                ContextToUse,
                renderedWrappedComponent,
                overriddenContextValue
            ]);
            return renderedChild;
        }
        const _Connect = React.memo(ConnectFunction);
        const Connect = _Connect;
        Connect.WrappedComponent = WrappedComponent;
        Connect.displayName = ConnectFunction.displayName = displayName;
        if (forwardRef) {
            const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
                return /* @__PURE__ */ React.createElement(Connect, __spreadProps(__spreadValues({}, props), {
                    reactReduxForwardedRef: ref
                }));
            });
            const forwarded = _forwarded;
            forwarded.displayName = displayName;
            forwarded.WrappedComponent = WrappedComponent;
            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
        }
        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
    };
    return wrapWithConnect;
}
var connect_default = connect;
// src/components/Provider.tsx
function Provider({ store, context, children, serverState, stabilityCheck = "once", identityFunctionCheck = "once" }) {
    const contextValue = React.useMemo(()=>{
        const subscription = createSubscription(store);
        return {
            store,
            subscription,
            getServerState: serverState ? ()=>serverState : void 0,
            stabilityCheck,
            identityFunctionCheck
        };
    }, [
        store,
        serverState,
        stabilityCheck,
        identityFunctionCheck
    ]);
    const previousState = React.useMemo(()=>store.getState(), [
        store
    ]);
    useIsomorphicLayoutEffect(()=>{
        const { subscription } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store.getState()) subscription.notifyNestedSubs();
        return ()=>{
            subscription.tryUnsubscribe();
            subscription.onStateChange = void 0;
        };
    }, [
        contextValue,
        previousState
    ]);
    const Context = context || ReactReduxContext;
    return /* @__PURE__ */ React.createElement(Context.Provider, {
        value: contextValue
    }, children);
}
var Provider_default = Provider;
// src/hooks/useStore.ts
function createStoreHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore
    createReduxContextHook(context);
    const useStore2 = ()=>{
        const { store } = useReduxContext2();
        return store;
    };
    Object.assign(useStore2, {
        withTypes: ()=>useStore2
    });
    return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
// src/hooks/useDispatch.ts
function createDispatchHook(context = ReactReduxContext) {
    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
    const useDispatch2 = ()=>{
        const store = useStore2();
        return store.dispatch;
    };
    Object.assign(useDispatch2, {
        withTypes: ()=>useDispatch2
    });
    return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
// src/exports.ts
var batch = defaultNoopBatch;
// src/index.ts
initializeUseSelector((0, _withSelectorJs.useSyncExternalStoreWithSelector));
initializeConnect(_react.useSyncExternalStore);

},{"react":"deO6h","use-sync-external-store/with-selector.js":"geIT9","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"deO6h":[function(require,module,exports) {
"use strict";
module.exports = require("f3b4f53e937abe36");

},{"f3b4f53e937abe36":"6mbnT"}],"6mbnT":[function(require,module,exports) {
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    "use strict";
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var ReactVersion = "18.2.0";
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types.
    var REACT_ELEMENT_TYPE = Symbol.for("react.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") return maybeIterator;
        return null;
    }
    /**
 * Keeps track of the current dispatcher.
 */ var ReactCurrentDispatcher = {
        /**
   * @internal
   * @type {ReactComponent}
   */ current: null
    };
    /**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */ var ReactCurrentBatchConfig = {
        transition: null
    };
    var ReactCurrentActQueue = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false
    };
    /**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */ var ReactCurrentOwner = {
        /**
   * @internal
   * @type {ReactComponent}
   */ current: null
    };
    var ReactDebugCurrentFrame = {};
    var currentExtraStackFrame = null;
    function setExtraStackFrame(stack) {
        currentExtraStackFrame = stack;
    }
    ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
        currentExtraStackFrame = stack;
    }; // Stack implementation injected by the current renderer.
    ReactDebugCurrentFrame.getCurrentStack = null;
    ReactDebugCurrentFrame.getStackAddendum = function() {
        var stack = ""; // Add an extra top frame while an element is being validated
        if (currentExtraStackFrame) stack += currentExtraStackFrame;
         // Delegate to the injected renderer-specific implementation
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) stack += impl() || "";
        return stack;
    };
    // -----------------------------------------------------------------------------
    var enableScopeAPI = false; // Experimental Create Event Handle API.
    var enableCacheElement = false;
    var enableTransitionTracing = false; // No known bugs, but needs performance testing
    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
    // stuff. Intended to enable React core members to more easily debug scheduling
    // issues in DEV builds.
    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.
    var ReactSharedInternals = {
        ReactCurrentDispatcher: ReactCurrentDispatcher,
        ReactCurrentBatchConfig: ReactCurrentBatchConfig,
        ReactCurrentOwner: ReactCurrentOwner
    };
    ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
    ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning("warn", format, args);
    }
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning("error", format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== "") {
            format += "%s";
            args = args.concat([
                stack
            ]);
        } // eslint-disable-next-line react-internal/safe-string-coercion
        var argsWithFormat = args.map(function(item) {
            return String(item);
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift("Warning: " + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    var didWarnStateUpdateForUnmountedComponent = {};
    function warnNoop(publicInstance, callerName) {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
        var warningKey = componentName + "." + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) return;
        error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
    }
    /**
 * This is the abstract API for an update queue.
 */ var ReactNoopUpdateQueue = {
        /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */ isMounted: function(publicInstance) {
            return false;
        },
        /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
        },
        /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
        },
        /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
        }
    };
    var assign = Object.assign;
    var emptyObject = {};
    Object.freeze(emptyObject);
    /**
 * Base class helpers for the updating state of a component.
 */ function Component(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.
        this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
        // renderer.
        this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    /**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */ Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    /**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */ Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
    };
    var defineDeprecationWarning = function(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
            get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return undefined;
            }
        });
    };
    for(var fnName in deprecatedAPIs)if (deprecatedAPIs.hasOwnProperty(fnName)) defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    /**
 * Convenience component with default shallow equality check for sCU.
 */ function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    // an immutable object with a single mutable value
    function createRef() {
        var refObject = {
            current: null
        };
        Object.seal(refObject);
        return refObject;
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
    function isArray(a) {
        return isArrayImpl(a);
    }
    /*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */ // $FlowFixMe only called in DEV, so void return is not possible.
    function typeName(value) {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        return type;
    } // $FlowFixMe only called in DEV, so void return is not possible.
    function willCoercionThrow(value) {
        try {
            testStringCoercion(value);
            return false;
        } catch (e) {
            return true;
        }
    }
    function testStringCoercion(value) {
        // If you ended up here by following an exception call stack, here's what's
        // happened: you supplied an object or symbol value to React (as a prop, key,
        // DOM attribute, CSS property, string ref, etc.) and when React tried to
        // coerce it to a string using `'' + value`, an exception was thrown.
        //
        // The most common types that will cause this exception are `Symbol` instances
        // and Temporal objects like `Temporal.Instant`. But any object that has a
        // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
        // exception. (Library authors do this to prevent users from using built-in
        // numeric operators like `+` or comparison operators like `>=` because custom
        // methods are needed to perform accurate arithmetic or comparison.)
        //
        // To fix the problem, coerce this object or symbol value to a string before
        // passing it to React. The most reliable way is usually `String(value)`.
        //
        // To find which value is throwing, check the browser or debugger console.
        // Before this exception was thrown, there should be `console.error` output
        // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
        // problem and how that type was used: key, atrribute, input value prop, etc.
        // In most cases, this console output also shows the component and its
        // ancestor components where the exception happened.
        //
        // eslint-disable-next-line react-internal/safe-string-coercion
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber
    function getContextName(type) {
        return type.displayName || "Context";
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
    function getComponentNameFromType(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === "number") error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
        if (typeof type === "function") return type.displayName || type.name || null;
        if (typeof type === "string") return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if (typeof type === "object") switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) return outerName;
                return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentNameFromType(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
    didWarnAboutStringRefs = {};
    function hasValidRef(config) {
        if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.ref !== undefined;
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
        });
    }
    function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
        });
    }
    function warnIfStringRefCannotBeAutoConverted(config) {
        if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
            }
        }
    }
    /**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */ var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type,
            key: key,
            ref: ref,
            props: props,
            // Record the component responsible for creating this element.
            _owner: owner
        };
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
        }); // self and source are DEV only properties.
        Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
        });
        if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
        }
        return element;
    };
    /**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */ function createElement(type, config, children) {
        var propName; // Reserved names are extracted
        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;
        if (config != null) {
            if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config);
            }
            if (hasValidKey(config)) {
                checkKeyStringCoercion(config.key);
                key = "" + config.key;
            }
            self = config.__self === undefined ? null : config.__self;
            source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object
            for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) props[propName] = config[propName];
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) props.children = children;
        else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for(var i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
            if (Object.freeze) Object.freeze(childArray);
            props.children = childArray;
        } // Resolve default props
        if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
        }
        if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) defineKeyPropWarningGetter(props, displayName);
            if (ref) defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
    }
    /**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */ function cloneElement(element, config, children) {
        if (element === null || element === undefined) throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName; // Original props are copied
        var props = assign({}, element.props); // Reserved names are extracted
        var key = element.key;
        var ref = element.ref; // Self is preserved since the owner is preserved.
        var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
        // transpiler, and the original source is probably a better indicator of the
        // true owner.
        var source = element._source; // Owner will be preserved, unless ref is overridden
        var owner = element._owner;
        if (config != null) {
            if (hasValidRef(config)) {
                // Silently steal the ref from the parent.
                ref = config.ref;
                owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
                checkKeyStringCoercion(config.key);
                key = "" + config.key;
            } // Remaining properties override existing props
            var defaultProps;
            if (element.type && element.type.defaultProps) defaultProps = element.type.defaultProps;
            for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === undefined && defaultProps !== undefined) // Resolve default props
                props[propName] = defaultProps[propName];
                else props[propName] = config[propName];
            }
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) props.children = children;
        else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for(var i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
            props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */ function isValidElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var SEPARATOR = ".";
    var SUBSEPARATOR = ":";
    /**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */ function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
            "=": "=0",
            ":": "=2"
        };
        var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
        });
        return "$" + escapedString;
    }
    /**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */ var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
    }
    /**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */ function getElementKey(element, index) {
        // Do some typechecking here since we call this blindly. We want to ensure
        // that we don't block potential future ES APIs.
        if (typeof element === "object" && element !== null && element.key != null) {
            checkKeyStringCoercion(element.key);
            return escape("" + element.key);
        } // Implicit key determined by the index in the set
        return index.toString(36);
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === "undefined" || type === "boolean") // All of the above are perceived as null.
        children = null;
        var invokeCallback = false;
        if (children === null) invokeCallback = true;
        else switch(type){
            case "string":
            case "number":
                invokeCallback = true;
                break;
            case "object":
                switch(children.$$typeof){
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                        invokeCallback = true;
                }
        }
        if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
            // so that it's consistent if the number of children grows:
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                    return c;
                });
            } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                    // The `if` statement here prevents auto-disabling of the safe
                    // coercion ESLint rule, so we must manually disable it below.
                    // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) checkKeyStringCoercion(mappedChild.key);
                    mappedChild = cloneAndReplaceKey(mappedChild, // traverseAllChildren used to do for objects as children
                    escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
                }
                array.push(mappedChild);
            }
            return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0; // Count of children found in the current subtree.
        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children)) for(var i = 0; i < children.length; i++){
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        }
        else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                // Warn about using Maps as children
                if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    didWarnAboutMaps = true;
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while(!(step = iterator.next()).done){
                    child = step.value;
                    nextName = nextNamePrefix + getElementKey(child, ii++);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else if (type === "object") {
                // eslint-disable-next-line react-internal/safe-string-coercion
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
            }
        }
        return subtreeCount;
    }
    /**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */ function mapChildren(children, func, context) {
        if (children == null) return children;
        var result = [];
        var count = 0;
        mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
        });
        return result;
    }
    /**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */ function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
            n++; // Don't return anything
        });
        return n;
    }
    /**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */ function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
            forEachFunc.apply(this, arguments); // Don't return anything.
        }, forEachContext);
    }
    /**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */ function toArray(children) {
        return mapChildren(children, function(child) {
            return child;
        }) || [];
    }
    /**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */ function onlyChild(children) {
        if (!isValidElement(children)) throw new Error("React.Children.only expected to receive a single React element child.");
        return children;
    }
    function createContext(defaultValue) {
        // TODO: Second argument used to be an optional `calculateChangedBits`
        // function. Warn to reserve for future use?
        var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
        };
        context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        // A separate object, but proxies back to the original context object for
        // backwards compatibility. It has a different $$typeof, so we can properly
        // warn for the incorrect usage of Context as a Consumer.
        var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here
        Object.defineProperties(Consumer, {
            Provider: {
                get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                        hasWarnedAboutUsingConsumerProvider = true;
                        error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                },
                set: function(_Provider) {
                    context.Provider = _Provider;
                }
            },
            _currentValue: {
                get: function() {
                    return context._currentValue;
                },
                set: function(_currentValue) {
                    context._currentValue = _currentValue;
                }
            },
            _currentValue2: {
                get: function() {
                    return context._currentValue2;
                },
                set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                }
            },
            _threadCount: {
                get: function() {
                    return context._threadCount;
                },
                set: function(_threadCount) {
                    context._threadCount = _threadCount;
                }
            },
            Consumer: {
                get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                        hasWarnedAboutUsingNestedContextConsumers = true;
                        error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                }
            },
            displayName: {
                get: function() {
                    return context.displayName;
                },
                set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                        warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                        hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                }
            }
        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty
        context.Consumer = Consumer;
        context._currentRenderer = null;
        context._currentRenderer2 = null;
        return context;
    }
    var Uninitialized = -1;
    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;
    function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor(); // Transition to the next state.
            // This might throw either because it's missing or throws. If so, we treat it
            // as still uninitialized and try again next time. Which is the same as what
            // happens if the ctor or any wrappers processing the ctor throws. This might
            // end up fixing it if the resolution was a concurrency bug.
            thenable.then(function(moduleObject) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                    // Transition to the next state.
                    var resolved = payload;
                    resolved._status = Resolved;
                    resolved._result = moduleObject;
                }
            }, function(error) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                    // Transition to the next state.
                    var rejected = payload;
                    rejected._status = Rejected;
                    rejected._result = error;
                }
            });
            if (payload._status === Uninitialized) {
                // In case, we're still uninitialized, then we're waiting for the thenable
                // to resolve. Set it as pending in the meantime.
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
            }
        }
        if (payload._status === Resolved) {
            var moduleObject = payload._result;
            if (moduleObject === undefined) error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
            if (!("default" in moduleObject)) error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
            return moduleObject.default;
        } else throw payload._result;
    }
    function lazy(ctor) {
        var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
        };
        var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
        };
        // In production, this would just set it on the object.
        var defaultProps;
        var propTypes; // $FlowFixMe
        Object.defineProperties(lazyType, {
            defaultProps: {
                configurable: true,
                get: function() {
                    return defaultProps;
                },
                set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps; // Match production behavior more closely:
                    // $FlowFixMe
                    Object.defineProperty(lazyType, "defaultProps", {
                        enumerable: true
                    });
                }
            },
            propTypes: {
                configurable: true,
                get: function() {
                    return propTypes;
                },
                set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes; // Match production behavior more closely:
                    // $FlowFixMe
                    Object.defineProperty(lazyType, "propTypes", {
                        enumerable: true
                    });
                }
            }
        });
        return lazyType;
    }
    function forwardRef(render) {
        if (render != null && render.$$typeof === REACT_MEMO_TYPE) error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
        else if (typeof render !== "function") error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
        else if (render.length !== 0 && render.length !== 2) error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
        if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        }
        var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render
        };
        var ownName;
        Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name; // The inner component shouldn't inherit this display name in most cases,
                // because the component may be used elsewhere.
                // But it's nice for anonymous functions to inherit the name,
                // so that our component-stack generation logic will display their frames.
                // An anonymous function generally suggests a pattern like:
                //   React.forwardRef((props, ref) => {...});
                // This kind of inner function is not used elsewhere so the side effect is okay.
                if (!render.name && !render.displayName) render.displayName = name;
            }
        });
        return elementType;
    }
    var REACT_MODULE_REFERENCE;
    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") return true;
         // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) return true;
        if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) return true;
        }
        return false;
    }
    function memo(type, compare) {
        if (!isValidElementType(type)) error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
        var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: compare === undefined ? null : compare
        };
        var ownName;
        Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name; // The inner component shouldn't inherit this display name in most cases,
                // because the component may be used elsewhere.
                // But it's nice for anonymous functions to inherit the name,
                // so that our component-stack generation logic will display their frames.
                // An anonymous function generally suggests a pattern like:
                //   React.memo((props) => {...});
                // This kind of inner function is not used elsewhere so the side effect is okay.
                if (!type.name && !type.displayName) type.displayName = name;
            }
        });
        return elementType;
    }
    function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        if (dispatcher === null) error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        // intentionally don't throw our own error because this is in a hot path.
        // Also helps ensure this is inlined.
        return dispatcher;
    }
    function useContext(Context) {
        var dispatcher = resolveDispatcher();
        // TODO: add a more generic warning for invalid values.
        if (Context._context !== undefined) {
            var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
            // and nobody should be using this in existing code.
            if (realContext.Consumer === Context) error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
            else if (realContext.Provider === Context) error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context);
    }
    function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
    }
    function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
    }
    function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
    }
    function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
    }
    function useInsertionEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
    }
    function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
    }
    function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
    }
    function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
    }
    function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
    }
    function useDebugValue(value, formatterFn) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDebugValue(value, formatterFn);
    }
    function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
    }
    function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
    }
    function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
    }
    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {}
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return "\n" + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher$1.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === "string") {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = "\n" + sampleLines[s].replace(" at new ", " at "); // If our component frame is labeled "<anonymous>"
                            // but we have a user-provided "displayName"
                            // splice it in to make the stack more readable.
                            if (fn.displayName && _frame.includes("<anonymous>")) _frame = _frame.replace("<anonymous>", fn.displayName);
                            if (typeof fn === "function") componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0);
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        if (typeof fn === "function") componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return "";
        if (typeof type === "function") return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === "string") return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {}
        }
        return "";
    }
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== "function") {
                    // eslint-disable-next-line react-internal/prod-error-codes
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    function setCurrentlyValidatingElement$1(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
        } else setExtraStackFrame(null);
    }
    var propTypesMisspellWarningShown;
    propTypesMisspellWarningShown = false;
    function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) return "\n\nCheck the render method of `" + name + "`.";
        }
        return "";
    }
    function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
        }
        return "";
    }
    function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) return getSourceInfoErrorAddendum(elementProps.__source);
        return "";
    }
    /**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */ var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
        return info;
    }
    /**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */ function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) return;
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) return;
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        setCurrentlyValidatingElement$1(element);
        error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
    }
    /**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */ function validateChildKeys(node, parentType) {
        if (typeof node !== "object") return;
        if (isArray(node)) for(var i = 0; i < node.length; i++){
            var child = node[i];
            if (isValidElement(child)) validateExplicitKey(child, parentType);
        }
        else if (isValidElement(node)) // This element was passed in a valid location.
        {
            if (node._store) node._store.validated = true;
        } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            {
                if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while(!(step = iterator.next()).done)if (isValidElement(step.value)) validateExplicitKey(step.value, parentType);
                }
            }
        }
    }
    /**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */ function validatePropTypes(element) {
        var type = element.type;
        if (type === null || type === undefined || typeof type === "string") return;
        var propTypes;
        if (typeof type === "function") propTypes = type.propTypes;
        else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) propTypes = type.propTypes;
        else return;
        if (propTypes) {
            // Intentionally inside to avoid triggering lazy initializers:
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
        }
        if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
    /**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */ function validateFragmentProps(fragment) {
        var keys = Object.keys(fragment.props);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
            }
        }
        if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
        }
    }
    function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.
        if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) info += sourceInfo;
            else info += getDeclarationErrorAddendum();
            var typeString;
            if (type === null) typeString = "null";
            else if (isArray(type)) typeString = "array";
            else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
            } else typeString = typeof type;
            error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.
        if (element == null) return element;
         // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)
        if (validType) for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], type);
        if (type === REACT_FRAGMENT_TYPE) validateFragmentProps(element);
        else validatePropTypes(element);
        return element;
    }
    var didWarnAboutDeprecatedCreateFactory = false;
    function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
        } // Legacy hook: remove it
        Object.defineProperty(validatedFactory, "type", {
            enumerable: false,
            get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                    value: type
                });
                return type;
            }
        });
        return validatedFactory;
    }
    function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], newElement.type);
        validatePropTypes(newElement);
        return newElement;
    }
    function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition._updatedFibers = new Set();
        try {
            scope();
        } finally{
            ReactCurrentBatchConfig.transition = prevTransition;
            if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                currentTransition._updatedFibers.clear();
            }
        }
    }
    var didWarnAboutMessageChannel = false;
    var enqueueTaskImpl = null;
    function enqueueTask(task) {
        if (enqueueTaskImpl === null) try {
            // read require off the module object to get around the bundlers.
            // we don't want them to detect a require and bundle a Node polyfill.
            var requireString = ("require" + Math.random()).slice(0, 7);
            var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
            // version of setImmediate, bypassing fake timers if any.
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
        } catch (_err) {
            // we're in a browser
            // we can't use regular timers because they may still be faked
            // so we try MessageChannel+postMessage instead
            enqueueTaskImpl = function(callback) {
                if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(undefined);
            };
        }
        return enqueueTaskImpl(task);
    }
    var actScopeDepth = 0;
    var didWarnNoAwaitAct = false;
    function act(callback) {
        // `act` calls can be nested, so we track the depth. This represents the
        // number of `act` scopes on the stack.
        var prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        if (ReactCurrentActQueue.current === null) // This is the outermost `act` scope. Initialize the queue. The reconciler
        // will detect the queue and use it instead of Scheduler.
        ReactCurrentActQueue.current = [];
        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
        var result;
        try {
            // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
            // set to `true` while the given callback is executed, not for updates
            // triggered during an async event, because this is how the legacy
            // implementation of `act` behaved.
            ReactCurrentActQueue.isBatchingLegacy = true;
            result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
            // which flushed updates immediately after the scope function exits, even
            // if it's an async function.
            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                }
            }
        } catch (error) {
            popActScope(prevActScopeDepth);
            throw error;
        } finally{
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
        }
        if (result !== null && typeof result === "object" && typeof result.then === "function") {
            var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
            // for it to resolve before exiting the current scope.
            var wasAwaited = false;
            var thenable = {
                then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue) {
                        popActScope(prevActScopeDepth);
                        if (actScopeDepth === 0) // We've exited the outermost act scope. Recursively flush the
                        // queue until there's no remaining work.
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                        else resolve(returnValue);
                    }, function(error) {
                        // The callback threw an error.
                        popActScope(prevActScopeDepth);
                        reject(error);
                    });
                }
            };
            if (!didWarnNoAwaitAct && typeof Promise !== "undefined") // eslint-disable-next-line no-undef
            Promise.resolve().then(function() {}).then(function() {
                if (!wasAwaited) {
                    didWarnNoAwaitAct = true;
                    error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                }
            });
            return thenable;
        } else {
            var returnValue = result; // The callback is not an async function. Exit the current scope
            // immediately, without awaiting.
            popActScope(prevActScopeDepth);
            if (actScopeDepth === 0) {
                // Exiting the outermost act scope. Flush the queue.
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                } // Return a thenable. If the user awaits it, we'll flush again in
                // case additional work was scheduled by a microtask.
                var _thenable = {
                    then: function(resolve, reject) {
                        // Confirm we haven't re-entered another `act` scope, in case
                        // the user does something weird like await the thenable
                        // multiple times.
                        if (ReactCurrentActQueue.current === null) {
                            // Recursively flush the queue until there's no remaining work.
                            ReactCurrentActQueue.current = [];
                            recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                        } else resolve(returnValue);
                    }
                };
                return _thenable;
            } else {
                // Since we're inside a nested `act` scope, the returned thenable
                // immediately resolves. The outer scope will flush the queue.
                var _thenable2 = {
                    then: function(resolve, reject) {
                        resolve(returnValue);
                    }
                };
                return _thenable2;
            }
        }
    }
    function popActScope(prevActScopeDepth) {
        if (prevActScopeDepth !== actScopeDepth - 1) error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
        actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactCurrentActQueue.current;
        if (queue !== null) try {
            flushActQueue(queue);
            enqueueTask(function() {
                if (queue.length === 0) {
                    // No additional work was scheduled. Finish.
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                } else // Keep flushing work until there's none left.
                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
        } catch (error) {
            reject(error);
        }
        else resolve(returnValue);
    }
    var isFlushing = false;
    function flushActQueue(queue) {
        if (!isFlushing) {
            // Prevent re-entrance.
            isFlushing = true;
            var i = 0;
            try {
                for(; i < queue.length; i++){
                    var callback = queue[i];
                    do callback = callback(true);
                    while (callback !== null);
                }
                queue.length = 0;
            } catch (error) {
                // If something throws, leave the remaining callbacks on the queue.
                queue = queue.slice(i + 1);
                throw error;
            } finally{
                isFlushing = false;
            }
        }
    }
    var createElement$1 = createElementWithValidation;
    var cloneElement$1 = cloneElementWithValidation;
    var createFactory = createFactoryWithValidation;
    var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
    };
    exports.Children = Children;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
    exports.cloneElement = cloneElement$1;
    exports.createContext = createContext;
    exports.createElement = createElement$1;
    exports.createFactory = createFactory;
    exports.createRef = createRef;
    exports.forwardRef = forwardRef;
    exports.isValidElement = isValidElement;
    exports.lazy = lazy;
    exports.memo = memo;
    exports.startTransition = startTransition;
    exports.unstable_act = act;
    exports.useCallback = useCallback;
    exports.useContext = useContext;
    exports.useDebugValue = useDebugValue;
    exports.useDeferredValue = useDeferredValue;
    exports.useEffect = useEffect;
    exports.useId = useId;
    exports.useImperativeHandle = useImperativeHandle;
    exports.useInsertionEffect = useInsertionEffect;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useMemo = useMemo;
    exports.useReducer = useReducer;
    exports.useRef = useRef;
    exports.useState = useState;
    exports.useSyncExternalStore = useSyncExternalStore;
    exports.useTransition = useTransition;
    exports.version = ReactVersion;
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
})();

},{}],"geIT9":[function(require,module,exports) {
"use strict";
module.exports = require("708cbb4a61023a28");

},{"708cbb4a61023a28":"66Ben"}],"66Ben":[function(require,module,exports) {
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    "use strict";
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var React = require("a48f2f62c79e7a46");
    /**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */ function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
        ;
    }
    var objectIs = typeof Object.is === "function" ? Object.is : is;
    var useSyncExternalStore = React.useSyncExternalStore;
    // for CommonJS interop.
    var useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.
    function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        // Use this to track the rendered snapshot.
        var instRef = useRef(null);
        var inst;
        if (instRef.current === null) {
            inst = {
                hasValue: false,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        var _useMemo = useMemo(function() {
            // Track the memoized state using closure variables that are local to this
            // memoized instance of a getSnapshot function. Intentionally not using a
            // useRef hook, because that state would be shared across all concurrent
            // copies of the hook/component.
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                    // The first time the hook is called, there is no memoized result.
                    hasMemo = true;
                    memoizedSnapshot = nextSnapshot;
                    var _nextSelection = selector(nextSnapshot);
                    if (isEqual !== undefined) // Even if the selector has changed, the currently rendered selection
                    // may be equal to the new selection. We should attempt to reuse the
                    // current value if possible, to preserve downstream memoizations.
                    {
                        if (inst.hasValue) {
                            var currentSelection = inst.value;
                            if (isEqual(currentSelection, _nextSelection)) {
                                memoizedSelection = currentSelection;
                                return currentSelection;
                            }
                        }
                    }
                    memoizedSelection = _nextSelection;
                    return _nextSelection;
                } // We may be able to reuse the previous invocation's result.
                // We may be able to reuse the previous invocation's result.
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) // The snapshot is the same as last time. Reuse the previous selection.
                return prevSelection;
                 // The snapshot has changed, so we need to compute a new selection.
                // The snapshot has changed, so we need to compute a new selection.
                var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data
                // has changed. If it hasn't, return the previous selection. That signals
                // to React that the selections are conceptually equal, and we can bail
                // out of rendering.
                // If a custom isEqual function is provided, use that to check if the data
                // has changed. If it hasn't, return the previous selection. That signals
                // to React that the selections are conceptually equal, and we can bail
                // out of rendering.
                if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) return prevSelection;
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
            }; // Assigning this to a constant so that Flow knows it can't change.
            // Assigning this to a constant so that Flow knows it can't change.
            var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function() {
                return memoizedSelector(maybeGetServerSnapshot());
            };
            return [
                getSnapshotWithSelector,
                getServerSnapshotWithSelector
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
        useEffect(function() {
            inst.hasValue = true;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    }
    exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
})();

},{"a48f2f62c79e7a46":"deO6h"}],"2MS7Z":[function(require,module,exports) {
"use strict";
var _localStorage = require("5d4f71de55428f87");
var _localStorage2 = _interopRequireDefault(_localStorage);
var _syncStorage = require("19680ef65d313b");
var _syncStorage2 = _interopRequireDefault(_syncStorage);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
module.exports = {
    localStorage: _localStorage2.default,
    syncStorage: _syncStorage2.default
};

},{"5d4f71de55428f87":"lECHU","19680ef65d313b":"kF1qQ"}],"lECHU":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createStorage = require("4ad5e0f4e633ccb5");
var _createStorage2 = _interopRequireDefault(_createStorage);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.default = (0, _createStorage2.default)("local");

},{"4ad5e0f4e633ccb5":"c9tRL"}],"c9tRL":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createStorage;
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function createStorage(type) {
    return {
        getItem: function getItem(key) {
            return new Promise(function(resolve, reject) {
                chrome.storage[type].get(key, function(value) {
                    if (chrome.runtime.lastError == null) // Chrome Storage returns the value in an Object of with its original key. Unwrap the
                    // value from the returned Object to match the `getItem` API.
                    resolve(value[key]);
                    else reject();
                });
            });
        },
        removeItem: function removeItem(key) {
            return new Promise(function(resolve, reject) {
                chrome.storage[type].remove(key, function() {
                    if (chrome.runtime.lastError == null) resolve();
                    else reject();
                });
            });
        },
        setItem: function setItem(key, value) {
            return new Promise(function(resolve, reject) {
                chrome.storage[type].set(_defineProperty({}, key, value), function() {
                    if (chrome.runtime.lastError == null) resolve();
                    else reject();
                });
            });
        }
    };
}

},{}],"kF1qQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createStorage = require("d6e6ff7339f123c9");
var _createStorage2 = _interopRequireDefault(_createStorage);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.default = (0, _createStorage2.default)("sync");

},{"d6e6ff7339f123c9":"c9tRL"}],"ljLcS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "persistReducer", ()=>(0, _persistReducerDefault.default));
parcelHelpers.export(exports, "persistCombineReducers", ()=>(0, _persistCombineReducersDefault.default));
parcelHelpers.export(exports, "persistStore", ()=>(0, _persistStoreDefault.default));
parcelHelpers.export(exports, "createMigrate", ()=>(0, _createMigrateDefault.default));
parcelHelpers.export(exports, "createTransform", ()=>(0, _createTransformDefault.default));
parcelHelpers.export(exports, "getStoredState", ()=>(0, _getStoredStateDefault.default));
parcelHelpers.export(exports, "createPersistoid", ()=>(0, _createPersistoidDefault.default));
parcelHelpers.export(exports, "purgeStoredState", ()=>(0, _purgeStoredStateDefault.default));
var _persistReducer = require("./persistReducer");
var _persistReducerDefault = parcelHelpers.interopDefault(_persistReducer);
var _persistCombineReducers = require("./persistCombineReducers");
var _persistCombineReducersDefault = parcelHelpers.interopDefault(_persistCombineReducers);
var _persistStore = require("./persistStore");
var _persistStoreDefault = parcelHelpers.interopDefault(_persistStore);
var _createMigrate = require("./createMigrate");
var _createMigrateDefault = parcelHelpers.interopDefault(_createMigrate);
var _createTransform = require("./createTransform");
var _createTransformDefault = parcelHelpers.interopDefault(_createTransform);
var _getStoredState = require("./getStoredState");
var _getStoredStateDefault = parcelHelpers.interopDefault(_getStoredState);
var _createPersistoid = require("./createPersistoid");
var _createPersistoidDefault = parcelHelpers.interopDefault(_createPersistoid);
var _purgeStoredState = require("./purgeStoredState");
var _purgeStoredStateDefault = parcelHelpers.interopDefault(_purgeStoredState);
var _constants = require("./constants");
parcelHelpers.exportAll(_constants, exports);

},{"./persistReducer":"hWy4Y","./persistCombineReducers":"cUBRU","./persistStore":"4IDDd","./createMigrate":"7MNoB","./createTransform":"c3bse","./getStoredState":"dQf9h","./createPersistoid":"kvP7X","./purgeStoredState":"beDyl","./constants":"2gBUl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"hWy4Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>persistReducer);
var _constants = require("./constants");
var _autoMergeLevel1 = require("./stateReconciler/autoMergeLevel1");
var _autoMergeLevel1Default = parcelHelpers.interopDefault(_autoMergeLevel1);
var _createPersistoid = require("./createPersistoid");
var _createPersistoidDefault = parcelHelpers.interopDefault(_createPersistoid);
var _getStoredState = require("./getStoredState");
var _getStoredStateDefault = parcelHelpers.interopDefault(_getStoredState);
var _purgeStoredState = require("./purgeStoredState");
var _purgeStoredStateDefault = parcelHelpers.interopDefault(_purgeStoredState);
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
const DEFAULT_TIMEOUT = 5000;
function persistReducer(config, baseReducer) {
    if (!config) throw new Error("config is required for persistReducer");
    if (!config.key) throw new Error("key is required in persistor config");
    if (!config.storage) throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
    const version = config.version !== undefined ? config.version : (0, _constants.DEFAULT_VERSION);
    const stateReconciler = config.stateReconciler === undefined ? (0, _autoMergeLevel1Default.default) : config.stateReconciler;
    const getStoredState = config.getStoredState || (0, _getStoredStateDefault.default);
    const timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;
    let _persistoid = null;
    let _purge = false;
    let _paused = true;
    const conditionalUpdate = (state)=>{
        // update the persistoid only if we are rehydrated and not paused
        state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
        return state;
    };
    return (state, action)=>{
        const _a = state || {}, { _persist } = _a, rest = __rest(_a, [
            "_persist"
        ]);
        const restState = rest;
        if (action.type === (0, _constants.PERSIST)) {
            let _sealed = false;
            const _rehydrate = (payload, err)=>{
                // dev warning if we are already sealed
                if (_sealed) console.error(`redux-persist: rehydrate for "${config.key}" called after timeout.`, payload, err);
                // only rehydrate if we are not already sealed
                if (!_sealed) {
                    action.rehydrate(config.key, payload, err);
                    _sealed = true;
                }
            };
            timeout && setTimeout(()=>{
                !_sealed && _rehydrate(undefined, new Error(`redux-persist: persist timed out for persist key "${config.key}"`));
            }, timeout);
            // @NOTE PERSIST resumes if paused.
            _paused = false;
            // @NOTE only ever create persistoid once, ensure we call it at least once, even if _persist has already been set
            if (!_persistoid) _persistoid = (0, _createPersistoidDefault.default)(config);
            // @NOTE PERSIST can be called multiple times, noop after the first
            if (_persist) // We still need to call the base reducer because there might be nested
            // uses of persistReducer which need to be aware of the PERSIST action
            return Object.assign(Object.assign({}, baseReducer(restState, action)), {
                _persist
            });
            if (typeof action.rehydrate !== "function" || typeof action.register !== "function") throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
            action.register(config.key);
            getStoredState(config).then((restoredState)=>{
                if (restoredState) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const migrate = config.migrate || ((s, _)=>Promise.resolve(s));
                    migrate(restoredState, version).then((migratedState)=>{
                        _rehydrate(migratedState);
                    }, (migrateErr)=>{
                        if (migrateErr) console.error("redux-persist: migration error", migrateErr);
                        _rehydrate(undefined, migrateErr);
                    });
                }
            }, (err)=>{
                _rehydrate(undefined, err);
            });
            return Object.assign(Object.assign({}, baseReducer(restState, action)), {
                _persist: {
                    version,
                    rehydrated: false
                }
            });
        } else if (action.type === (0, _constants.PURGE)) {
            _purge = true;
            action.result((0, _purgeStoredStateDefault.default)(config));
            return Object.assign(Object.assign({}, baseReducer(restState, action)), {
                _persist
            });
        } else if (action.type === (0, _constants.RESYNC)) {
            getStoredState(config).then((restoredState)=>action.rehydrate(config.key, restoredState, undefined), (err)=>action.rehydrate(config.key, undefined, err)).then(()=>action.result());
            return Object.assign(Object.assign({}, baseReducer(restState, action)), {
                _persist: {
                    version,
                    rehydrated: false
                }
            });
        } else if (action.type === (0, _constants.FLUSH)) {
            action.result(_persistoid && _persistoid.flush());
            return Object.assign(Object.assign({}, baseReducer(restState, action)), {
                _persist
            });
        } else if (action.type === (0, _constants.PAUSE)) _paused = true;
        else if (action.type === (0, _constants.REHYDRATE)) {
            // noop on restState if purging
            if (_purge) return Object.assign(Object.assign({}, restState), {
                _persist: Object.assign(Object.assign({}, _persist), {
                    rehydrated: true
                })
            });
            // @NOTE if key does not match, will continue to default else below
            if (action.key === config.key) {
                const reducedState = baseReducer(restState, action);
                const inboundState = action.payload;
                // only reconcile state if stateReconciler and inboundState are both defined
                const reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
                const newState = Object.assign(Object.assign({}, reconciledRest), {
                    _persist: Object.assign(Object.assign({}, _persist), {
                        rehydrated: true
                    })
                });
                return conditionalUpdate(newState);
            }
        }
        // if we have not already handled PERSIST, straight passthrough
        if (!_persist) return baseReducer(state, action);
        // run base reducer:
        // is state modified ? return original : return updated
        const newState = baseReducer(restState, action);
        if (newState === restState) return state;
        return conditionalUpdate(Object.assign(Object.assign({}, newState), {
            _persist
        }));
    };
}

},{"./constants":"2gBUl","./stateReconciler/autoMergeLevel1":"6nhUz","./createPersistoid":"kvP7X","./getStoredState":"dQf9h","./purgeStoredState":"beDyl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"2gBUl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KEY_PREFIX", ()=>KEY_PREFIX);
parcelHelpers.export(exports, "FLUSH", ()=>FLUSH);
parcelHelpers.export(exports, "REHYDRATE", ()=>REHYDRATE);
parcelHelpers.export(exports, "RESYNC", ()=>RESYNC);
parcelHelpers.export(exports, "PAUSE", ()=>PAUSE);
parcelHelpers.export(exports, "PERSIST", ()=>PERSIST);
parcelHelpers.export(exports, "PURGE", ()=>PURGE);
parcelHelpers.export(exports, "REGISTER", ()=>REGISTER);
parcelHelpers.export(exports, "DEFAULT_VERSION", ()=>DEFAULT_VERSION);
const KEY_PREFIX = "persist:";
const FLUSH = "persist/FLUSH";
const REHYDRATE = "persist/REHYDRATE";
const RESYNC = "persist/RESYNC";
const PAUSE = "persist/PAUSE";
const PERSIST = "persist/PERSIST";
const PURGE = "persist/PURGE";
const REGISTER = "persist/REGISTER";
const DEFAULT_VERSION = -1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"6nhUz":[function(require,module,exports) {
/*
  autoMergeLevel1:
    - merges 1 level of substate
    - skips substate if already modified
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>autoMergeLevel1);
function autoMergeLevel1(inboundState, originalState, reducedState, { debug }) {
    const newState = Object.assign({}, reducedState);
    // only rehydrate if inboundState exists and is an object
    if (inboundState && typeof inboundState === "object") {
        const keys = Object.keys(inboundState);
        keys.forEach((key)=>{
            // ignore _persist data
            if (key === "_persist") return;
            // if reducer modifies substate, skip auto rehydration
            if (originalState[key] !== reducedState[key]) {
                if (debug) console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
                return;
            }
            // otherwise hard set the new value
            newState[key] = inboundState[key];
        });
    }
    if (debug && inboundState && typeof inboundState === "object") console.log(`redux-persist/stateReconciler: rehydrated keys '${Object.keys(inboundState).join(", ")}'`);
    return newState;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"kvP7X":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-explicit-any */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createPersistoid);
var _constants = require("./constants");
function createPersistoid(config) {
    // defaults
    const blacklist = config.blacklist || null;
    const whitelist = config.whitelist || null;
    const transforms = config.transforms || [];
    const throttle = config.throttle || 0;
    const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : (0, _constants.KEY_PREFIX)}${config.key}`;
    const storage = config.storage;
    let serialize;
    if (config.serialize === false) serialize = (x)=>x;
    else if (typeof config.serialize === "function") serialize = config.serialize;
    else serialize = defaultSerialize;
    const writeFailHandler = config.writeFailHandler || null;
    // initialize stateful values
    let lastState = {};
    const stagedState = {};
    const keysToProcess = [];
    let timeIterator = null;
    let writePromise = null;
    const update = (state)=>{
        // add any changed keys to the queue
        Object.keys(state).forEach((key)=>{
            if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop
            if (lastState[key] === state[key]) return; // value unchanged? noop
            if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop
            keysToProcess.push(key); // add key to queue
        });
        //if any key is missing in the new state which was present in the lastState,
        //add it for processing too
        Object.keys(lastState).forEach((key)=>{
            if (state[key] === undefined && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== undefined) keysToProcess.push(key);
        });
        // start the time iterator if not running (read: throttle)
        if (timeIterator === null) timeIterator = setInterval(processNextKey, throttle);
        lastState = state;
    };
    function processNextKey() {
        if (keysToProcess.length === 0) {
            if (timeIterator) clearInterval(timeIterator);
            timeIterator = null;
            return;
        }
        const key = keysToProcess.shift();
        if (key === undefined) return;
        const endState = transforms.reduce((subState, transformer)=>{
            return transformer.in(subState, key, lastState);
        }, lastState[key]);
        if (endState !== undefined) try {
            stagedState[key] = serialize(endState);
        } catch (err) {
            console.error("redux-persist/createPersistoid: error serializing state", err);
        }
        else //if the endState is undefined, no need to persist the existing serialized content
        delete stagedState[key];
        if (keysToProcess.length === 0) writeStagedState();
    }
    function writeStagedState() {
        // cleanup any removed keys just before write.
        Object.keys(stagedState).forEach((key)=>{
            if (lastState[key] === undefined) delete stagedState[key];
        });
        writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
    }
    function passWhitelistBlacklist(key) {
        if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist") return false;
        if (blacklist && blacklist.indexOf(key) !== -1) return false;
        return true;
    }
    function onWriteFail(err) {
        // @TODO add fail handlers (typically storage full)
        if (writeFailHandler) writeFailHandler(err);
        if (err && true) console.error("Error storing data", err);
    }
    const flush = ()=>{
        while(keysToProcess.length !== 0)processNextKey();
        return writePromise || Promise.resolve();
    };
    // return `persistoid`
    return {
        update,
        flush
    };
}
// @NOTE in the future this may be exposed via config
function defaultSerialize(data) {
    return JSON.stringify(data);
}

},{"./constants":"2gBUl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"dQf9h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getStoredState);
var _constants = require("./constants");
function getStoredState(config) {
    const transforms = config.transforms || [];
    const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : (0, _constants.KEY_PREFIX)}${config.key}`;
    const storage = config.storage;
    const debug = config.debug;
    let deserialize;
    if (config.deserialize === false) deserialize = (x)=>x;
    else if (typeof config.deserialize === "function") deserialize = config.deserialize;
    else deserialize = defaultDeserialize;
    return storage.getItem(storageKey).then((serialized)=>{
        if (!serialized) return undefined;
        else try {
            const state = {};
            const rawState = deserialize(serialized);
            Object.keys(rawState).forEach((key)=>{
                state[key] = transforms.reduceRight((subState, transformer)=>{
                    return transformer.out(subState, key, rawState);
                }, deserialize(rawState[key]));
            });
            return state;
        } catch (err) {
            if (debug) console.log(`redux-persist/getStoredState: Error restoring data ${serialized}`, err);
            throw err;
        }
    });
}
function defaultDeserialize(serial) {
    return JSON.parse(serial);
}

},{"./constants":"2gBUl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"beDyl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>purgeStoredState);
var _constants = require("./constants");
function purgeStoredState(config) {
    const storage = config.storage;
    const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : (0, _constants.KEY_PREFIX)}${config.key}`;
    return storage.removeItem(storageKey, warnIfRemoveError);
}
function warnIfRemoveError(err) {
    if (err && true) console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
}

},{"./constants":"2gBUl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"cUBRU":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-explicit-any */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>persistCombineReducers);
var _redux = require("redux");
var _persistReducer = require("./persistReducer");
var _persistReducerDefault = parcelHelpers.interopDefault(_persistReducer);
var _autoMergeLevel2 = require("./stateReconciler/autoMergeLevel2");
var _autoMergeLevel2Default = parcelHelpers.interopDefault(_autoMergeLevel2);
function persistCombineReducers(config, reducers) {
    config.stateReconciler = config.stateReconciler === undefined ? (0, _autoMergeLevel2Default.default) : config.stateReconciler;
    return (0, _persistReducerDefault.default)(config, (0, _redux.combineReducers)(reducers));
}

},{"redux":"ghKXw","./persistReducer":"hWy4Y","./stateReconciler/autoMergeLevel2":"esULx","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"esULx":[function(require,module,exports) {
/*
  autoMergeLevel2:
    - merges 2 level of substate
    - skips substate if already modified
    - this is essentially redux-perist v4 behavior
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>autoMergeLevel2);
function autoMergeLevel2(inboundState, originalState, reducedState, { debug }) {
    const newState = Object.assign({}, reducedState);
    // only rehydrate if inboundState exists and is an object
    if (inboundState && typeof inboundState === "object") {
        const keys = Object.keys(inboundState);
        keys.forEach((key)=>{
            // ignore _persist data
            if (key === "_persist") return;
            // if reducer modifies substate, skip auto rehydration
            if (originalState[key] !== reducedState[key]) {
                if (debug) console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
                return;
            }
            if (isPlainEnoughObject(reducedState[key])) {
                // if object is plain enough shallow merge the new values (hence "Level2")
                newState[key] = Object.assign(Object.assign({}, newState[key]), inboundState[key]);
                return;
            }
            // otherwise hard set
            newState[key] = inboundState[key];
        });
    }
    if (debug && inboundState && typeof inboundState === "object") console.log(`redux-persist/stateReconciler: rehydrated keys '${Object.keys(inboundState).join(", ")}'`);
    return newState;
}
function isPlainEnoughObject(o) {
    return o !== null && !Array.isArray(o) && typeof o === "object";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"4IDDd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>persistStore);
var _redux = require("redux");
var _constants = require("./constants");
const initialState = {
    registry: [],
    bootstrapped: false
};
const persistorReducer = (state = initialState, action)=>{
    const firstIndex = state.registry.indexOf(action.key);
    const registry = [
        ...state.registry
    ];
    switch(action.type){
        case 0, _constants.REGISTER:
            return Object.assign(Object.assign({}, state), {
                registry: [
                    ...state.registry,
                    action.key
                ]
            });
        case 0, _constants.REHYDRATE:
            registry.splice(firstIndex, 1);
            return Object.assign(Object.assign({}, state), {
                registry,
                bootstrapped: registry.length === 0
            });
        default:
            return state;
    }
};
function persistStore(store, options, cb) {
    {
        const optionsToTest = options || {};
        const bannedKeys = [
            "blacklist",
            "whitelist",
            "transforms",
            "storage",
            "keyPrefix",
            "migrate"
        ];
        bannedKeys.forEach((k)=>{
            if (optionsToTest[k]) console.error(`redux-persist: invalid option passed to persistStore: "${k}". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.`);
        });
    }
    let boostrappedCb = cb || false;
    const _pStore = (0, _redux.createStore)(persistorReducer, initialState, options && options.enhancer ? options.enhancer : undefined);
    const register = (key)=>{
        _pStore.dispatch({
            type: (0, _constants.REGISTER),
            key
        });
    };
    const rehydrate = (key, payload, err)=>{
        const rehydrateAction = {
            type: (0, _constants.REHYDRATE),
            payload,
            err,
            key
        };
        // dispatch to `store` to rehydrate and `persistor` to track result
        store.dispatch(rehydrateAction);
        _pStore.dispatch(rehydrateAction);
        if (typeof boostrappedCb === "function" && persistor.getState().bootstrapped) {
            boostrappedCb();
            boostrappedCb = false;
        }
    };
    const persistor = Object.assign(Object.assign({}, _pStore), {
        purge: ()=>{
            const results = [];
            store.dispatch({
                type: (0, _constants.PURGE),
                result: (purgeResult)=>{
                    results.push(purgeResult);
                }
            });
            return Promise.all(results);
        },
        flush: ()=>{
            const results = [];
            store.dispatch({
                type: (0, _constants.FLUSH),
                result: (flushResult)=>{
                    results.push(flushResult);
                }
            });
            return Promise.all(results);
        },
        pause: ()=>{
            store.dispatch({
                type: (0, _constants.PAUSE)
            });
        },
        persist: ()=>{
            store.dispatch({
                type: (0, _constants.PERSIST),
                register,
                rehydrate
            });
        },
        resync: ()=>{
            return new Promise((resolve)=>{
                store.dispatch({
                    type: (0, _constants.RESYNC),
                    rehydrate,
                    result: ()=>resolve()
                });
            });
        }
    });
    if (!(options && options.manualPersist)) persistor.persist();
    return persistor;
}

},{"redux":"ghKXw","./constants":"2gBUl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"7MNoB":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-explicit-any */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createMigrate);
var _constants = require("./constants");
function createMigrate(migrations, config) {
    const { debug } = config || {};
    return function(state, currentVersion) {
        if (!state) {
            if (debug) console.log("redux-persist: no inbound state, skipping migration");
            return Promise.resolve(undefined);
        }
        const inboundVersion = state._persist && state._persist.version !== undefined ? state._persist.version : (0, _constants.DEFAULT_VERSION);
        if (inboundVersion === currentVersion) {
            if (debug) console.log("redux-persist: versions match, noop migration");
            return Promise.resolve(state);
        }
        if (inboundVersion > currentVersion) {
            console.error("redux-persist: downgrading version is not supported");
            return Promise.resolve(state);
        }
        const migrationKeys = Object.keys(migrations).map((ver)=>parseInt(ver)).filter((key)=>currentVersion >= key && key > inboundVersion).sort((a, b)=>a - b);
        if (debug) console.log("redux-persist: migrationKeys", migrationKeys);
        try {
            const migratedState = migrationKeys.reduce((state, versionKey)=>{
                if (debug) console.log("redux-persist: running migration for versionKey", versionKey);
                return migrations[versionKey](state);
            }, state);
            return Promise.resolve(migratedState);
        } catch (err) {
            return Promise.reject(err);
        }
    };
}

},{"./constants":"2gBUl","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"c3bse":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createTransform);
function createTransform(// @NOTE inbound: transform state coming from redux on its way to being serialized and stored
// eslint-disable-next-line @typescript-eslint/ban-types
inbound, // @NOTE outbound: transform state coming from storage, on its way to be rehydrated into redux
// eslint-disable-next-line @typescript-eslint/ban-types
outbound, config = {}) {
    const whitelist = config.whitelist || null;
    const blacklist = config.blacklist || null;
    function whitelistBlacklistCheck(key) {
        if (whitelist && whitelist.indexOf(key) === -1) return true;
        if (blacklist && blacklist.indexOf(key) !== -1) return true;
        return false;
    }
    return {
        in: (state, key, fullState)=>!whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state,
        out: (state, key, fullState)=>!whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"9NURi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseStorage", ()=>o);
parcelHelpers.export(exports, "Storage", ()=>g);
var _pify = require("pify");
var _pifyDefault = parcelHelpers.interopDefault(_pify);
var l = ()=>{
    try {
        let e = globalThis.navigator?.userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (e[1] === "Chrome") return parseInt(e[2]) < 100 || globalThis.chrome.runtime?.getManifest()?.manifest_version === 2;
    } catch  {
        return !1;
    }
    return !1;
};
var o = class {
    #a;
    #e;
    get primaryClient() {
        return this.#e;
    }
    #t;
    get secondaryClient() {
        return this.#t;
    }
    #r;
    get area() {
        return this.#r;
    }
    get hasWebApi() {
        try {
            return typeof window < "u" && !!window.localStorage;
        } catch (e) {
            return console.error(e), !1;
        }
    }
    #s = new Map;
    #i;
    get copiedKeySet() {
        return this.#i;
    }
    isCopied = (e)=>this.hasWebApi && (this.allCopied || this.copiedKeySet.has(e));
    #n = !1;
    get allCopied() {
        return this.#n;
    }
    getExtStorageApi = ()=>globalThis.browser?.storage || globalThis.chrome?.storage;
    get hasExtensionApi() {
        try {
            return !!this.getExtStorageApi();
        } catch (e) {
            return console.error(e), !1;
        }
    }
    isWatchSupported = ()=>this.hasExtensionApi;
    keyNamespace = "";
    isValidKey = (e)=>e.startsWith(this.keyNamespace);
    getNamespacedKey = (e)=>`${this.keyNamespace}${e}`;
    getUnnamespacedKey = (e)=>e.slice(this.keyNamespace.length);
    constructor({ area: e = "sync", allCopied: t = !1, copiedKeyList: s = [] } = {}){
        this.setCopiedKeySet(s), this.#r = e, this.#n = t;
        try {
            this.hasWebApi && (t || s.length > 0) && (this.#t = window.localStorage);
        } catch  {}
        try {
            this.hasExtensionApi && (this.#a = this.getExtStorageApi(), l() ? this.#e = (0, _pifyDefault.default)(this.#a[this.area], {
                exclude: [
                    "getBytesInUse"
                ],
                errorFirst: !1
            }) : this.#e = this.#a[this.area]);
        } catch  {}
    }
    setCopiedKeySet(e) {
        this.#i = new Set(e);
    }
    rawGetAll = ()=>this.#e?.get();
    getAll = async ()=>{
        let e = await this.rawGetAll();
        return Object.entries(e).filter(([t])=>this.isValidKey(t)).reduce((t, [s, a])=>(t[this.getUnnamespacedKey(s)] = a, t), {});
    };
    copy = async (e)=>{
        let t = e === void 0;
        if (!t && !this.copiedKeySet.has(e) || !this.allCopied || !this.hasExtensionApi) return !1;
        let s = this.allCopied ? await this.rawGetAll() : await this.#e.get((t ? [
            ...this.copiedKeySet
        ] : [
            e
        ]).map(this.getNamespacedKey));
        if (!s) return !1;
        let a = !1;
        for(let r in s){
            let i = s[r], n = this.#t?.getItem(r);
            this.#t?.setItem(r, i), a ||= i !== n;
        }
        return a;
    };
    rawGet = async (e)=>this.hasExtensionApi ? (await this.#e.get(e))[e] : this.isCopied(e) ? this.#t?.getItem(e) : null;
    rawSet = async (e, t)=>(this.isCopied(e) && this.#t?.setItem(e, t), this.hasExtensionApi && await this.#e.set({
            [e]: t
        }), null);
    clear = async (e = !1)=>{
        e && this.#t?.clear(), await this.#e.clear();
    };
    rawRemove = async (e)=>{
        this.isCopied(e) && this.#t?.removeItem(e), this.hasExtensionApi && await this.#e.remove(e);
    };
    removeAll = async ()=>{
        let e = await this.rawGetAll(), t = Object.keys(e);
        await Promise.all(t.map(this.rawRemove));
    };
    watch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#o(e), t;
    };
    #o = (e)=>{
        for(let t in e){
            let s = this.getNamespacedKey(t), a = this.#s.get(s)?.callbackSet || new Set;
            if (a.add(e[t]), a.size > 1) continue;
            let r = (i, n)=>{
                if (n !== this.area || !i[s]) return;
                let h = this.#s.get(s);
                if (!h) throw new Error(`Storage comms does not exist for nsKey: ${s}`);
                Promise.all([
                    this.parseValue(i[s].newValue),
                    this.parseValue(i[s].oldValue)
                ]).then(([p, d])=>{
                    for (let m of h.callbackSet)m({
                        newValue: p,
                        oldValue: d
                    }, n);
                });
            };
            this.#a.onChanged.addListener(r), this.#s.set(s, {
                callbackSet: a,
                listener: r
            });
        }
    };
    unwatch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#c(e), t;
    };
    #c(e) {
        for(let t in e){
            let s = this.getNamespacedKey(t), a = e[t], r = this.#s.get(s);
            r && (r.callbackSet.delete(a), r.callbackSet.size === 0 && (this.#s.delete(s), this.#a.onChanged.removeListener(r.listener)));
        }
    }
    unwatchAll = ()=>this.#h();
    #h() {
        this.#s.forEach(({ listener: e })=>this.#a.onChanged.removeListener(e)), this.#s.clear();
    }
    async getItem(e) {
        return this.get(e);
    }
    async setItem(e, t) {
        await this.set(e, t);
    }
    async removeItem(e) {
        return this.remove(e);
    }
}, g = class extends o {
    get = async (e)=>{
        let t = this.getNamespacedKey(e), s = await this.rawGet(t);
        return this.parseValue(s);
    };
    set = async (e, t)=>{
        let s = this.getNamespacedKey(e), a = JSON.stringify(t);
        return this.rawSet(s, a);
    };
    remove = async (e)=>{
        let t = this.getNamespacedKey(e);
        return this.rawRemove(t);
    };
    setNamespace = (e)=>{
        this.keyNamespace = e;
    };
    parseValue = async (e)=>{
        try {
            if (e !== void 0) return JSON.parse(e);
        } catch (t) {
            console.error(t);
        }
    };
};

},{"pify":"1siwu","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"1siwu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pify);
const processFunction = (function_, options, proxy, unwrapped)=>function(...arguments_) {
        const P = options.promiseModule;
        return new P((resolve, reject)=>{
            if (options.multiArgs) arguments_.push((...result)=>{
                if (options.errorFirst) {
                    if (result[0]) reject(result);
                    else {
                        result.shift();
                        resolve(result);
                    }
                } else resolve(result);
            });
            else if (options.errorFirst) arguments_.push((error, result)=>{
                if (error) reject(error);
                else resolve(result);
            });
            else arguments_.push(resolve);
            const self = this === proxy ? unwrapped : this;
            Reflect.apply(function_, self, arguments_);
        });
    };
const filterCache = new WeakMap();
function pify(input, options) {
    options = {
        exclude: [
            /.+(?:Sync|Stream)$/
        ],
        errorFirst: true,
        promiseModule: Promise,
        ...options
    };
    const objectType = typeof input;
    if (!(input !== null && (objectType === "object" || objectType === "function"))) throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
    const filter = (target, key)=>{
        let cached = filterCache.get(target);
        if (!cached) {
            cached = {};
            filterCache.set(target, cached);
        }
        if (key in cached) return cached[key];
        const match = (pattern)=>typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = descriptor === undefined || descriptor.writable || descriptor.configurable;
        const included = options.include ? options.include.some((element)=>match(element)) : !options.exclude.some((element)=>match(element));
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
    };
    const cache = new WeakMap();
    const proxy = new Proxy(input, {
        apply (target, thisArg, args) {
            const cached = cache.get(target);
            if (cached) return Reflect.apply(cached, thisArg, args);
            const pified = options.excludeMain ? target : processFunction(target, options, proxy, target);
            cache.set(target, pified);
            return Reflect.apply(pified, thisArg, args);
        },
        get (target, key) {
            const property = target[key];
            // eslint-disable-next-line no-use-extend-native/no-use-extend-native
            if (!filter(target, key) || property === Function.prototype[key]) return property;
            const cached = cache.get(property);
            if (cached) return cached;
            if (typeof property === "function") {
                const pified = processFunction(property, options, proxy, target);
                cache.set(property, pified);
                return pified;
            }
            return property;
        }
    });
    return proxy;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"8xFUL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initialState", ()=>initialState);
parcelHelpers.export(exports, "setUser", ()=>setUser);
parcelHelpers.export(exports, "setSpaces", ()=>setSpaces);
parcelHelpers.export(exports, "setPreferences", ()=>setPreferences);
var _toolkit = require("@reduxjs/toolkit");
const initialState = {
    preferences: null,
    user: null,
    spaces: []
};
const notionSlice = (0, _toolkit.createSlice)({
    name: "notion",
    initialState,
    reducers: {
        setUser: (state, action)=>{
            state.user = action.payload;
        },
        setSpaces: (state, action)=>{
            state.spaces = action.payload;
        },
        setPreferences: (state, action)=>{
            state.preferences = action.payload;
        }
    }
});
const { setUser, setSpaces, setPreferences } = notionSlice.actions;
exports.default = notionSlice.reducer;

},{"@reduxjs/toolkit":"NXNwC","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}]},["66OA4","8oeFb"], "8oeFb", "parcelRequire8dac")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLFlBQVksQ0FBQSxHQUFBLDBCQUFXLEVBQUU7QUFFdEMsSUFBSSxDQUFBLEdBQUEsZ0JBQU0sSUFBSSxNQUFNO0lBQ2hCLENBQUMsQ0FBQyxRQUFRLEVBQUUsY0FBYyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDL0IsTUFBTSxFQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUMsR0FBRztRQUM3QixNQUFNLGNBQWMsRUFBRTtRQUN0QixJQUFLLE1BQU0sT0FBTyxTQUNkLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsSUFBSSxFQUNqQyxZQUFZLEtBQUs7UUFHekIsSUFBSyxNQUFNLE9BQU8sU0FDZCxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksRUFDakMsWUFBWSxLQUFLO1FBR3pCLElBQUksWUFBWSxTQUFTLEdBQ3JCLFVBQVU7SUFFbEI7QUFDSjtBQUtPLE1BQU0saUJBQW9DLENBQUEsR0FBQSx1QkFBVTtBQUNwRCxNQUFNLGlCQUFrRCxDQUFBLEdBQUEsdUJBQVU7Ozs7O0EsaUQ7QSxzRDtBLG9EO0EsMkM7QSxpRDtBLHVEO0EsdUQ7QSxzRDtBLHVEO0EsbUQ7QSxvRDtBLGtEO0EsNEU7QSxzRDtBLDZEO0Esb0U7QSw2RDtBLHlEO0EsNkU7QSw4RDtBLHFELEMsRyxjO0EsbUQ7QSxvRCxDLEcsd0I7QSwyRCxDLEcsK0I7QSxnRjtBLGlEO0EsNkMsQyxHLGM7QSw4RDtBLDREO0EsNEMsQyxHLGE7QSxxRDtBLDZDO0EsNkM7QSx3RDtBLDZDLEMsRyxjO0EsMEQ7QSxpRDtBLHdEO0EsK0M7QSw2QztBLGdEO0EseUQ7QSxnRCxDLEcsb0I7QSx3RDtBLDRDO0EsOEMsQyxHLGU7QSx3RDtBLG9EO0Esa0Q7QSxvRCxDLEcsd0I7QSxlO0FFL0V6RTtBQUFBLHdCQUFBO0FBQ0E7QUFFQTtBLDhCO0FJSkE7O0EsSSxZLE87QSxJLGEsTztBLEksb0IsTztBLEksc0IsTztBLEksZSxPLFU7QSxJLGUsTyxVO0EsSSxrQixDLEssSyxRLE8sTSxVLEssSztRLFk7USxjO1EsVTtRO0ksSyxHLEMsSSxHO0EsSSxpQixDLEc7SSxJLEksUSxLLEMsSSxDLEMsRSxJLGEsSyxHLE8sZ0IsRyxNLEMsQyxLO0ksSSxxQjtRLEssSSxRLG9CLEcsSSxhLEssRyxPLGdCLEcsTSxDLEMsSztJO0ksTztBO0EsSSxnQixDLEcsSSxXLEcsa0I7QSxJLFksQyxRO0ksSSxTLEM7SSxJLEksUSxPLEksYSxLLFEsUyxRLFEsUSxHLE0sQyxLLEcsTSxDLEs7SSxJLFUsUSxxQjtRLEssSSxRLG9CLFEsSSxRLFEsUSxLLGEsSyxRLE8sTSxDLEssRyxNLEMsSztJO0ksTztBO0EsSSxnQixDLEssSztJLGdCLEssTyxRLFcsTSxLLEs7SSxPO0E7QUhBTyxJQUFNLGlDQUErRCxDQUFBLEdBQUk7SUFDOUUsTUFBTUssa0JBQWtCLENBQUEsR0FBQSwrQkFBQSxLQUFpQztJQUN6RCxNQUFNQywyQkFBMEIsT0FBTyxPQUFPLENBQUEsR0FBSUM7UUFDaEQsTUFBTSxXQUFXRixtQkFBa0JFO1FBRW5DLE1BQU0sa0JBQWtCLENBQUMsT0FBQSxHQUFtQixPQUFvQixTQUFTLENBQUEsR0FBQSxjQUFBLEVBQVEsU0FBUyxDQUFBLEdBQUEsY0FBQSxFQUFRLFNBQVMsVUFBVTtRQUVySCxPQUFPLE9BQU8saUJBQWlCO1FBQy9CLE9BQVE7SUFDVixHQUFHO1FBQ0QsV0FBVyxJQUFNRDtJQUNuQjtJQUNBLE9BQU9BO0FBQ1Q7QUFTTyxJQUFNLDBCQUEwQiwrQkFBK0IsQ0FBQSxHQUFBLHdCQUFBO0FFME4vRCxJQUFNLHNCQUEyQyxPQUFPLFdBQVcsZUFBZ0IsT0FBZSx1Q0FBd0MsT0FBZSx1Q0FBdUM7SUFDck0sSUFBSSxVQUFVLFdBQVcsR0FBRyxPQUFPLEtBQVA7SUFDNUIsSUFBSSxPQUFPLFNBQUEsQ0FBVSxFQUFDLEtBQU0sVUFBVSxPQUFPLEdBQUE7SUFDN0MsT0FBTyxDQUFBLEdBQUEsY0FBQSxFQUFRLE1BQU0sTUFBUTtBQUMvQjtBQUtPLElBQU0sbUJBRVQsT0FBTyxXQUFXLGVBQWdCLE9BQWUsK0JBQWdDLE9B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QWEsT0FBTyxhQUFhO1FBQUcsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFHLENBQUMsQ0FBQSxLQUFJLGNBQWEsT0FBTyxJQUFFLGNBQWEsYUFBYTtRQUFHLElBQUc7WUFBQyxPQUFPLEVBQUU7UUFBRSxFQUFDLE9BQU0sR0FBRTtZQUFDLElBQUc7Z0JBQUMsT0FBTyxFQUFFLEtBQUssTUFBSztZQUFFLEVBQUMsT0FBTSxHQUFFO2dCQUFDLE9BQU8sRUFBRSxLQUFLLElBQUksRUFBQztZQUFFO1FBQUM7SUFBQztJQUFDLElBQUksSUFBRSxFQUFFLEVBQUMsSUFBRSxDQUFDLEdBQUUsR0FBRSxJQUFFO0lBQUcsU0FBUztRQUFJLENBQUMsS0FBRyxDQUFDLEtBQUksQ0FBQSxJQUFFLENBQUMsR0FBRSxFQUFFLFNBQU8sSUFBRSxFQUFFLE9BQU8sS0FBRyxJQUFFLElBQUcsRUFBRSxVQUFRLEdBQUU7SUFBRTtJQUFDLFNBQVM7UUFBSSxJQUFHLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxFQUFFO1lBQUcsSUFBRSxDQUFDO1lBQUUsSUFBSSxJQUFJLElBQUUsRUFBRSxRQUFPLEdBQUc7Z0JBQUMsSUFBSSxJQUFFLEdBQUUsSUFBRSxFQUFFLEVBQUMsRUFBRSxJQUFFLEdBQUcsS0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUFNLElBQUUsSUFBRyxJQUFFLEVBQUU7WUFBTTtZQUFDLElBQUUsTUFBSyxJQUFFLENBQUMsR0FBRSxFQUFFO1FBQUU7SUFBQztJQUFDLEVBQUUsV0FBUyxTQUFTLENBQUM7UUFBRSxJQUFJLElBQUUsSUFBSSxNQUFNLFVBQVUsU0FBTztRQUFHLElBQUcsVUFBVSxTQUFPLEdBQUUsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLFVBQVUsUUFBTyxJQUFJLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQyxTQUFTLENBQUMsRUFBRTtRQUFDLEVBQUUsS0FBSyxJQUFJLEVBQUUsR0FBRSxLQUFJLEVBQUUsV0FBUyxLQUFHLENBQUMsS0FBRyxFQUFFO0lBQUU7SUFBRSxTQUFTLEVBQUUsQ0FB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TyxDQUFDLEdBQUcsSUFBTSxDQUFBLEdBQUksT0FBYyxFQUFFLEtBQUs7QUFDekQ7QSx5QjtBQ09lLFNBQVIsZ0JBQUEsR0FBb0MsV0FBQTtJQUN6QyxPQUFPLENBQUFDLGVBQWUsQ0FBQyxTQUFTO1lBQzlCLE1BQU0sUUFBUUEsYUFBWSxTQUFTO1lBQ25DLElBQUksV0FBcUI7Z0JBQ3ZCLE1BQU0sSUFBSSxNQUE0RTtZQUN4RjtZQUNBLE1BQU0sZ0JBQStCO2dCQUNuQyxVQUFVLE1BQU07Z0JBQ2hCLFVBQVUsQ0FBQyxRQUFBLEdBQVcsT0FBUyxTQUFTLFdBQVc7WUFDckQ7WUFDQSxNQUFNLFFBQVEsWUFBWSxJQUFJLENBQUEsYUFBYyxXQUFXO1lBQ3ZELFdBQVcsV0FBNEIsT0FBTyxNQUFNO1lBQ3BELE9BQU87Z0JBQ0wsR0FBRyxLQURFO2dCQUVMO1lBQ0Y7UUFDRjtBQUNGO0Esd0I7QUMxRGUsU0FBUixTQUEwQixNQUFBO0lBQy9CLE9BQU8sY0FBYyxXQUFXLFVBQVUsVUFBVSxPQUFRLE9BQW1DLFNBQVM7QUFDMUc7Ozs7O0EsMkM7QSxrRDtBLCtDO0EsbUQ7QSxpRDtBLDZDO0Esa0Q7QSxtRDtBLGlEO0EsNEM7QSwrQztBLDZDO0EsaUQ7QSw2QztBLDhDO0EsNkM7QSx3RDtBLG1EO0EsNkQ7QSxJLFksTztBLEksc0IsTztBLEksZSxPLFU7QSxJLGUsTyxVO0EsSSxrQixDLEssSyxRLE8sTSxVLEssSztRLFk7USxjO1EsVTtRO0ksSyxHLEMsSSxHO0EsSSxpQixDLEc7SSxJLEksUSxLLEMsSSxDLEMsRSxJLGEsSyxHLE8sZ0IsRyxNLEMsQyxLO0ksSSxxQjtRLEssSSxRLG9CLEcsSSxhLEssRyxPLGdCLEcsTSxDLEMsSztJO0ksTztBO0EsbUI7QUVDTyxJQUFNLFVBQXlCLE9BQU8sSUFBSTtBQVUxQyxJQUFNLFlBQTJCLE9BQU8sSUFBSTtBQUU1QyxJQUFNLGNBQTZCLE9BQU8sSUFBSTtBLHNCO0FDakI5QyxJQUFNLFNBRVQ7SUFBQSxrQ0FBQTtJQUVBLFNBQVMsTUFBQTtRQUNSLE9BQU8sQ0FB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LGlEO0EsaUQ7QSw4QztBLGU7QUVOeEI7QUFDQTtBLEksWSxPO0EsSSxhLE87QSxJLG9CLE87QSxJLHNCLE87QSxJLGUsTyxVO0EsSSxlLE8sVTtBLEksa0IsQyxLLEssUSxPLE0sVSxLLEs7USxZO1EsYztRLFU7UTtJLEssRyxDLEksRztBLEksaUIsQyxHO0ksSSxJLFEsSyxDLEksQyxDLEUsSSxhLEssRyxPLGdCLEcsTSxDLEMsSztJLEkscUI7USxLLEksUSxvQixHLEksYSxLLEcsTyxnQixHLE0sQyxDLEs7STtJLE87QTtBLEksZ0IsQyxHLEksVyxHLGtCO0EsSSxZLEMsUTtJLEksUyxDO0ksSSxJLFEsTyxJLGEsSyxRLFMsUSxRLFEsRyxNLEMsSyxHLE0sQyxLO0ksSSxVLFEscUI7USxLLEksUSxvQixRLEksUSxRLFEsSyxhLEssUSxPLE0sQyxLLEcsTSxDLEs7STtJLE87QTtBQ0hPLElBQU0sUUFBQSxrQkFBQTtBQUFBLGFBQUE7QUFHWCxhQUFhLFNBQThCLE1BQUEsQ0FBQSxVQUFBLEdBQWE7QSw0QjtBQ1MxRCxJQUFNLGFBQWEsT0FBTyxJQUFJLENBQUEsbUJBQUEsQ0FBcUI7QUFDbkQsSUFBTSxLQU1KLE9BQU8sZUFBZSxjQUNsQixhQUFBLHdGQUFBLEdBQzJGLENBQUM7QUFHbEcsU0FBUztJQTNCVCxJQUFBO0lBNEJFLElBQUksQ0FBQyxNQUFNLGVBQWUsT0FBTyxDQUFDO0lBRWxDLE1BQU0sYUFBQSxBQUFjLENBQUEsS0FBQSxFQUFBLENBQUEsV0FBQSxBQUFBLEtBQUEsT0FBQSxLQUFBLEVBQUEsQ0FBQSxXQUFBLEdBQW1CLGFBQUEsR0FBQSxJQUFJO0lBSTNDLElBQUksY0FBYyxXQUFXLElBQUksTUFBTTtJQUN2QyxJQUFJLENBQUMsYUFBYTtRQUNoQixjQUFjLE1BQU0sY0FDbEI7UUFHQSxZQUFZLGNBQWM7UUFFNUIsV0FBVyxJQUFJLE1BQU0sZUFBZTtJQUN0QztJQUNBLE9BQU87QUFDVDtBQUVPLElBQU0sb0JBQWtDLGFBQUEsR0FBQTtBLG9DO0FDNUN4QyxJQUFNLGlCQUFpQjtJ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QUFBLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFBRSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQUMsSUFBSSxJQUFFLElBQUksQ0FBQyxpQkFBaUIsSUFBRyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTtZQUFHLEtBQUksQ0FBQSxFQUFFLFlBQVksT0FBTyxJQUFHLEVBQUUsWUFBWSxTQUFPLEtBQUksQ0FBQSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLGVBQWUsRUFBRSxTQUFRLENBQUM7UUFBRTtJQUFDO0lBQUMsYUFBVyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRztJQUFBLENBQUMsQ0FBQztRQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBQyxVQUFTLENBQUMsRUFBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLGVBQWUsS0FBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFBTztJQUFDLE1BQU0sUUFBUSxDQUFDLEVBQUM7UUFBQyxPQUFPLElBQUksQ0FBQyxJQUFJO0lBQUU7SUFBQyxNQUFNLFFBQVEsQ0FBQyxFQUFDLENBQUMsRUFBQztRQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksR0FBRTtJQUFFO0lBQUMsTUFBTSxXQUFXLENBQUMsRUFBQztRQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU87SUFBRTtBQUFDLEdBQUUsSUFBRSxjQUFjO0lBQUUsTUFBSSxPQUFNO1FBQUksSUFBSSxJQUFFLElBQUksQ0FBQyxpQkFBaUIsSUFBRyxJQUFFLE1BQU0sSUFBSSxDQUFDLE9BQU87UUFBRyxPQUFPLElBQUksQ0FBQyxXQUFXO0lBQUUsRUFBRTtJQUFBLE1BQUksT0FBTSxHQUFFO1FBQUssSUFBSSxJQUFFLElBQUksQ0FBQyxpQkFBaUIsSUFBRyxJQUFFLEtBQUssVUFBVTtRQUFHLE9BQU8sSUFBSSxDQUFDLE9BQU8s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QUFRLFFBQVEsYUFBYSxTQUFTLFNBQVMsQ0FBQyxJQUFJLEVBQy9ELE9BQU87WUFHUixNQUFNLFNBQVMsTUFBTSxJQUFJO1lBRXpCLElBQUksUUFDSCxPQUFPO1lBR1IsSUFBSSxPQUFPLGFBQWEsWUFBWTtnQkFDbkMsTUFBTSxTQUFTLGdCQUFnQixVQUFVLFNBQVMsT0FBTztnQkFDekQsTUFBTSxJQUFJLFVBQVU7Z0JBQ3BCLE9BQU87WUFDUjtZQUVBLE9BQU87UUFDUjtJQUNEO0lBRUEsT0FBTztBQUNSOzs7OztrRENyR2E7NkNBdUJUOytDQUNBO29EQUNBO0FBbENKO0FBU08sTUFBTSxlQUE0QjtJQUNyQyxhQUFhO0lBQ2IsTUFBTTtJQUNOLFFBQVEsRUFBRTtBQUNkO0FBRUEsTUFBTSxjQUFjLENBQUEsR0FBQSxvQkFBVSxFQUFFO0lBQzVCLE1BQU07SUFDTjtJQUNBLFVBQVU7UUFDTixTQUFTLENBQUMsT0FBTztZQUNiLE1BQU0sT0FBTyxPQUFPO1FBQ3hCO1FBQ0EsV0FBVyxDQUFDLE9BQU87WUFDZixNQUFNLFNBQVMsT0FBTztRQUMxQjtRQUNBLGdCQUFnQixDQUFDLE9BQU87WUFDcEIsTUFBTSxjQUFjLE9BQU87UUFDL0I7SUFDSjtBQUNKO0FBRU8sTUFBTSxFQUNULE9BQU8sRUFDUCxTQUFTLEVBQ1QsY0FBYyxFQUNqQixHQUFHLFlBQVk7a0JBRUQsWUFBWSIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzLy5wbnBtL0BwbGFzbW9ocStwYXJjZWwtcnVudGltZUAwLjIzLjEvbm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9wYXJjZWwtcnVudGltZS9kaXN0L3J1bnRpbWUtYzNlYmIwYmUwZDk0ZWZhMi5qcyIsIi5wbGFzbW8vc3RhdGljL2JhY2tncm91bmQvaW5kZXgudHMiLCIucGxhc21vL3N0YXRpYy9iYWNrZ3JvdW5kL21lc3NhZ2luZy50cyIsInNyYy9iYWNrZ3JvdW5kL21lc3NhZ2VzL2JhY2tncm91bmQtY3Jvcy1ub3Rpb24taW1hZ2UudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBhcmNlbCt0cmFuc2Zvcm1lci1qc0AyLjkuM19AcGFyY2VsK2NvcmVAMi45LjMvbm9kZV9tb2R1bGVzL0BwYXJjZWwvdHJhbnNmb3JtZXItanMvc3JjL2VzbW9kdWxlLWhlbHBlcnMuanMiLCJzcmMvYmFja2dyb3VuZC9tZXNzYWdlcy9iYWNrZ3JvdW5kLWdldC1zcGFjZXMudHMiLCJzcmMvZmV0Y2gvZmV0Y2gudHMiLCJzcmMvYmFja2dyb3VuZC9tZXNzYWdlcy9iYWNrZ3JvdW5kLW5vdGlvbi1zZWFyY2gudHMiLCJzcmMvYmFja2dyb3VuZC9pbmRleC50cyIsInNyYy9zdG9yZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubGVnYWN5LWVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvaW5kZXgudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2NyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9jb25maWd1cmVTdG9yZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvZGV2dG9vbHNFeHRlbnNpb24udHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9jcmVhdGVBY3Rpb24udHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL3RzSGVscGVycy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvYWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL3V0aWxzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL3NlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvYXV0b0JhdGNoRW5oYW5jZXIudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2NyZWF0ZVJlZHVjZXIudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL21hcEJ1aWxkZXJzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9uYW5vaWQudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL21hdGNoZXJzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9jcmVhdGVBc3luY1RodW5rLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9jcmVhdGVTbGljZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL3V0aWxzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcmVkdXhqcyt0b29sa2l0QDIuMi4zX3JlYWN0LXJlZHV4QDkuMS4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9zcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3Rhc2sudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQHJlZHV4anMrdG9vbGtpdEAyLjIuM19yZWFjdC1yZWR1eEA5LjEuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9jb21iaW5lU2xpY2VzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0ByZWR1eGpzK3Rvb2xraXRAMi4yLjNfcmVhY3QtcmVkdXhAOS4xLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L3NyYy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BwbGFzbW9ocStwYXJjZWwtcmVzb2x2ZXJAMC4xNC4wL25vZGVfbW9kdWxlcy9AcGxhc21vaHEvcGFyY2VsLXJlc29sdmVyL2Rpc3QvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlZHV4L2Rpc3QvcmVkdXgubGVnYWN5LWVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy91dGlscy9zeW1ib2wtb2JzZXJ2YWJsZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL2FjdGlvblR5cGVzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWR1eC9zcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL2tpbmRPZi50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL2NyZWF0ZVN0b3JlLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWR1eC9zcmMvdXRpbHMvd2FybmluZy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL2NvbWJpbmVSZWR1Y2Vycy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL2JpbmRBY3Rpb25DcmVhdG9ycy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL2NvbXBvc2UudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy9hcHBseU1pZGRsZXdhcmUudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy91dGlscy9pc0FjdGlvbi50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbW1lckAxMC4wLjQvbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIubGVnYWN5LWVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbW1lckAxMC4wLjQvbm9kZV9tb2R1bGVzL2ltbWVyL3NyYy91dGlscy9lbnYudHMiLCJub2RlX21vZHVsZXMvLnBucG0vaW1tZXJAMTAuMC40L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvdXRpbHMvZXJyb3JzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDEwLjAuNC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL3V0aWxzL2NvbW1vbi50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbW1lckAxMC4wLjQvbm9kZV9tb2R1bGVzL2ltbWVyL3NyYy91dGlscy9wbHVnaW5zLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDEwLjAuNC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL2NvcmUvc2NvcGUudHMiLCJub2RlX21vZHVsZXMvLnBucG0vaW1tZXJAMTAuMC40L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvY29yZS9maW5hbGl6ZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbW1lckAxMC4wLjQvbm9kZV9tb2R1bGVzL2ltbWVyL3NyYy9jb3JlL3Byb3h5LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDEwLjAuNC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL2NvcmUvaW1tZXJDbGFzcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbW1lckAxMC4wLjQvbm9kZV9tb2R1bGVzL2ltbWVyL3NyYy9jb3JlL2N1cnJlbnQudHMiLCJub2RlX21vZHVsZXMvLnBucG0vaW1tZXJAMTAuMC40L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvcGx1Z2lucy9wYXRjaGVzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDEwLjAuNC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL3BsdWdpbnMvbWFwc2V0LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDEwLjAuNC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL2ltbWVyLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3Jlc2VsZWN0QDUuMS4wL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9kaXN0L3Jlc2VsZWN0LmxlZ2FjeS1lc20uanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVzZWxlY3RANS4xLjAvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9kZXZNb2RlQ2hlY2tzL2lkZW50aXR5RnVuY3Rpb25DaGVjay50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZXNlbGVjdEA1LjEuMC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL2Rldk1vZGVDaGVja3MvaW5wdXRTdGFiaWxpdHlDaGVjay50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZXNlbGVjdEA1LjEuMC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL2Rldk1vZGVDaGVja3Mvc2V0R2xvYmFsRGV2TW9kZUNoZWNrcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZXNlbGVjdEA1LjEuMC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL3V0aWxzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3Jlc2VsZWN0QDUuMS4wL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvYXV0b3RyYWNrTWVtb2l6ZS9hdXRvdHJhY2tpbmcudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVzZWxlY3RANS4xLjAvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9hdXRvdHJhY2tNZW1vaXplL3RyYWNraW5nLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3Jlc2VsZWN0QDUuMS4wL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvYXV0b3RyYWNrTWVtb2l6ZS9wcm94eS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZXNlbGVjdEA1LjEuMC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL2xydU1lbW9pemUudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVzZWxlY3RANS4xLjAvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja01lbW9pemUudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVzZWxlY3RANS4xLjAvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy93ZWFrTWFwTWVtb2l6ZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZXNlbGVjdEA1LjEuMC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvci50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZXNlbGVjdEA1LjEuMC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWR1eC10aHVua0AzLjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZGlzdC9yZWR1eC10aHVuay5sZWdhY3ktZXNtLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5sZWdhY3ktZXNtLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL3JlYWN0LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2NvbXBvbmVudHMvQ29udGV4dC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvaG9va3MvdXNlU2VsZWN0b3IudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvcmVhY3QtaXMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvd2FybmluZy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29ubmVjdC9tZXJnZVByb3BzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL2JhdGNoLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlZHV4QDkuMS4wX0B0eXBlcytyZWFjdEAxOC4yLjQ4X3JlYWN0QDE4LjIuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL3NoYWxsb3dFcXVhbC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy9ob2lzdFN0YXRpY3MudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVkdXhAOS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDhfcmVhY3RAMTguMi4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9ob29rcy91c2VTdG9yZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9ob29rcy91c2VEaXNwYXRjaC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWR1eEA5LjEuMF9AdHlwZXMrcmVhY3RAMTguMi40OF9yZWFjdEAxOC4yLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9leHBvcnRzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmVAMS4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlQDEuMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZUAxLjAuMi9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlZHV4LXBlcnNpc3Qtd2ViZXh0ZW5zaW9uLXN0b3JhZ2VAMS4wLjIvbm9kZV9tb2R1bGVzL3JlZHV4LXBlcnNpc3Qtd2ViZXh0ZW5zaW9uLXN0b3JhZ2UvZGlzdC9sb2NhbFN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZUAxLjAuMi9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZS9kaXN0L2NyZWF0ZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZUAxLjAuMi9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZS9kaXN0L3N5bmNTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BwbGFzbW9ocStyZWR1eC1wZXJzaXN0QDYuMS4wX3JlZHV4QDUuMC4xL25vZGVfbW9kdWxlcy9AcGxhc21vaHEvcmVkdXgtcGVyc2lzdC9lcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcmVkdXgtcGVyc2lzdEA2LjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QvZXMvcGVyc2lzdFJlZHVjZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3JlZHV4LXBlcnNpc3RANi4xLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9yZWR1eC1wZXJzaXN0L2VzL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcmVkdXgtcGVyc2lzdEA2LjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QvZXMvc3RhdGVSZWNvbmNpbGVyL2F1dG9NZXJnZUxldmVsMS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcmVkdXgtcGVyc2lzdEA2LjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QvZXMvY3JlYXRlUGVyc2lzdG9pZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcmVkdXgtcGVyc2lzdEA2LjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QvZXMvZ2V0U3RvcmVkU3RhdGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3JlZHV4LXBlcnNpc3RANi4xLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9yZWR1eC1wZXJzaXN0L2VzL3B1cmdlU3RvcmVkU3RhdGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3JlZHV4LXBlcnNpc3RANi4xLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9yZWR1eC1wZXJzaXN0L2VzL3BlcnNpc3RDb21iaW5lUmVkdWNlcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3JlZHV4LXBlcnNpc3RANi4xLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9yZWR1eC1wZXJzaXN0L2VzL3N0YXRlUmVjb25jaWxlci9hdXRvTWVyZ2VMZXZlbDIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3JlZHV4LXBlcnNpc3RANi4xLjBfcmVkdXhANS4wLjEvbm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9yZWR1eC1wZXJzaXN0L2VzL3BlcnNpc3RTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcmVkdXgtcGVyc2lzdEA2LjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QvZXMvY3JlYXRlTWlncmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcmVkdXgtcGVyc2lzdEA2LjEuMF9yZWR1eEA1LjAuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QvZXMvY3JlYXRlVHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BwbGFzbW9ocStzdG9yYWdlQDEuOS4zX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3N0b3JhZ2UvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9waWZ5QDYuMS4wL25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwic3JjL25vdGlvbi9ub3Rpb24tc2xpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHU9dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuYXJndjpbXTt2YXIgaD0oKT0+dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuZW52Ont9O3ZhciBCPW5ldyBTZXQodSksXz1lPT5CLmhhcyhlKSxHPXUuZmlsdGVyKGU9PmUuc3RhcnRzV2l0aChcIi0tXCIpJiZlLmluY2x1ZGVzKFwiPVwiKSkubWFwKGU9PmUuc3BsaXQoXCI9XCIpKS5yZWR1Y2UoKGUsW3Qsb10pPT4oZVt0XT1vLGUpLHt9KTt2YXIgVT1fKFwiLS1kcnktcnVuXCIpLGc9KCk9Pl8oXCItLXZlcmJvc2VcIil8fGgoKS5WRVJCT1NFPT09XCJ0cnVlXCIsTj1nKCk7dmFyIG09KGU9XCJcIiwuLi50KT0+Y29uc29sZS5sb2coZS5wYWRFbmQoOSksXCJ8XCIsLi4udCk7dmFyIHk9KC4uLmUpPT5jb25zb2xlLmVycm9yKFwiXFx1ezFGNTM0fSBFUlJPUlwiLnBhZEVuZCg5KSxcInxcIiwuLi5lKSxiPSguLi5lKT0+bShcIlxcdXsxRjUzNX0gSU5GT1wiLC4uLmUpLGY9KC4uLmUpPT5tKFwiXFx1ezFGN0UwfSBXQVJOXCIsLi4uZSksTT0wLGk9KC4uLmUpPT5nKCkmJm0oYFxcdXsxRjdFMX0gJHtNKyt9YCwuLi5lKTt2YXIgdj0oKT0+e2xldCBlPWdsb2JhbFRoaXMuYnJvd3Nlcj8ucnVudGltZXx8Z2xvYmFsVGhpcy5jaHJvbWU/LnJ1bnRpbWUsdD0oKT0+c2V0SW50ZXJ2YWwoZS5nZXRQbGF0Zm9ybUluZm8sMjRlMyk7ZS5vblN0YXJ0dXAuYWRkTGlzdGVuZXIodCksdCgpfTt2YXIgbj17XCJpc0NvbnRlbnRTY3JpcHRcIjpmYWxzZSxcImlzQmFja2dyb3VuZFwiOnRydWUsXCJpc1JlYWN0XCI6ZmFsc2UsXCJydW50aW1lc1wiOltcImJhY2tncm91bmQtc2VydmljZS1ydW50aW1lXCJdLFwiaG9zdFwiOlwibG9jYWxob3N0XCIsXCJwb3J0XCI6MTgxNSxcImVudHJ5RmlsZVBhdGhcIjpcIi9Vc2Vycy9zaGFuZ3NoeS9EZXZlbG9wZXIvY29kZS9jaHJvbWUgZXh0ZW5zaW9uL0F0TXlOb3Rpb24tQ2hyb21lRXh0ZW5zaW9uLy5wbGFzbW8vc3RhdGljL2JhY2tncm91bmQvaW5kZXgudHNcIixcImJ1bmRsZUlkXCI6XCJjMzM4OTA4ZTcwNGM5MWYxXCIsXCJlbnZIYXNoXCI6XCJkOTlhNWZmYTU3YWNkNjM4XCIsXCJ2ZXJib3NlXCI6XCJmYWxzZVwiLFwic2VjdXJlXCI6ZmFsc2UsXCJzZXJ2ZXJQb3J0XCI6NTU3MDR9O21vZHVsZS5idW5kbGUuSE1SX0JVTkRMRV9JRD1uLmJ1bmRsZUlkO2dsb2JhbFRoaXMucHJvY2Vzcz17YXJndjpbXSxlbnY6e1ZFUkJPU0U6bi52ZXJib3NlfX07dmFyIEQ9bW9kdWxlLmJ1bmRsZS5Nb2R1bGU7ZnVuY3Rpb24gSChlKXtELmNhbGwodGhpcyxlKSx0aGlzLmhvdD17ZGF0YTptb2R1bGUuYnVuZGxlLmhvdERhdGFbZV0sX2FjY2VwdENhbGxiYWNrczpbXSxfZGlzcG9zZUNhbGxiYWNrczpbXSxhY2NlcHQ6ZnVuY3Rpb24odCl7dGhpcy5fYWNjZXB0Q2FsbGJhY2tzLnB1c2godHx8ZnVuY3Rpb24oKXt9KX0sZGlzcG9zZTpmdW5jdGlvbih0KXt0aGlzLl9kaXNwb3NlQ2FsbGJhY2tzLnB1c2godCl9fSxtb2R1bGUuYnVuZGxlLmhvdERhdGFbZV09dm9pZCAwfW1vZHVsZS5idW5kbGUuTW9kdWxlPUg7bW9kdWxlLmJ1bmRsZS5ob3REYXRhPXt9O3ZhciBjPWdsb2JhbFRoaXMuYnJvd3Nlcnx8Z2xvYmFsVGhpcy5jaHJvbWV8fG51bGw7ZnVuY3Rpb24gUigpe3JldHVybiFuLmhvc3R8fG4uaG9zdD09PVwiMC4wLjAuMFwiP2xvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwXCIpPT09MD9sb2NhdGlvbi5ob3N0bmFtZTpcImxvY2FsaG9zdFwiOm4uaG9zdH1mdW5jdGlvbiB4KCl7cmV0dXJuIW4uaG9zdHx8bi5ob3N0PT09XCIwLjAuMC4wXCI/XCJsb2NhbGhvc3RcIjpuLmhvc3R9ZnVuY3Rpb24gZCgpe3JldHVybiBuLnBvcnR8fGxvY2F0aW9uLnBvcnR9dmFyIFA9XCJfX3BsYXNtb19ydW50aW1lX3BhZ2VfXCIsUz1cIl9fcGxhc21vX3J1bnRpbWVfc2NyaXB0X1wiO3ZhciBPPWAke24uc2VjdXJlP1wiaHR0cHNcIjpcImh0dHBcIn06Ly8ke1IoKX06JHtkKCl9L2A7YXN5bmMgZnVuY3Rpb24gayhlPTE0NzApe2Zvcig7Oyl0cnl7YXdhaXQgZmV0Y2goTyk7YnJlYWt9Y2F0Y2h7YXdhaXQgbmV3IFByb21pc2Uobz0+c2V0VGltZW91dChvLGUpKX19aWYoYy5ydW50aW1lLmdldE1hbmlmZXN0KCkubWFuaWZlc3RfdmVyc2lvbj09PTMpe2xldCBlPWMucnVudGltZS5nZXRVUkwoXCIvX19wbGFzbW9faG1yX3Byb3h5X18/dXJsPVwiKTtnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJmZXRjaFwiLGZ1bmN0aW9uKHQpe2xldCBvPXQucmVxdWVzdC51cmw7aWYoby5zdGFydHNXaXRoKGUpKXtsZXQgcz1uZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudChvLnNsaWNlKGUubGVuZ3RoKSkpO3MuaG9zdG5hbWU9PT1uLmhvc3QmJnMucG9ydD09PWAke24ucG9ydH1gPyhzLnNlYXJjaFBhcmFtcy5zZXQoXCJ0XCIsRGF0ZS5ub3coKS50b1N0cmluZygpKSx0LnJlc3BvbmRXaXRoKGZldGNoKHMpLnRoZW4ocj0+bmV3IFJlc3BvbnNlKHIuYm9keSx7aGVhZGVyczp7XCJDb250ZW50LVR5cGVcIjpyLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPz9cInRleHQvamF2YXNjcmlwdFwifX0pKSkpOnQucmVzcG9uZFdpdGgobmV3IFJlc3BvbnNlKFwiUGxhc21vIEhNUlwiLHtzdGF0dXM6MjAwLHN0YXR1c1RleHQ6XCJUZXN0aW5nXCJ9KSl9fSl9ZnVuY3Rpb24gRShlLHQpe2xldHttb2R1bGVzOm99PWU7cmV0dXJuIG8/ISFvW3RdOiExfWZ1bmN0aW9uIEMoZT1kKCkpe2xldCB0PXgoKTtyZXR1cm5gJHtuLnNlY3VyZXx8bG9jYXRpb24ucHJvdG9jb2w9PT1cImh0dHBzOlwiJiYhL2xvY2FsaG9zdHwxMjcuMC4wLjF8MC4wLjAuMC8udGVzdCh0KT9cIndzc1wiOlwid3NcIn06Ly8ke3R9OiR7ZX0vYH1mdW5jdGlvbiBUKGUpe3R5cGVvZiBlLm1lc3NhZ2U9PVwic3RyaW5nXCImJnkoXCJbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogXCIrZS5tZXNzYWdlKX1mdW5jdGlvbiBMKGUpe2lmKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldD5cInVcIilyZXR1cm47bGV0IHQ9bmV3IFdlYlNvY2tldChDKE51bWJlcihkKCkpKzEpKTtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGFzeW5jIGZ1bmN0aW9uKG8pe2xldCBzPUpTT04ucGFyc2Uoby5kYXRhKTthd2FpdCBlKHMpfSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixUKSx0fWZ1bmN0aW9uIEEoZSl7aWYodHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0PlwidVwiKXJldHVybjtsZXQgdD1uZXcgV2ViU29ja2V0KEMoKSk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixhc3luYyBmdW5jdGlvbihvKXtsZXQgcz1KU09OLnBhcnNlKG8uZGF0YSk7aWYocy50eXBlPT09XCJ1cGRhdGVcIiYmYXdhaXQgZShzLmFzc2V0cykscy50eXBlPT09XCJlcnJvclwiKWZvcihsZXQgciBvZiBzLmRpYWdub3N0aWNzLmFuc2kpe2xldCBsPXIuY29kZWZyYW1lfHxyLnN0YWNrO2YoXCJbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogXCIrci5tZXNzYWdlK2BcbmArbCtgXG5cbmArci5oaW50cy5qb2luKGBcbmApKX19KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLFQpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwoKT0+e2IoYFtwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBDb25uZWN0ZWQgdG8gSE1SIHNlcnZlciBmb3IgJHtuLmVudHJ5RmlsZVBhdGh9YCl9KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCgpPT57ZihgW3BsYXNtby9wYXJjZWwtcnVudGltZV06IENvbm5lY3Rpb24gdG8gdGhlIEhNUiBzZXJ2ZXIgaXMgY2xvc2VkIGZvciAke24uZW50cnlGaWxlUGF0aH1gKX0pLHR9dmFyIHc9bW9kdWxlLmJ1bmRsZS5wYXJlbnQsYT17YnVpbGRSZWFkeTohMSxiZ0NoYW5nZWQ6ITEsY3NDaGFuZ2VkOiExLHBhZ2VDaGFuZ2VkOiExLHNjcmlwdFBvcnRzOm5ldyBTZXQscGFnZVBvcnRzOm5ldyBTZXR9O2FzeW5jIGZ1bmN0aW9uIHAoZT0hMSl7aWYoZXx8YS5idWlsZFJlYWR5JiZhLnBhZ2VDaGFuZ2VkKXtpKFwiQkdTVyBSdW50aW1lIC0gcmVsb2FkaW5nIFBhZ2VcIik7Zm9yKGxldCB0IG9mIGEucGFnZVBvcnRzKXQucG9zdE1lc3NhZ2UobnVsbCl9aWYoZXx8YS5idWlsZFJlYWR5JiYoYS5iZ0NoYW5nZWR8fGEuY3NDaGFuZ2VkKSl7aShcIkJHU1cgUnVudGltZSAtIHJlbG9hZGluZyBDU1wiKTtsZXQgdD1hd2FpdCBjPy50YWJzLnF1ZXJ5KHthY3RpdmU6ITB9KTtmb3IobGV0IG8gb2YgYS5zY3JpcHRQb3J0cyl7bGV0IHM9dC5zb21lKHI9PnIuaWQ9PT1vLnNlbmRlci50YWI/LmlkKTtvLnBvc3RNZXNzYWdlKHtfX3BsYXNtb19jc19hY3RpdmVfdGFiX186c30pfWMucnVudGltZS5yZWxvYWQoKX19aWYoIXd8fCF3LmlzUGFyY2VsUmVxdWlyZSl7digpO2xldCBlPUEoYXN5bmMgdD0+e2koXCJCR1NXIFJ1bnRpbWUgLSBPbiBITVIgVXBkYXRlXCIpLGEuYmdDaGFuZ2VkfHw9dC5maWx0ZXIocz0+cy5lbnZIYXNoPT09bi5lbnZIYXNoKS5zb21lKHM9PkUobW9kdWxlLmJ1bmRsZSxzLmlkKSk7bGV0IG89dC5maW5kKHM9PnMudHlwZT09PVwianNvblwiKTtpZihvKXtsZXQgcz1uZXcgU2V0KHQubWFwKGw9PmwuaWQpKSxyPU9iamVjdC52YWx1ZXMoby5kZXBzQnlCdW5kbGUpLm1hcChsPT5PYmplY3QudmFsdWVzKGwpKS5mbGF0KCk7YS5iZ0NoYW5nZWR8fD1yLmV2ZXJ5KGw9PnMuaGFzKGwpKX1wKCl9KTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsKCk9PntsZXQgdD1zZXRJbnRlcnZhbCgoKT0+ZS5zZW5kKFwicGluZ1wiKSwyNGUzKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCgpPT5jbGVhckludGVydmFsKHQpKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsYXN5bmMoKT0+e2F3YWl0IGsoKSxwKCEwKX0pfUwoYXN5bmMgZT0+e3N3aXRjaChpKFwiQkdTVyBSdW50aW1lIC0gT24gQnVpbGQgUmVwYWNrYWdlZFwiKSxlLnR5cGUpe2Nhc2VcImJ1aWxkX3JlYWR5XCI6e2EuYnVpbGRSZWFkeXx8PSEwLHAoKTticmVha31jYXNlXCJjc19jaGFuZ2VkXCI6e2EuY3NDaGFuZ2VkfHw9ITAscCgpO2JyZWFrfX19KTtjLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKGZ1bmN0aW9uKGUpe2xldCB0PWUubmFtZS5zdGFydHNXaXRoKFApLG89ZS5uYW1lLnN0YXJ0c1dpdGgoUyk7aWYodHx8byl7bGV0IHM9dD9hLnBhZ2VQb3J0czphLnNjcmlwdFBvcnRzO3MuYWRkKGUpLGUub25EaXNjb25uZWN0LmFkZExpc3RlbmVyKCgpPT57cy5kZWxldGUoZSl9KSxlLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmdW5jdGlvbihyKXtpKFwiQkdTVyBSdW50aW1lIC0gT24gc291cmNlIGNoYW5nZWRcIixyKSxyLl9fcGxhc21vX2NzX2NoYW5nZWRfXyYmKGEuY3NDaGFuZ2VkfHw9ITApLHIuX19wbGFzbW9fcGFnZV9jaGFuZ2VkX18mJihhLnBhZ2VDaGFuZ2VkfHw9ITApLHAoKX0pfX0pO2MucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wbGFzbW9fZnVsbF9yZWxvYWRfXyYmKGkoXCJCR1NXIFJ1bnRpbWUgLSBPbiB0b3AtbGV2ZWwgY29kZSBjaGFuZ2VkXCIpLHAoKSksITB9KTtcbiIsImltcG9ydCBcIi4vbWVzc2FnaW5nXCJcbmltcG9ydCBcIi4uLy4uLy4uL3NyYy9iYWNrZ3JvdW5kL2luZGV4XCIiLCIvLyBAdHMtbm9jaGVja1xuZ2xvYmFsVGhpcy5fX3BsYXNtb0ludGVybmFsUG9ydE1hcCA9IG5ldyBNYXAoKVxuXG5pbXBvcnQgeyBkZWZhdWx0IGFzIG1lc3NhZ2VzQmFja2dyb3VuZENyb3NOb3Rpb25JbWFnZSB9IGZyb20gXCJ+YmFja2dyb3VuZC9tZXNzYWdlcy9iYWNrZ3JvdW5kLWNyb3Mtbm90aW9uLWltYWdlXCJcbmltcG9ydCB7IGRlZmF1bHQgYXMgbWVzc2FnZXNCYWNrZ3JvdW5kR2V0U3BhY2VzIH0gZnJvbSBcIn5iYWNrZ3JvdW5kL21lc3NhZ2VzL2JhY2tncm91bmQtZ2V0LXNwYWNlc1wiXG5pbXBvcnQgeyBkZWZhdWx0IGFzIG1lc3NhZ2VzQmFja2dyb3VuZE5vdGlvblNlYXJjaCB9IGZyb20gXCJ+YmFja2dyb3VuZC9tZXNzYWdlcy9iYWNrZ3JvdW5kLW5vdGlvbi1zZWFyY2hcIlxuXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2VFeHRlcm5hbC5hZGRMaXN0ZW5lcigocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpID0+IHtcbiAgc3dpdGNoIChyZXF1ZXN0Lm5hbWUpIHtcbiAgICBjYXNlIFwiYmFja2dyb3VuZC1jcm9zLW5vdGlvbi1pbWFnZVwiOlxuICBtZXNzYWdlc0JhY2tncm91bmRDcm9zTm90aW9uSW1hZ2Uoe1xuICAgIHNlbmRlcixcbiAgICAuLi5yZXF1ZXN0XG4gIH0sIHtcbiAgICBzZW5kOiAocCkgPT4gc2VuZFJlc3BvbnNlKHApXG4gIH0pXG4gIGJyZWFrXG5jYXNlIFwiYmFja2dyb3VuZC1nZXQtc3BhY2VzXCI6XG4gIG1lc3NhZ2VzQmFja2dyb3VuZEdldFNwYWNlcyh7XG4gICAgc2VuZGVyLFxuICAgIC4uLnJlcXVlc3RcbiAgfSwge1xuICAgIHNlbmQ6IChwKSA9PiBzZW5kUmVzcG9uc2UocClcbiAgfSlcbiAgYnJlYWtcbmNhc2UgXCJiYWNrZ3JvdW5kLW5vdGlvbi1zZWFyY2hcIjpcbiAgbWVzc2FnZXNCYWNrZ3JvdW5kTm90aW9uU2VhcmNoKHtcbiAgICBzZW5kZXIsXG4gICAgLi4ucmVxdWVzdFxuICB9LCB7XG4gICAgc2VuZDogKHApID0+IHNlbmRSZXNwb25zZShwKVxuICB9KVxuICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIHRydWVcbn0pXG5cbmNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpID0+IHtcbiAgc3dpdGNoIChyZXF1ZXN0Lm5hbWUpIHtcbiAgICBjYXNlIFwiYmFja2dyb3VuZC1jcm9zLW5vdGlvbi1pbWFnZVwiOlxuICBtZXNzYWdlc0JhY2tncm91bmRDcm9zTm90aW9uSW1hZ2Uoe1xuICAgIHNlbmRlcixcbiAgICAuLi5yZXF1ZXN0XG4gIH0sIHtcbiAgICBzZW5kOiAocCkgPT4gc2VuZFJlc3BvbnNlKHApXG4gIH0pXG4gIGJyZWFrXG5jYXNlIFwiYmFja2dyb3VuZC1nZXQtc3BhY2VzXCI6XG4gIG1lc3NhZ2VzQmFja2dyb3VuZEdldFNwYWNlcyh7XG4gICAgc2VuZGVyLFxuICAgIC4uLnJlcXVlc3RcbiAgfSwge1xuICAgIHNlbmQ6IChwKSA9PiBzZW5kUmVzcG9uc2UocClcbiAgfSlcbiAgYnJlYWtcbmNhc2UgXCJiYWNrZ3JvdW5kLW5vdGlvbi1zZWFyY2hcIjpcbiAgbWVzc2FnZXNCYWNrZ3JvdW5kTm90aW9uU2VhcmNoKHtcbiAgICBzZW5kZXIsXG4gICAgLi4ucmVxdWVzdFxuICB9LCB7XG4gICAgc2VuZDogKHApID0+IHNlbmRSZXNwb25zZShwKVxuICB9KVxuICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIHRydWVcbn0pXG5cbmNocm9tZS5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcihmdW5jdGlvbihwb3J0KSB7XG4gIGdsb2JhbFRoaXMuX19wbGFzbW9JbnRlcm5hbFBvcnRNYXAuc2V0KHBvcnQubmFtZSwgcG9ydClcbiAgcG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHN3aXRjaCAocG9ydC5uYW1lKSB7XG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9KVxufSlcblxuIiwiaW1wb3J0IHR5cGUgeyBQbGFzbW9NZXNzYWdpbmcgfSBmcm9tIFwiQHBsYXNtb2hxL21lc3NhZ2luZ1wiO1xuXG5jb25zdCBoYW5kbGVyOiBQbGFzbW9NZXNzYWdpbmcuTWVzc2FnZUhhbmRsZXIgPSBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpLmdldFRpbWUoKSxcImJhY2tncm91bmQg5byA5aeL6K+35rGCIE5vdGlvblNlYXJjaE1lbnUgTm90aW9uIOWbvueJh1wiLHJlcS5ib2R5LnBhZ2VfaWNvbilcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcS5ib2R5LnBhZ2VfaWNvbiwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cblxuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7IC8vIOWwhuWTjeW6lOS9k+i9rOaNouS4umJsb2JcbiAgICBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpLmdldFRpbWUoKSxcImJhY2tncm91bmQg6K+35rGC5YiwIE5vdGlvblNlYXJjaE1lbnUg5Zu+54mHXCIsIGJsb2IpXG5cbiAgICAvLyDlsIblm77niYfkvZzkuLpCbG9i5Y+R6YCB5Zue5YmN56uvXG4gICAgcmVzLnNlbmQoe1xuICAgICAgICBibG9iOiBibG9iLFxuICAgIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyXG4iLCJleHBvcnRzLmludGVyb3BEZWZhdWx0ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5fX2VzTW9kdWxlID8gYSA6IHtkZWZhdWx0OiBhfTtcbn07XG5cbmV4cG9ydHMuZGVmaW5lSW50ZXJvcEZsYWcgPSBmdW5jdGlvbiAoYSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTtcbn07XG5cbmV4cG9ydHMuZXhwb3J0QWxsID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdCkge1xuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdkZWZhdWx0JyB8fCBrZXkgPT09ICdfX2VzTW9kdWxlJyB8fCBkZXN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZXhwb3J0cy5leHBvcnQgPSBmdW5jdGlvbiAoZGVzdCwgZGVzdE5hbWUsIGdldCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgZGVzdE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZ2V0LFxuICB9KTtcbn07XG4iLCJpbXBvcnQgdHlwZSB7UGxhc21vTWVzc2FnaW5nfSBmcm9tIFwiQHBsYXNtb2hxL21lc3NhZ2luZ1wiXG5pbXBvcnQgZmV0Y2hDbGllbnQgZnJvbSBcIn5mZXRjaC9mZXRjaFwiO1xuaW1wb3J0IHtTdG9yYWdlfSBmcm9tIFwiQHBsYXNtb2hxL3N0b3JhZ2VcIjtcbmltcG9ydCB7U3BhY2VJbmZvLCBVc2VySW5mb30gZnJvbSBcIn5ub3Rpb24vbm90aW9uLW1vZGVsXCI7XG5pbXBvcnQge3NldFNwYWNlcywgc2V0VXNlcn0gZnJvbSBcIn5ub3Rpb24vbm90aW9uLXNsaWNlXCI7XG5cbmNvbnN0IGhhbmRsZXI6IFBsYXNtb01lc3NhZ2luZy5NZXNzYWdlSGFuZGxlciA9IGFzeW5jIChyZXEsIHJlcykgPT4ge1xuXG4gICAgLy8g6K+35rGCIGdldFNwYWNlc1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDbGllbnQoe1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly93d3cubm90aW9uLnNvL2FwaS92My9nZXRTcGFjZXNcIiwgbWV0aG9kOiBcIlBPU1RcIlxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3BhY2VzUmVzcG9uc2UgPSBPYmplY3QudmFsdWVzKHJlc3BvbnNlKVswXTtcbiAgICBjb25zdCBzcGFjZUlkTGlzdCA9IE9iamVjdC5rZXlzKHNwYWNlc1Jlc3BvbnNlLnNwYWNlKTtcblxuICAgIC8vIOivt+axgiBnZXRQdWJsaWNTcGFjZURhdGFcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgdHlwZTogXCJzcGFjZS1pZHNcIixcbiAgICAgICAgc3BhY2VJZHM6IHNwYWNlSWRMaXN0XG4gICAgfTtcbiAgICBjb25zdCBzcGFjZURhdGFSZXNwb25zZSA9IGF3YWl0IGZldGNoQ2xpZW50KHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vd3d3Lm5vdGlvbi5zby9hcGkvdjMvZ2V0UHVibGljU3BhY2VEYXRhXCIsIG1ldGhvZDogXCJQT1NUXCIsIGJvZHk6IHJlcXVlc3RCb2R5XG4gICAgfSk7XG5cblxuICAgIC8vIOWTjeW6lFxuICAgIHJlcy5zZW5kKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHNwYWNlRGF0YVJlc3BvbnNlXG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlclxuIiwiLy8gZmV0Y2guanNcbmludGVyZmFjZSBGZXRjaENvbmZpZyB7XG4gIHVybDogc3RyaW5nXG4gIG1ldGhvZD86IFwiR0VUXCIgfCBcIlBPU1RcIiB8IFwiUFVUXCIgfCBcIkRFTEVURVwiXG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIGJvZHk/OiBhbnlcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDbGllbnQoZmV0Y2hDb25maWc6IEZldGNoQ29uZmlnKSB7XG4gIGNvbnN0IHsgdXJsLCBtZXRob2QgPSBcIlBPU1RcIiwgaGVhZGVycyA9IHt9LCBib2R5ID0gbnVsbCB9ID0gZmV0Y2hDb25maWdcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgYm9keTogYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogbnVsbFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICB9XG5cbiAgICAvLyDmoLnmja7pnIDopoHlpITnkIblkozov5Tlm57lk43lupTvvIzkvovlpoIgSlNPTiDmiJblhbbku5bmoLzlvI9cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1ha2luZyBhIGZldGNoOlwiLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZldGNoQ2xpZW50XG4iLCJpbXBvcnQgdHlwZSB7UGxhc21vTWVzc2FnaW5nfSBmcm9tIFwiQHBsYXNtb2hxL21lc3NhZ2luZ1wiXG5pbXBvcnQgZmV0Y2hDbGllbnQgZnJvbSBcIn5mZXRjaC9mZXRjaFwiO1xuXG5jb25zb2xlLmxvZyhcImJhY2tncm91bmQtbm90aW9uLXNlYXJjaFwiKVxuXG5jb25zdCBoYW5kbGVyOiBQbGFzbW9NZXNzYWdpbmcuTWVzc2FnZUhhbmRsZXIgPSBhc3luYyAocmVxLCByZXMpID0+IHtcblxuICAgIGNvbnN0IHt1c2VyLCB1c2VyUHJlZmVyZW5jZXMsIHF1ZXJ5fSA9IHJlcS5ib2R5XG5cbiAgICBpZiAoIXVzZXIgfHwgIXVzZXJQcmVmZXJlbmNlcyB8fCAhcXVlcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXJzOiB1c2VyLCB1c2VyUHJlZmVyZW5jZXMsIG9yIHF1ZXJ5XCIpO1xuICAgIH1cblxuICAgIC8vIOiOt+WPluacgOi/kemhtemdouiuv+mXruaVsOaNrlxuICAgIGNvbnN0IHJlY2VudFBhZ2VzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaENsaWVudCh7XG4gICAgICAgIHVybDogXCJodHRwczovL3d3dy5ub3Rpb24uc28vYXBpL3YzL2dldFJlY2VudFBhZ2VWaXNpdHNcIixcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBcIlgtTm90aW9uLUFjdGl2ZS1Vc2VyLUhlYWRlclwiOiB1c2VyLmlkLFxuICAgICAgICAgICAgXCJYLU5vdGlvbi1TcGFjZS1JZFwiOiB1c2VyUHJlZmVyZW5jZXMuY3VycmVudFNwYWNlLmlkLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICBzcGFjZUlkOiB1c2VyUHJlZmVyZW5jZXMuY3VycmVudFNwYWNlLmlkXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVjZW50UGFnZXNSZXNwb25zZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlY2VudFBhZ2VzUmVzcG9uc2Ug5aSx6LSlXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBva1wiKTtcbiAgICB9XG5cbiAgICAvLyDkv67mlLkgcmVjZW50UGFnZXNGb3JCb29zdGluZ1xuICAgIHJlY2VudFBhZ2VzUmVzcG9uc2UucGFnZXMgPSByZWNlbnRQYWdlc1Jlc3BvbnNlLnBhZ2VzLm1hcChpdGVtID0+ICh7XG4gICAgICAgIHZpc2l0ZWRBdDogaXRlbS52aXNpdGVkQXQsXG4gICAgICAgIHBhZ2VJZDogaXRlbS5pZCxcbiAgICB9KSk7XG5cbiAgICAvLyDmnoTlu7rmlrDnmoTor7fmsYLkvZPvvIzlsIbmnIDov5HpobXpnaLorr/pl67mlbDmja7mj5LlhaXliLAgcmVjZW50UGFnZXNGb3JCb29zdGluZyDlrZfmrrXkuK1cbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgc291cmNlOiBcInF1aWNrX2ZpbmRfaW5wdXRfY2hhbmdlXCIsXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBcInJlbGV2YW5jZVwiLFxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJzOiB7XG4gICAgICAgICAgICBsYXN0RWRpdGVkVGltZToge30sXG4gICAgICAgICAgICBleGNsdWRlVGVtcGxhdGVzOiBmYWxzZSxcbiAgICAgICAgICAgIG5hdmlnYWJsZUJsb2NrQ29udGVudE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgYW5jZXN0b3JzOiBbXSxcbiAgICAgICAgICAgIGVkaXRlZEJ5OiBbXSxcbiAgICAgICAgICAgIHJlcXVpcmVFZGl0UGVybWlzc2lvbnM6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlZEJ5OiBbXSxcbiAgICAgICAgICAgIGlzRGVsZXRlZE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlZFRpbWU6IHt9LFxuICAgICAgICAgICAgaW5UZWFtczogW10sXG4gICAgICAgICAgICBpbmNsdWRlUHVibGljUGFnZXNXaXRob3V0RXhwbGljaXRBY2Nlc3M6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBleGNsdWRlZEJsb2NrSWRzOiBbXSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBsaW1pdDogOCxcbiAgICAgICAgcmVjZW50UGFnZXNGb3JCb29zdGluZzogcmVjZW50UGFnZXNSZXNwb25zZS5wYWdlcywgLy8g5o+S5YWl5pyA6L+R6aG16Z2i5pWw5o2uXG4gICAgICAgIHR5cGU6IFwiQmxvY2tzSW5TcGFjZVwiLFxuICAgICAgICBzZWFyY2hTZXNzaW9uSWQ6IFwiZWRkOGFkMDUtZmE2ZS00MTFiLTg0NzgtOTgzNzhjMDI0ZTNiXCIsXG4gICAgICAgIHNlYXJjaFNlc3Npb25GbG93TnVtYmVyOiAzLFxuICAgICAgICBzZWFyY2hFeHBlcmltZW50T3ZlcnJpZGVzOiB7fSxcbiAgICAgICAgc3BhY2VJZDogdXNlclByZWZlcmVuY2VzLmN1cnJlbnRTcGFjZS5pZFxuICAgIH07XG5cbiAgICAvLyDlvIDlp4vmkJzntKJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ2xpZW50KHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vd3d3Lm5vdGlvbi5zby9hcGkvdjMvc2VhcmNoXCIsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgXCJYLU5vdGlvbi1BY3RpdmUtVXNlci1IZWFkZXJcIjogdXNlci5pZCxcbiAgICAgICAgICAgIFwiWC1Ob3Rpb24tU3BhY2UtSWRcIjogdXNlclByZWZlcmVuY2VzLmN1cnJlbnRTcGFjZS5pZCxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogcmVxdWVzdEJvZHksXG4gICAgfSk7XG5cbiAgICAvLyDop6PmnpAg5Li65q+P5Liq57uT5p6c5re75YqgIHRpdGxl77yMcGF0aO+8jGljb25cbiAgICBjb25zdCByZXN1bHRzV2l0aEljb24gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcmVzcG9uc2UucmVzdWx0cy5tYXAoYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZEJsb2NrID0gcmVzcG9uc2UucmVjb3JkTWFwLmJsb2NrW2l0ZW0uaWRdO1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWRJdGVtID0gaXRlbTtcblxuICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgIC8vIOWkhOeQhiB0aXRsZSwgcGF0aFRleHRcbiAgICAgICAgICAgIGlmIChpdGVtLmhpZ2hsaWdodD8udGl0bGUgICYmIGl0ZW0uaGlnaGxpZ2h0LnRpdGxlLmluY2x1ZGVzKCc8Z3prTmZvVVU+JykpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkSXRlbS5oaWdobGlnaHQucGF0aFRleHQgPSBpdGVtLmhpZ2hsaWdodC5wYXRoVGV4dC5yZXBsYWNlKGl0ZW0uaGlnaGxpZ2h0LnRpdGxlLCAnJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZWRJdGVtLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTppdGVtLmhpZ2hsaWdodD8udGl0bGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXVwZGF0ZWRJdGVtLmhpZ2hsaWdodD8udGl0bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aXRsZVRleHQgPSByZWNvcmRCbG9jay52YWx1ZS5wcm9wZXJ0aWVzLnRpdGxlWzBdWzBdO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVkSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlVGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWkhOeQhiBpY29uXG4gICAgICAgICAgICBpZiAocmVjb3JkQmxvY2s/LnZhbHVlPy5mb3JtYXQ/LnBhZ2VfaWNvbikge1xuICAgICAgICAgICAgICAgIGxldCBwYWdlSWNvbj1yZWNvcmRCbG9jaz8udmFsdWU/LmZvcm1hdD8ucGFnZV9pY29uXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VJY29uLmluY2x1ZGVzKFwiYW1hem9uYXdzLmNvbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkVXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KHBhZ2VJY29uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVJZFF1ZXJ5ID0gaXRlbS5pZCA/IGA/dGFibGU9YmxvY2smaWQ9JHtpdGVtLmlkfSZ3aWR0aD00MCZjYWNoZT12MmAgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uVXJsID0gYGh0dHBzOi8vd3d3Lm5vdGlvbi5zby9pbWFnZS8ke2VuY29kZWRVcmx9JHt0YWJsZUlkUXVlcnl9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpY29uVXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0U3RyaW5nID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlQmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaIkOWKn+i9rOS4uuS6hiBibG9iIOWbvueJhyBiYXNlNjRTdHJpbmcgXCIsYmFzZTY0U3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZWRJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUljb246YmFzZTY0U3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYWdlSWNvbi5pbmNsdWRlcyhcInNpbmFpbWcuY1wiKSl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkSWNvblVybCA9IHBhZ2VJY29uLnJlcGxhY2UoL14oaHR0cHM/OlxcL1xcLykoW15cXC9dKykoXFwvLiopJC8sICckMWkxLndwLmNvbS8kMiQzJyk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlZEl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlSWNvbjpyZXBsYWNlZEljb25VcmxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVkSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJY29uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkSXRlbTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coXCJyZXN1bHRzV2l0aEljb25cIixyZXN1bHRzV2l0aEljb24pXG4gICAgcmVzLnNlbmQoe1xuICAgICAgICByZXNwb25zZTpyZXN1bHRzV2l0aEljb24sXG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlclxuIiwiaW1wb3J0IHtwZXJzaXN0b3IsIHN0b3JlfSBmcm9tIFwifnN0b3JlXCJcblxuY29uc29sZS5sb2coXCJMaXZlIG5vdzsgbWFrZSBub3cgYWx3YXlzIHRoZSBtb3N0IHByZWNpb3VzIHRpbWUuIE5vdyB3aWxsIG5ldmVyIGNvbWUgYWdhaW4uXCIpXG5cbi8vIOebkeWQrCBjb29raWVzIOeahOWPmOWMllxuY2hyb21lLmNvb2tpZXMub25DaGFuZ2VkLmFkZExpc3RlbmVyKChjaGFuZ2VJbmZvKSA9PiB7XG4gICAgLy8gLm5vdGlvbi5zbyDnmoQgY29va2llIOWPmOWMllxuICAgIGlmIChjaGFuZ2VJbmZvLmNvb2tpZS5kb21haW4gPT09IFwiLm5vdGlvbi5zb1wiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLm5vdGlvbi5zbyDnmoQgY29va2llIOWPmOWMllwiLGNoYW5nZUluZm8uY29va2llKVxuICAgICAgICAvLyBleHBsaWNpdCArIG92ZXJ3cml0ZSArIGZpbGVfdG9rZW4g55m75b2V5pON5L2c5LiL5Y+Y5YyWXG4gICAgICAgIGlmICgoY2hhbmdlSW5mby5jYXVzZSA9PT0gXCJleHBsaWNpdFwiIHx8IGNoYW5nZUluZm8uY2F1c2UgPT09IFwib3ZlcndyaXRlXCIpICYmIGNoYW5nZUluZm8uY29va2llLm5hbWUgPT09IFwiZmlsZV90b2tlblwiKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKVxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGAke2RhdGUuZ2V0RnVsbFllYXIoKX0tJHsoZGF0ZS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIil9LSR7ZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIil9ICR7ZGF0ZS5nZXRIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpfToke2RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpfToke2RhdGUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpfWBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcm1hdHRlZERhdGUsIFwi55uR5ZCs5YiwIC5ub3Rpb24uc28g55qEIGZpbGVfdG9rZW4g55qE5Y+Y5YyWXCIsIGNoYW5nZUluZm8pXG4gICAgICAgICAgICAvLyDlj5HpgIHmtojmga/liLBwb3B1cOmhtemdolxuICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe3R5cGU6IFwibm90aW9uX2Nvb2tpZXNfb25DaGFuZ2VkXCIsIHBheWxvYWQ6IGNoYW5nZUluZm99LCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWbnuiwg+WHveaVsDpcIiwgcmVzKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzICYmIHJlcy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWbnuiwg+WHveaVsCBFcnJvcjpcIiwgcmVzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICB9XG59KVxuXG5wZXJzaXN0b3Iuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcImJhY2tncm91bmQgaW5kZXgudHMgc3Vic2NyaWJlIFN0YXRlOiBcIiwgc3RvcmU/LmdldFN0YXRlKCkpXG59KVxuIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzLCBjb25maWd1cmVTdG9yZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgdXNlRGlzcGF0Y2gsIHVzZVNlbGVjdG9yIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHR5cGUgeyBUeXBlZFVzZVNlbGVjdG9ySG9vayB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHN5bmNTdG9yYWdlIH0gZnJvbSAncmVkdXgtcGVyc2lzdC13ZWJleHRlbnNpb24tc3RvcmFnZSc7XG5cbmltcG9ydCB7XG4gICAgRkxVU0gsXG4gICAgUEFVU0UsXG4gICAgUEVSU0lTVCxcbiAgICBwZXJzaXN0UmVkdWNlcixcbiAgICBwZXJzaXN0U3RvcmUsXG4gICAgUFVSR0UsXG4gICAgUkVHSVNURVIsXG4gICAgUkVIWURSQVRFLFxuICAgIFJFU1lOQyxcbn0gZnJvbSAnQHBsYXNtb2hxL3JlZHV4LXBlcnNpc3QnO1xuaW1wb3J0IHsgU3RvcmFnZSB9IGZyb20gJ0BwbGFzbW9ocS9zdG9yYWdlJztcblxuaW1wb3J0IG5vdGlvblN0YXRlUmVkdWNlciBmcm9tICd+bm90aW9uL25vdGlvbi1zbGljZSc7XG5cbmNvbnN0IGNvbWJpbmVkUmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICAgIG5vdGlvbjogbm90aW9uU3RhdGVSZWR1Y2VyLFxufSk7XG5cblxuY29uc3QgcGVyc2lzdENvbmZpZyA9IHtcbiAgICBrZXk6IFwicm9vdFwiLFxuICAgIHZlcnNpb246IDEsXG4gICAgc3RvcmFnZTogc3luY1N0b3JhZ2Vcbn1cblxuY29uc3QgcGVyc2lzdGVkUmVkdWNlciA9IHBlcnNpc3RSZWR1Y2VyKHBlcnNpc3RDb25maWcsIGNvbWJpbmVkUmVkdWNlcnMpXG5cbmNvbnN0IG1vY2tTdG9yZSA9IGNvbmZpZ3VyZVN0b3JlKHtcbiAgICByZWR1Y2VyOiBjb21iaW5lZFJlZHVjZXJzXG59KVxuXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3Qgc3RvcmUgPSBjb25maWd1cmVTdG9yZSh7XG4gICAgcmVkdWNlcjogcGVyc2lzdGVkUmVkdWNlcixcbiAgICBtaWRkbGV3YXJlOiAoZ2V0RGVmYXVsdE1pZGRsZXdhcmUpID0+XG4gICAgICAgIGdldERlZmF1bHRNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUNoZWNrOiB7XG4gICAgICAgICAgICAgICAgaWdub3JlZEFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgRkxVU0gsXG4gICAgICAgICAgICAgICAgICAgIFJFSFlEUkFURSxcbiAgICAgICAgICAgICAgICAgICAgUEFVU0UsXG4gICAgICAgICAgICAgICAgICAgIFBFUlNJU1QsXG4gICAgICAgICAgICAgICAgICAgIFBVUkdFLFxuICAgICAgICAgICAgICAgICAgICBSRUdJU1RFUixcbiAgICAgICAgICAgICAgICAgICAgUkVTWU5DXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxufSkgYXMgdHlwZW9mIG1vY2tTdG9yZVxuXG5leHBvcnQgY29uc3QgcGVyc2lzdG9yID0gcGVyc2lzdFN0b3JlKHN0b3JlKVxuXG5uZXcgU3RvcmFnZSgpLndhdGNoKHtcbiAgICBbYHBlcnNpc3Q6JHtwZXJzaXN0Q29uZmlnLmtleX1gXTogKGNoYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCB7b2xkVmFsdWUsIG5ld1ZhbHVlfSA9IGNoYW5nZVxuICAgICAgICBjb25zdCB1cGRhdGVkS2V5cyA9IFtdXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWVba2V5XSAhPT0gbmV3VmFsdWU/LltrZXldKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEtleXMucHVzaChrZXkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZT8uW2tleV0gIT09IG5ld1ZhbHVlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkS2V5cy5wdXNoKGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGVyc2lzdG9yLnJlc3luYygpXG4gICAgICAgIH1cbiAgICB9XG59KVxuXG5leHBvcnQgdHlwZSBSb290U3RhdGUgPSBSZXR1cm5UeXBlPHR5cGVvZiBtb2NrU3RvcmUuZ2V0U3RhdGU+XG5leHBvcnQgdHlwZSBBcHBEaXNwYXRjaCA9IHR5cGVvZiBtb2NrU3RvcmUuZGlzcGF0Y2hcblxuZXhwb3J0IGNvbnN0IHVzZUFwcERpc3BhdGNoOiAoKSA9PiBBcHBEaXNwYXRjaCA9IHVzZURpc3BhdGNoXG5leHBvcnQgY29uc3QgdXNlQXBwU2VsZWN0b3I6IFR5cGVkVXNlU2VsZWN0b3JIb29rPFJvb3RTdGF0ZT4gPSB1c2VTZWxlY3RvclxuIiwidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MiwgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xuaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgY29tYmluZVJlZHVjZXJzLCBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9kZXZ0b29sc0V4dGVuc2lvbi50c1xuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZFxuICAgICAgfSwgXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICB9KSwgXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZChpdGVyYWJsZSwgY29tcGFyYXRvcikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoZW50cnkpKSB7XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gY3JlYXRlTmV4dFN0YXRlKHZhbCwgKCkgPT4ge1xuICB9KSA6IHZhbDtcbn1cbmZ1bmN0aW9uIGVtcGxhY2UobWFwLCBrZXksIGhhbmRsZXIpIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoaGFuZGxlci51cGRhdGUpIHtcbiAgICAgIHZhbHVlID0gaGFuZGxlci51cGRhdGUodmFsdWUsIGtleSwgbWFwKTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWhhbmRsZXIuaW5zZXJ0KVxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiTm8gaW5zZXJ0IHByb3ZpZGVkIGZvciBrZXkgbm90IGFscmVhZHkgaW4gbWFwXCIpO1xuICBjb25zdCBpbnNlcnRlZCA9IGhhbmRsZXIuaW5zZXJ0KGtleSwgbWFwKTtcbiAgbWFwLnNldChrZXksIGluc2VydGVkKTtcbiAgcmV0dXJuIGluc2VydGVkO1xufVxuXG4vLyBzcmMvaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsIHx8IE9iamVjdC5pc0Zyb3plbih2YWx1ZSk7XG59XG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xuICBjb25zdCB0cmFja2VkUHJvcGVydGllcyA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaik7XG4gIHJldHVybiB7XG4gICAgZGV0ZWN0TXV0YXRpb25zKCkge1xuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMgPSBbXSwgb2JqLCBwYXRoID0gXCJcIiwgY2hlY2tlZE9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQgPSB7XG4gICAgdmFsdWU6IG9ialxuICB9O1xuICBpZiAoIWlzSW1tdXRhYmxlKG9iaikgJiYgIWNoZWNrZWRPYmplY3RzLmhhcyhvYmopKSB7XG4gICAgY2hlY2tlZE9iamVjdHMuYWRkKG9iaik7XG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tlZDtcbn1cbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzID0gW10sIHRyYWNrZWRQcm9wZXJ0eSwgb2JqLCBzYW1lUGFyZW50UmVmID0gZmFsc2UsIHBhdGggPSBcIlwiKSB7XG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XG4gIGNvbnN0IHNhbWVSZWYgPSBwcmV2T2JqID09PSBvYmo7XG4gIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiB0cnVlLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IGtleXNUb0RldGVjdCA9IHt9O1xuICBmb3IgKGxldCBrZXkgaW4gdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGtleSBpbiBrZXlzVG9EZXRlY3QpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XG4gICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3RyaW5naWZ5MiA9IGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplciwgaW5kZW50LCBkZWN5Y2xlcikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplMihzZXJpYWxpemVyLCBkZWN5Y2xlciksIGluZGVudCk7XG4gICAgfSwgZ2V0U2VyaWFsaXplMiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSB7XG4gICAgICBsZXQgc3RhY2sgPSBbXSwga2V5cyA9IFtdO1xuICAgICAgaWYgKCFkZWN5Y2xlcilcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbihfLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfl1cIjtcbiAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlID09IG51bGwgPyB2b2lkIDAgOiBjYWNoZS5oYXModmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSlcbiAgICBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxuICAgICAgZ2V0RW50cmllcyxcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXG4gICAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSxcbiAgICAgIGlnbm9yZWRQYXRocyA9IFtdLFxuICAgICAgd2FybkFmdGVyID0gMzIsXG4gICAgICBpZ25vcmVTdGF0ZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQWN0aW9ucyA9IGZhbHNlLFxuICAgICAgZGlzYWJsZUNhY2hlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYWNoZSA9ICFkaXNhYmxlQ2FjaGUgJiYgV2Vha1NldCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xuICAgIHJldHVybiAoc3RvcmVBUEkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWlzQWN0aW9uMihhY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICBpZiAoIWlnbm9yZUFjdGlvbnMgJiYgIShpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoYWN0aW9uLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZEFjdGlvblBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiBhbiBhY3Rpb24sIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxuVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhpcyBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX0uXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJib29sZWFuXCI7XG59XG52YXIgYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSA9ICgpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHRodW5rID0gdHJ1ZSxcbiAgICBpbW11dGFibGVDaGVjayA9IHRydWUsXG4gICAgc2VyaWFsaXphYmxlQ2hlY2sgPSB0cnVlLFxuICAgIGFjdGlvbkNyZWF0b3JDaGVjayA9IHRydWVcbiAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgbGV0IG1pZGRsZXdhcmVBcnJheSA9IG5ldyBUdXBsZSgpO1xuICBpZiAodGh1bmspIHtcbiAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2god2l0aEV4dHJhQXJndW1lbnQodGh1bmsuZXh0cmFBcmd1bWVudCkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgaW1tdXRhYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oaW1tdXRhYmxlQ2hlY2spKSB7XG4gICAgICAgIGltbXV0YWJsZU9wdGlvbnMgPSBpbW11dGFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xuICAgICAgbGV0IHNlcmlhbGl6YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKHNlcmlhbGl6YWJsZUNoZWNrKSkge1xuICAgICAgICBzZXJpYWxpemFibGVPcHRpb25zID0gc2VyaWFsaXphYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XG4gICAgICBsZXQgYWN0aW9uQ3JlYXRvck9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGFjdGlvbkNyZWF0b3JDaGVjaykpIHtcbiAgICAgICAgYWN0aW9uQ3JlYXRvck9wdGlvbnMgPSBhY3Rpb25DcmVhdG9yQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWlkZGxld2FyZUFycmF5O1xufTtcblxuLy8gc3JjL2F1dG9CYXRjaEVuaGFuY2VyLnRzXG52YXIgU0hPVUxEX0FVVE9CQVRDSCA9IFwiUlRLX2F1dG9CYXRjaFwiO1xudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9ICgpID0+IChwYXlsb2FkKSA9PiAoe1xuICBwYXlsb2FkLFxuICBtZXRhOiB7XG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gIH1cbn0pO1xudmFyIGNyZWF0ZVF1ZXVlV2l0aFRpbWVyID0gKHRpbWVvdXQpID0+IHtcbiAgcmV0dXJuIChub3RpZnkpID0+IHtcbiAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XG4gIH07XG59O1xudmFyIHJBRiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcigxMCk7XG52YXIgYXV0b0JhdGNoRW5oYW5jZXIgPSAob3B0aW9ucyA9IHtcbiAgdHlwZTogXCJyYWZcIlxufSkgPT4gKG5leHQpID0+ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gbmV4dCguLi5hcmdzKTtcbiAgbGV0IG5vdGlmeWluZyA9IHRydWU7XG4gIGxldCBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICBsZXQgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSBvcHRpb25zLnR5cGUgPT09IFwidGlja1wiID8gcXVldWVNaWNyb3Rhc2sgOiBvcHRpb25zLnR5cGUgPT09IFwicmFmXCIgPyByQUYgOiBvcHRpb25zLnR5cGUgPT09IFwiY2FsbGJhY2tcIiA/IG9wdGlvbnMucXVldWVOb3RpZmljYXRpb24gOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcihvcHRpb25zLnRpbWVvdXQpO1xuICBjb25zdCBub3RpZnlMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGwpID0+IGwoKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuc3Vic2NyaWJlYCBtZXRob2QgdG8ga2VlcCBvcmlnaW5hbCBsaXN0ZW5lcnNcbiAgICAvLyBmcm9tIHJ1bm5pbmcgaWYgd2UncmUgZGVsYXlpbmcgbm90aWZpY2F0aW9uc1xuICAgIHN1YnNjcmliZShsaXN0ZW5lcjIpIHtcbiAgICAgIGNvbnN0IHdyYXBwZWRMaXN0ZW5lciA9ICgpID0+IG5vdGlmeWluZyAmJiBsaXN0ZW5lcjIoKTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyMik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLmRpc3BhdGNoYCBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gY2hlY2sgYWN0aW9uc1xuICAgIC8vIGZvciB0aGUgYHNob3VsZEF1dG9CYXRjaGAgZmxhZyBhbmQgZGV0ZXJtaW5lIGlmIGJhdGNoaW5nIGlzIGFjdGl2ZVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gISgoX2EgPSBhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbU0hPVUxEX0FVVE9CQVRDSF0pO1xuICAgICAgICBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9ICFub3RpZnlpbmc7XG4gICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgICAgIGlmICghbm90aWZpY2F0aW9uUXVldWVkKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25RdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcXVldWVDYWxsYmFjayhub3RpZnlMaXN0ZW5lcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG5vdGlmeWluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0RW5oYW5jZXJzLnRzXG52YXIgYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzID0gKG1pZGRsZXdhcmVFbmhhbmNlcikgPT4gZnVuY3Rpb24gZ2V0RGVmYXVsdEVuaGFuY2VycyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBhdXRvQmF0Y2ggPSB0cnVlXG4gIH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gIGxldCBlbmhhbmNlckFycmF5ID0gbmV3IFR1cGxlKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gXCJvYmplY3RcIiA/IGF1dG9CYXRjaCA6IHZvaWQgMCkpO1xuICB9XG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xufTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG52YXIgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIHByZWxvYWRlZFN0YXRlID0gdm9pZCAwLFxuICAgIGVuaGFuY2VycyA9IHZvaWQgMFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IHJvb3RSZWR1Y2VyO1xuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0MihyZWR1Y2VyKSkge1xuICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJgcmVkdWNlcmAgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnNcIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGxldCBmaW5hbENvbXBvc2UgPSBjb21wb3NlMjtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXG4gICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KHN0b3JlRW5oYW5jZXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5sZW5ndGggJiYgIXN0b3JlRW5oYW5jZXJzLmluY2x1ZGVzKG1pZGRsZXdhcmVFbmhhbmNlcikpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibWlkZGxld2FyZXMgd2VyZSBwcm92aWRlZCwgYnV0IG1pZGRsZXdhcmUgZW5oYW5jZXIgd2FzIG5vdCBpbmNsdWRlZCBpbiBmaW5hbCBlbmhhbmNlcnMgLSBtYWtlIHN1cmUgdG8gY2FsbCBgZ2V0RGVmYXVsdEVuaGFuY2Vyc2BcIik7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZSguLi5zdG9yZUVuaGFuY2Vycyk7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNykgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5KSA6IGBcXGBidWlsZGVyLmFkZENhc2VcXGAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZTIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6IFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9uYW5vaWQudHNcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLy8gc3JjL21hdGNoZXJzLnRzXG52YXIgbWF0Y2hlcyA9IChtYXRjaGVyLCBhY3Rpb24pID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0FueU9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FsbE9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCB2YWxpZFN0YXR1cykge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcbiAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XG59XG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnBlbmRpbmcpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICAgIH07XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICBjb25zdCBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mKC4uLm1hdGNoZXJzKTtcbiAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFzeW5jVGh1bmsgb2YgYXN5bmNUaHVua3MpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2goYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJzdGFja1wiLCBcImNvZGVcIl07XG52YXIgUmVqZWN0V2l0aFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgIC8qXG4gICAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3R5cGVcIik7XG4gIH1cbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgIC8qXG4gICAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3R5cGVcIik7XG4gIH1cbn07XG52YXIgbWluaVNlcmlhbGl6ZUVycm9yID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICBjb25zdCBzaW1wbGVFcnJvciA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgY29tbW9uUHJvcGVydGllcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wZXJ0eV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBTdHJpbmcodmFsdWUpXG4gIH07XG59O1xudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuazIodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmdWxmaWxsZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL2Z1bGZpbGxlZFwiLCAocGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgbWV0YTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWV0YSB8fCB7fSksIHtcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH0pXG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWV0YSB8fCB7fSksIHtcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicGVuZGluZ1wiXG4gICAgICB9KVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcbiAgICAgIH0pXG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRHZW5lcmF0b3IpID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgbGV0IGFib3J0SGFuZGxlcjtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbmRpdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlIHx8IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJBYm9ydEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCBcIkFib3J0ZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldFBlbmRpbmdNZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCB7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgYXJnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gYXdhaXQgUHJvbWlzZS5yYWNlKFthYm9ydGVkUHJvbWlzZSwgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xuICAgICAgICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgIHJlamVjdFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWplY3RXaXRoVmFsdWUodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdWxmaWxsV2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQucGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdCwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gZXJyIGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlID8gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIGVyci5wYXlsb2FkLCBlcnIubWV0YSkgOiByZWplY3RlZChlcnIsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGFib3J0SGFuZGxlcikge1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcbiAgICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goZmluYWxBY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluYWxBY3Rpb247XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgdW53cmFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbih1bndyYXBSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XG4gICAgICBwZW5kaW5nLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBmdWxmaWxsZWQsXG4gICAgICBzZXR0bGVkOiBpc0FueU9mKHJlamVjdGVkLCBmdWxmaWxsZWQpLFxuICAgICAgdHlwZVByZWZpeFxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9ICgpID0+IGNyZWF0ZUFzeW5jVGh1bmsyO1xuICByZXR1cm4gY3JlYXRlQXN5bmNUaHVuazI7XG59KSgpO1xuZnVuY3Rpb24gdW53cmFwUmVzdWx0KGFjdGlvbikge1xuICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcbiAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgfVxuICBpZiAoYWN0aW9uLmVycm9yKSB7XG4gICAgdGhyb3cgYWN0aW9uLmVycm9yO1xuICB9XG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcbnZhciBhc3luY1RodW5rU3ltYm9sID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJydGstc2xpY2UtY3JlYXRlYXN5bmN0aHVua1wiKTtcbnZhciBhc3luY1RodW5rQ3JlYXRvciA9IHtcbiAgW2FzeW5jVGh1bmtTeW1ib2xdOiBjcmVhdGVBc3luY1RodW5rXG59O1xudmFyIFJlZHVjZXJUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVkdWNlclR5cGUyKSA9PiB7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJcIl0gPSBcInJlZHVjZXJcIjtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlcldpdGhQcmVwYXJlXCJdID0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIjtcbiAgUmVkdWNlclR5cGUyW1wiYXN5bmNUaHVua1wiXSA9IFwiYXN5bmNUaHVua1wiO1xuICByZXR1cm4gUmVkdWNlclR5cGUyO1xufSkoUmVkdWNlclR5cGUgfHwge30pO1xuZnVuY3Rpb24gZ2V0VHlwZShzbGljZSwgYWN0aW9uS2V5KSB7XG4gIHJldHVybiBgJHtzbGljZX0vJHthY3Rpb25LZXl9YDtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ3JlYXRlU2xpY2Uoe1xuICBjcmVhdG9yc1xufSA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgY0FUID0gKF9hID0gY3JlYXRvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNyZWF0b3JzLmFzeW5jVGh1bmspID09IG51bGwgPyB2b2lkIDAgOiBfYVthc3luY1RodW5rU3ltYm9sXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNsaWNlMihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXJQYXRoID0gbmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGU6IHt9LFxuICAgICAgYWN0aW9uQ3JlYXRvcnM6IHt9LFxuICAgICAgc2xpY2VNYXRjaGVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHRNZXRob2RzID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyMikge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQWN0aW9uKG5hbWUyLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZTJdID0gYWN0aW9uQ3JlYXRvcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUNhc2VSZWR1Y2VyKG5hbWUyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW25hbWUyXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpZiAoaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcywgY0FUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBleHRyYVJlZHVjZXJzKSwgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVkdWNlcihvcHRpb25zLmluaXRpYWxTdGF0ZSwgKGJ1aWxkZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGZpbmFsQ2FzZVJlZHVjZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGtleSwgZmluYWxDYXNlUmVkdWNlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc00gb2YgY29udGV4dC5zbGljZU1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKHNNLm1hdGNoZXIsIHNNLnJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG0gb2YgYWN0aW9uTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIobS5tYXRjaGVyLCBtLnJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RTZWxmID0gKHN0YXRlKSA9PiBzdGF0ZTtcbiAgICBjb25zdCBpbmplY3RlZFNlbGVjdG9yQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBfcmVkdWNlcjtcbiAgICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIGlmICghX3JlZHVjZXIpXG4gICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICByZXR1cm4gX3JlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgIGlmICghX3JlZHVjZXIpXG4gICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICByZXR1cm4gX3JlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VTZWxlY3RvclByb3BzKHJlZHVjZXJQYXRoMiwgaW5qZWN0ZWQgPSBmYWxzZSkge1xuICAgICAgZnVuY3Rpb24gc2VsZWN0U2xpY2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aDJdO1xuICAgICAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlU3RhdGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBlbXBsYWNlKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgaW5qZWN0ZWQsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1wbGFjZShzZWxlY3RvckNhY2hlLCBzZWxlY3RTdGF0ZSwge1xuICAgICAgICAgIGluc2VydDogKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZTIsIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcygoX2EyID0gb3B0aW9ucy5zZWxlY3RvcnMpICE9IG51bGwgPyBfYTIgOiB7fSkpIHtcbiAgICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyLFxuICAgICAgYWN0aW9uczogY29udGV4dC5hY3Rpb25DcmVhdG9ycyxcbiAgICAgIGNhc2VSZWR1Y2VyczogY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcbiAgICAgIGdldEluaXRpYWxTdGF0ZVxuICAgIH0sIG1ha2VTZWxlY3RvclByb3BzKHJlZHVjZXJQYXRoKSksIHtcbiAgICAgIGluamVjdEludG8oaW5qZWN0YWJsZSwgX2EyID0ge30pIHtcbiAgICAgICAgdmFyIF9iID0gX2EyLCB7XG4gICAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHRcbiAgICAgICAgfSA9IF9iLCBjb25maWcgPSBfX29ialJlc3QoX2IsIFtcbiAgICAgICAgICBcInJlZHVjZXJQYXRoXCJcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCAhPSBudWxsID8gcGF0aE9wdCA6IHJlZHVjZXJQYXRoO1xuICAgICAgICBpbmplY3RhYmxlLmluamVjdCh7XG4gICAgICAgICAgcmVkdWNlclBhdGg6IG5ld1JlZHVjZXJQYXRoLFxuICAgICAgICAgIHJlZHVjZXJcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBzbGljZSksIG1ha2VTZWxlY3RvclByb3BzKG5ld1JlZHVjZXJQYXRoLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xuICB9O1xufVxuZnVuY3Rpb24gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCkge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xuICAgIGxldCBzbGljZVN0YXRlID0gc2VsZWN0U3RhdGUocm9vdFN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XG4gIH1cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG52YXIgY3JlYXRlU2xpY2UgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRDcmVhdGVTbGljZSgpO1xuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XG4gIGZ1bmN0aW9uIGFzeW5jVGh1bmsocGF5bG9hZENyZWF0b3IsIGNvbmZpZykge1xuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxuICAgICAgcGF5bG9hZENyZWF0b3JcbiAgICB9LCBjb25maWcpO1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdyYXBwZXIgc28gdGhlIGByZWR1Y2VyRGVmaW5pdGlvblR5cGVgIGlzIG5vdCBhc3NpZ25lZCB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgW2Nhc2VSZWR1Y2VyLm5hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi8sXG4gICAgICAgIHByZXBhcmUsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luY1RodW5rXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufSwgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUsIGNvbnRleHQpIHtcbiAgbGV0IGNhc2VSZWR1Y2VyO1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrO1xuICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBcIlBsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLlwiKTtcbiAgICB9XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xuICAgIHByZXBhcmVDYWxsYmFjayA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnByZXBhcmU7XG4gIH0gZWxzZSB7XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcbiAgfVxuICBjb250ZXh0LmFkZENhc2UodHlwZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCBjYXNlUmVkdWNlcikuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKSk7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovO1xufVxuZnVuY3Rpb24gaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi87XG59XG5mdW5jdGlvbiBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lXG59LCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dCwgY0FUKSB7XG4gIGlmICghY0FUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGF5bG9hZENyZWF0b3IsXG4gICAgZnVsZmlsbGVkLFxuICAgIHBlbmRpbmcsXG4gICAgcmVqZWN0ZWQsXG4gICAgc2V0dGxlZCxcbiAgICBvcHRpb25zXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcbiAgY29uc3QgdGh1bmsgPSBjQVQodHlwZSwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpO1xuICBjb250ZXh0LmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgdGh1bmspO1xuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuICBpZiAocGVuZGluZykge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5wZW5kaW5nLCBwZW5kaW5nKTtcbiAgfVxuICBpZiAocmVqZWN0ZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsucmVqZWN0ZWQsIHJlamVjdGVkKTtcbiAgfVxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQgfHwgbm9vcCxcbiAgICBwZW5kaW5nOiBwZW5kaW5nIHx8IG5vb3AsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXG4gICAgc2V0dGxlZDogc2V0dGxlZCB8fCBub29wXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGlkczogW10sXG4gICAgZW50aXRpZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcikge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30sIGVudGl0aWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICAgIHJldHVybiBlbnRpdGllcyA/IHN0YXRlQWRhcHRlci5zZXRBbGwoc3RhdGUsIGVudGl0aWVzKSA6IHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMywgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xudmFyIGlzRHJhZnRUeXBlZCA9IGlzRHJhZnQzO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcbiAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdCkgPT4ge1xuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0RyYWZ0VHlwZWQoc3RhdGUpKSB7XG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xuICB9XG4gIHJldHVybiBlbnRpdGllcztcbn1cbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgdXBkYXRlZC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYW5nZXM6IGVudGl0eVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW25ld0tleV0gPSB1cGRhdGVkO1xuICAgIHJldHVybiBoYXNOZXdLZXk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBjb25zdCBuZXdLZXlzID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eSA9IHt9O1xuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB7XG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXMgOiBudWxsKSwgdXBkYXRlLmNoYW5nZXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XG4gICAgY29uc3QgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XG4gICAgICBjb25zdCBkaWRNdXRhdGVJZHMgPSB1cGRhdGVzLmZpbHRlcigodXBkYXRlKSA9PiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpKS5sZW5ndGggPiAwO1xuICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xuICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKS5tYXAoKGUpID0+IHNlbGVjdElkVmFsdWUoZSwgc2VsZWN0SWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxuICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcbiAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydCkge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsXG4gIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpKTtcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZShtb2RlbHMsIHN0YXRlKSB7XG4gICAgbW9kZWxzLmZvckVhY2goKG1vZGVsKSA9PiB7XG4gICAgICA7XG4gICAgICBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChtb2RlbCldID0gbW9kZWw7XG4gICAgfSk7XG4gICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKTtcbiAgICBhbGxFbnRpdGllcy5zb3J0KHNvcnQpO1xuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgY29uc3Qge1xuICAgICAgaWRzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZFxuICB9LCBvcHRpb25zKTtcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBjb25zdCBzdGF0ZUZhY3RvcnkgPSBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcik7XG4gIGNvbnN0IHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xufVxuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBpc0FjdGlvbiBhcyBpc0FjdGlvbjMgfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9leGNlcHRpb25zLnRzXG52YXIgdGFzayA9IFwidGFza1wiO1xudmFyIGxpc3RlbmVyID0gXCJsaXN0ZW5lclwiO1xudmFyIGNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcbnZhciB0YXNrQ2FuY2VsbGVkID0gYHRhc2stJHtjYW5jZWxsZWR9YDtcbnZhciB0YXNrQ29tcGxldGVkID0gYHRhc2stJHtjb21wbGV0ZWR9YDtcbnZhciBsaXN0ZW5lckNhbmNlbGxlZCA9IGAke2xpc3RlbmVyfS0ke2NhbmNlbGxlZH1gO1xudmFyIGxpc3RlbmVyQ29tcGxldGVkID0gYCR7bGlzdGVuZXJ9LSR7Y29tcGxldGVkfWA7XG52YXIgVGFza0Fib3J0RXJyb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiVGFza0Fib3J0RXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1lc3NhZ2VcIik7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGNhdGNoUmVqZWN0aW9uID0gKHByb21pc2UsIG9uRXJyb3IgPSBub29wMikgPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbCwgY2FsbGJhY2spID0+IHtcbiAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7XG59O1xudmFyIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24gPSAoYWJvcnRDb250cm9sbGVyLCByZWFzb24pID0+IHtcbiAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcmVhc29uLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICA7XG4gIGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXG52YXIgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsKSA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSBzaWduYWw7XG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXAgPT0gbnVsbCA/IHZvaWQgMCA6IGNsZWFuVXAoKTtcbiAgfVxufTtcbnZhciBjcmVhdGVQYXVzZSA9IChzaWduYWwpID0+IHtcbiAgcmV0dXJuIChwcm9taXNlKSA9PiB7XG4gICAgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gIH07XG59O1xudmFyIGNyZWF0ZURlbGF5ID0gKHNpZ25hbCkgPT4ge1xuICBjb25zdCBwYXVzZSA9IGNyZWF0ZVBhdXNlKHNpZ25hbCk7XG4gIHJldHVybiAodGltZW91dE1zKSA9PiB7XG4gICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcykpKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbnZhciB7XG4gIGFzc2lnblxufSA9IE9iamVjdDtcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcbnZhciBhbG0gPSBcImxpc3RlbmVyTWlkZGxld2FyZVwiO1xudmFyIGNyZWF0ZUZvcmsgPSAocGFyZW50QWJvcnRTaWduYWwsIHBhcmVudEJsb2NraW5nUHJvbWlzZXMpID0+IHtcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXIpID0+IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKSk7XG4gIHJldHVybiAodGFza0V4ZWN1dG9yLCBvcHRzKSA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcbiAgICBjb25zdCBjaGlsZEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsaW5rQ29udHJvbGxlcnMoY2hpbGRBYm9ydENvbnRyb2xsZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1blRhc2soYXN5bmMgKCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0YXNrRXhlY3V0b3Ioe1xuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpID0+IHtcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIGVmZmVjdDogKGFjdGlvbiwgbGlzdGVuZXJBcGkpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3R1cGxlUHJvbWlzZV07XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7XG59O1xudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgYWN0aW9uQ3JlYXRvcixcbiAgICBtYXRjaGVyLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xuICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XG4gIH0gZWxzZSBpZiAobWF0Y2hlcikge1xuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XG4gIH0gZWxzZSBpZiAocHJlZGljYXRlKSB7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XG4gIH1cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBPYmplY3QuYXNzaWduKChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkLFxuICAgIGVmZmVjdCxcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBwZW5kaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMikgOiBcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeTtcbn0sIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVMaXN0ZW5lckVudHJ5XG59KTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjYW5jZWxPcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHN0YXJ0TGlzdGVuaW5nID0gKG9wdGlvbnMpID0+IHtcbiAgICBsZXQgZW50cnkgPSBmaW5kKEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpLCAoZXhpc3RpbmdFbnRyeSkgPT4gZXhpc3RpbmdFbnRyeS5lZmZlY3QgPT09IG9wdGlvbnMuZWZmZWN0KTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICBlbnRyeSA9IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnRFbnRyeShlbnRyeSk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhcnRMaXN0ZW5pbmcsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHN0YXJ0TGlzdGVuaW5nXG4gIH0pO1xuICBjb25zdCBzdG9wTGlzdGVuaW5nID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZWZmZWN0LFxuICAgICAgcHJlZGljYXRlXG4gICAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kKEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpLCAoZW50cnkyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaFByZWRpY2F0ZU9yVHlwZSA9IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiID8gZW50cnkyLnR5cGUgPT09IHR5cGUgOiBlbnRyeTIucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgICByZXR1cm4gbWF0Y2hQcmVkaWNhdGVPclR5cGUgJiYgZW50cnkyLmVmZmVjdCA9PT0gZWZmZWN0O1xuICAgIH0pO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISFlbnRyeTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdG9wTGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdG9wTGlzdGVuaW5nXG4gIH0pO1xuICBjb25zdCBub3RpZnlMaXN0ZW5lciA9IGFzeW5jIChlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoZW50cnkuZWZmZWN0KFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIC8vIFVzZSBhc3NpZ24oKSByYXRoZXIgdGhhbiAuLi4gdG8gYXZvaWQgZXh0cmEgaGVscGVyIGZ1bmN0aW9ucyBhZGRlZCB0byBidW5kbGVcbiAgICAgICAgYXNzaWduKHt9LCBhcGksIHtcbiAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlLFxuICAgICAgICAgIGNvbmRpdGlvbjogKHByZWRpY2F0ZSwgdGltZW91dCkgPT4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbiksXG4gICAgICAgICAgdGFrZSxcbiAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgc2lnbmFsOiBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcbiAgICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXG4gICAgICAgICAgc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogKCkgPT4ge1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyLCBfLCBzZXQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IGludGVybmFsVGFza0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApKTtcbiAgICB9IGNhdGNoIChsaXN0ZW5lckVycm9yKSB7XG4gICAgICBpZiAoIShsaXN0ZW5lckVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XG4gICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3IsIHtcbiAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXV0b0pvaW5Qcm9taXNlcyk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ29tcGxldGVkKTtcbiAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICghaXNBY3Rpb24zKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgfVxuICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhcnRMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBbGxMaXN0ZW5lcnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgbGV0IG9yaWdpbmFsU3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCkgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsU3RhdGUgPT09IElOVEVSTkFMX05JTF9UT0tFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdGVuZXJFbnRyaWVzKSB7XG4gICAgICAgICAgbGV0IHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZW50cnkucHJlZGljYXRlKGFjdGlvbiwgY3VycmVudFN0YXRlLCBvcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgICB9IGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIHByZWRpY2F0ZUVycm9yLCB7XG4gICAgICAgICAgICAgIHJhaXNlZEJ5OiBcInByZWRpY2F0ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFydW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgb3JpZ2luYWxTdGF0ZSA9IElOVEVSTkFMX05JTF9UT0tFTjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIHN0YXJ0TGlzdGVuaW5nLFxuICAgIHN0b3BMaXN0ZW5pbmcsXG4gICAgY2xlYXJMaXN0ZW5lcnM6IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlXG4gIH07XG59O1xuXG4vLyBzcmMvZHluYW1pY01pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGNvbXBvc2UgYXMgY29tcG9zZTMgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjcmVhdGVNaWRkbGV3YXJlRW50cnkgPSAobWlkZGxld2FyZSkgPT4gKHtcbiAgaWQ6IG5hbm9pZCgpLFxuICBtaWRkbGV3YXJlLFxuICBhcHBsaWVkOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG59KTtcbnZhciBtYXRjaEluc3RhbmNlID0gKGluc3RhbmNlSWQpID0+IChhY3Rpb24pID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGFjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogYWN0aW9uLm1ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbnN0YW5jZUlkKSA9PT0gaW5zdGFuY2VJZDtcbn07XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG52YXIgbm9vcFJlZHVjZXIgPSAoc3RhdGUgPSB7fSkgPT4gc3RhdGU7XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKSA6IG5vb3BSZWR1Y2VyO1xuICBsZXQgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgZnVuY3Rpb24gY29tYmluZWRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgfVxuICBjb21iaW5lZFJlZHVjZXIud2l0aExhenlMb2FkZWRTbGljZXMgPSAoKSA9PiBjb21iaW5lZFJlZHVjZXI7XG4gIGNvbnN0IGluamVjdCA9IChzbGljZSwgY29uZmlnID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuICAgIGlmICghY29uZmlnLm92ZXJyaWRlRXhpc3RpbmcgJiYgY3VycmVudFJlZHVjZXIgJiYgY3VycmVudFJlZHVjZXIgIT09IHJlZHVjZXJUb0luamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdFxcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIHJlZHVjZXIgJHtyZWR1Y2VyUGF0aH0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcihzZWxlY3RvckZuLCBzZWxlY3RTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcjIoc3RhdGUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCksIC4uLmFyZ3MpO1xuICAgIH07XG4gIH0sIHtcbiAgICBvcmlnaW5hbFxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29tYmluZWRSZWR1Y2VyLCB7XG4gICAgaW5qZWN0LFxuICAgIHNlbGVjdG9yXG4gIH0pO1xufVxuXG4vLyBzcmMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggVG9vbGtpdCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9FcnJvcnM/Y29kZT0ke2NvZGV9IGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIGA7XG59XG5leHBvcnQge1xuICBSZWR1Y2VyVHlwZSxcbiAgU0hPVUxEX0FVVE9CQVRDSCxcbiAgVGFza0Fib3J0RXJyb3IsXG4gIFR1cGxlLFxuICBhZGRMaXN0ZW5lcixcbiAgYXN5bmNUaHVua0NyZWF0b3IsXG4gIGF1dG9CYXRjaEVuaGFuY2VyLFxuICBidWlsZENyZWF0ZVNsaWNlLFxuICBjbGVhckFsbExpc3RlbmVycyxcbiAgY29tYmluZVNsaWNlcyxcbiAgY29uZmlndXJlU3RvcmUsXG4gIGNyZWF0ZUFjdGlvbixcbiAgY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUFzeW5jVGh1bmssXG4gIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlLFxuICBjcmVhdGVFbnRpdHlBZGFwdGVyLFxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSxcbiAgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsXG4gIGNyZWF0ZVJlZHVjZXIsXG4gIGNyZWF0ZVNlbGVjdG9yLFxuICBjcmVhdGVTZWxlY3RvckNyZWF0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVTbGljZSxcbiAgY3VycmVudDIgYXMgY3VycmVudCxcbiAgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLFxuICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlLFxuICBmcmVlemUsXG4gIGlzQWN0aW9uQ3JlYXRvcixcbiAgaXNBbGxPZixcbiAgaXNBbnlPZixcbiAgaXNBc3luY1RodW5rQWN0aW9uLFxuICBpc0RyYWZ0NCBhcyBpc0RyYWZ0LFxuICBpc0ZTQSBhcyBpc0ZsdXhTdGFuZGFyZEFjdGlvbixcbiAgaXNGdWxmaWxsZWQsXG4gIGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgaXNQZW5kaW5nLFxuICBpc1BsYWluLFxuICBpc1JlamVjdGVkLFxuICBpc1JlamVjdGVkV2l0aFZhbHVlLFxuICBscnVNZW1vaXplLFxuICBtaW5pU2VyaWFsaXplRXJyb3IsXG4gIG5hbm9pZCxcbiAgb3JpZ2luYWwyIGFzIG9yaWdpbmFsLFxuICBwcmVwYXJlQXV0b0JhdGNoZWQsXG4gIHJlbW92ZUxpc3RlbmVyLFxuICB1bndyYXBSZXN1bHQsXG4gIHdlYWtNYXBNZW1vaXplMiBhcyB3ZWFrTWFwTWVtb2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQubGVnYWN5LWVzbS5qcy5tYXAiLCIvLyBUaGlzIG11c3QgcmVtYWluIGhlcmUgc28gdGhhdCB0aGUgYG1hbmdsZUVycm9ycy5janNgIGJ1aWxkIHNjcmlwdFxuLy8gZG9lcyBub3QgaGF2ZSB0byBpbXBvcnQgdGhpcyBpbnRvIGVhY2ggc291cmNlIGZpbGUgaXQgcmV3cml0ZXMuXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlJztcbmV4cG9ydCAqIGZyb20gJ3JlZHV4JztcbmV4cG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLCBjdXJyZW50LCBmcmVlemUsIG9yaWdpbmFsLCBpc0RyYWZ0IH0gZnJvbSAnaW1tZXInO1xuZXhwb3J0IHR5cGUgeyBEcmFmdCB9IGZyb20gJ2ltbWVyJztcbmV4cG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IsIGxydU1lbW9pemUsIHdlYWtNYXBNZW1vaXplIH0gZnJvbSAncmVzZWxlY3QnO1xuZXhwb3J0IHR5cGUgeyBTZWxlY3RvciwgT3V0cHV0U2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCc7XG5leHBvcnQgeyBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yIH0gZnJvbSAnLi9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvcic7XG5leHBvcnQgdHlwZSB7IFRodW5rQWN0aW9uLCBUaHVua0Rpc3BhdGNoLCBUaHVua01pZGRsZXdhcmUgfSBmcm9tICdyZWR1eC10aHVuayc7XG5leHBvcnQgeyAvLyBqc1xuY29uZmlndXJlU3RvcmUgfSBmcm9tICcuL2NvbmZpZ3VyZVN0b3JlJztcbmV4cG9ydCB0eXBlIHsgLy8gdHlwZXNcbkNvbmZpZ3VyZVN0b3JlT3B0aW9ucywgRW5oYW5jZWRTdG9yZSB9IGZyb20gJy4vY29uZmlndXJlU3RvcmUnO1xuZXhwb3J0IHR5cGUgeyBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyB9IGZyb20gJy4vZGV2dG9vbHNFeHRlbnNpb24nO1xuZXhwb3J0IHsgLy8ganNcbmNyZWF0ZUFjdGlvbiwgaXNBY3Rpb25DcmVhdG9yLCBpc0ZTQSBhcyBpc0ZsdXhTdGFuZGFyZEFjdGlvbiB9IGZyb20gJy4vY3JlYXRlQWN0aW9uJztcbmV4cG9ydCB0eXBlIHsgLy8gdHlwZXNcblBheWxvYWRBY3Rpb24sIFBheWxvYWRBY3Rpb25DcmVhdG9yLCBBY3Rpb25DcmVhdG9yV2l0aE5vbkluZmVycmFibGVQYXlsb2FkLCBBY3Rpb25DcmVhdG9yV2l0aE9wdGlvbmFsUGF5bG9hZCwgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkLCBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQsIEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkLCBQcmVwYXJlQWN0aW9uIH0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nO1xuZXhwb3J0IHsgLy8ganNcbmNyZWF0ZVJlZHVjZXIgfSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInO1xuZXhwb3J0IHR5cGUgeyAvLyB0eXBlc1xuQWN0aW9ucywgQ2FzZVJlZHVjZXIsIENhc2VSZWR1Y2VycyB9IGZyb20gJy4vY3JlYXRlUmVkdWNlcic7XG5leHBvcnQgeyAvLyBqc1xuY3JlYXRlU2xpY2UsIGJ1aWxkQ3JlYXRlU2xpY2UsIGFzeW5jVGh1bmtDcmVhdG9yLCBSZWR1Y2VyVHlwZSB9IGZyb20gJy4vY3JlYXRlU2xpY2UnO1xuZXhwb3J0IHR5cGUgeyAvLyB0eXBlc1xuQ3JlYXRlU2xpY2VPcHRpb25zLCBTbGljZSwgQ2FzZVJlZHVjZXJBY3Rpb25zLCBTbGljZUNhc2VSZWR1Y2VycywgVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VycywgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZSwgUmVkdWNlckNyZWF0b3JzLCBTbGljZVNlbGVjdG9ycyB9IGZyb20gJy4vY3JlYXRlU2xpY2UnO1xuZXhwb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmV4cG9ydCB7IGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIH0gZnJvbSAnLi9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSc7XG5leHBvcnQgeyAvLyBqc1xuY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBpc0ltbXV0YWJsZURlZmF1bHQgfSBmcm9tICcuL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSc7XG5leHBvcnQgdHlwZSB7IC8vIHR5cGVzXG5JbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zIH0gZnJvbSAnLi9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuZXhwb3J0IHsgLy8ganNcbmNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSwgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLCBpc1BsYWluIH0gZnJvbSAnLi9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuZXhwb3J0IHR5cGUgeyAvLyB0eXBlc1xuU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyB9IGZyb20gJy4vc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmV4cG9ydCB0eXBlIHsgLy8gdHlwZXNcbkFjdGlvblJlZHVjZXJNYXBCdWlsZGVyIH0gZnJvbSAnLi9tYXBCdWlsZGVycyc7XG5leHBvcnQgeyBUdXBsZSB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHsgY3JlYXRlRW50aXR5QWRhcHRlciB9IGZyb20gJy4vZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXInO1xuZXhwb3J0IHR5cGUgeyBFbnRpdHlTdGF0ZSwgRW50aXR5QWRhcHRlciwgRW50aXR5U2VsZWN0b3JzLCBFbnRpdHlTdGF0ZUFkYXB0ZXIsIEVudGl0eUlkLCBVcGRhdGUsIElkU2VsZWN0b3IsIENvbXBhcmVyIH0gZnJvbSAnLi9lbnRpdGllcy9tb2RlbHMnO1xuZXhwb3J0IHsgY3JlYXRlQXN5bmNUaHVuaywgdW53cmFwUmVzdWx0LCBtaW5pU2VyaWFsaXplRXJyb3IgfSBmcm9tICcuL2NyZWF0ZUFzeW5jVGh1bmsnO1xuZXhwb3J0IHR5cGUgeyBBc3luY1RodW5rLCBBc3luY1RodW5rT3B0aW9ucywgQXN5bmNUaHVua0FjdGlvbiwgQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yUmV0dXJuVmFsdWUsIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvciwgU2VyaWFsaXplZEVycm9yIH0gZnJvbSAnLi9jcmVhdGVBc3luY1RodW5rJztcbmV4cG9ydCB7IC8vIGpzXG5pc0FsbE9mLCBpc0FueU9mLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc0FzeW5jVGh1bmtBY3Rpb24sIGlzUmVqZWN0ZWRXaXRoVmFsdWUgfSBmcm9tICcuL21hdGNoZXJzJztcbmV4cG9ydCB0eXBlIHsgLy8gdHlwZXNcbkFjdGlvbk1hdGNoaW5nQWxsT2YsIEFjdGlvbk1hdGNoaW5nQW55T2YgfSBmcm9tICcuL21hdGNoZXJzJztcbmV4cG9ydCB7IG5hbm9pZCB9IGZyb20gJy4vbmFub2lkJztcbmV4cG9ydCB0eXBlIHsgTGlzdGVuZXJFZmZlY3QsIExpc3RlbmVyTWlkZGxld2FyZSwgTGlzdGVuZXJFZmZlY3RBUEksIExpc3RlbmVyTWlkZGxld2FyZUluc3RhbmNlLCBDcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmVPcHRpb25zLCBMaXN0ZW5lckVycm9ySGFuZGxlciwgVHlwZWRTdGFydExpc3RlbmluZywgVHlwZWRBZGRMaXN0ZW5lciwgVHlwZWRTdG9wTGlzdGVuaW5nLCBUeXBlZFJlbW92ZUxpc3RlbmVyLCBVbnN1YnNjcmliZUxpc3RlbmVyLCBVbnN1YnNjcmliZUxpc3RlbmVyT3B0aW9ucywgRm9ya2VkVGFza0V4ZWN1dG9yLCBGb3JrZWRUYXNrLCBGb3JrZWRUYXNrQVBJLCBBc3luY1Rhc2tFeGVjdXRvciwgU3luY1Rhc2tFeGVjdXRvciwgVGFza0NhbmNlbGxlZCwgVGFza1JlamVjdGVkLCBUYXNrUmVzb2x2ZWQsIFRhc2tSZXN1bHQgfSBmcm9tICcuL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleCc7XG5leHBvcnQgdHlwZSB7IEFueUxpc3RlbmVyUHJlZGljYXRlIH0gZnJvbSAnLi9saXN0ZW5lck1pZGRsZXdhcmUvdHlwZXMnO1xuZXhwb3J0IHsgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlLCBhZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXIsIGNsZWFyQWxsTGlzdGVuZXJzLCBUYXNrQWJvcnRFcnJvciB9IGZyb20gJy4vbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4JztcbmV4cG9ydCB0eXBlIHsgRHluYW1pY01pZGRsZXdhcmVJbnN0YW5jZSwgR2V0RGlzcGF0Y2gsIEdldFN0YXRlLCBNaWRkbGV3YXJlQXBpQ29uZmlnIH0gZnJvbSAnLi9keW5hbWljTWlkZGxld2FyZS90eXBlcyc7XG5leHBvcnQgeyBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSB9IGZyb20gJy4vZHluYW1pY01pZGRsZXdhcmUvaW5kZXgnO1xuZXhwb3J0IHsgU0hPVUxEX0FVVE9CQVRDSCwgcHJlcGFyZUF1dG9CYXRjaGVkLCBhdXRvQmF0Y2hFbmhhbmNlciB9IGZyb20gJy4vYXV0b0JhdGNoRW5oYW5jZXInO1xuZXhwb3J0IHR5cGUgeyBBdXRvQmF0Y2hPcHRpb25zIH0gZnJvbSAnLi9hdXRvQmF0Y2hFbmhhbmNlcic7XG5leHBvcnQgeyBjb21iaW5lU2xpY2VzIH0gZnJvbSAnLi9jb21iaW5lU2xpY2VzJztcbmV4cG9ydCB0eXBlIHsgV2l0aFNsaWNlIH0gZnJvbSAnLi9jb21iaW5lU2xpY2VzJztcbmV4cG9ydCB0eXBlIHsgRXh0cmFjdERpc3BhdGNoRXh0ZW5zaW9ucyBhcyBUU0hlbHBlcnNFeHRyYWN0RGlzcGF0Y2hFeHRlbnNpb25zLCBTYWZlUHJvbWlzZSB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmV4cG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tICcuL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UnOyIsImltcG9ydCB7IGN1cnJlbnQsIGlzRHJhZnQgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsIHdlYWtNYXBNZW1vaXplIH0gZnJvbSAncmVzZWxlY3QnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcjogdHlwZW9mIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAoY3JlYXRlU2VsZWN0b3JDcmVhdG9yIGFzIGFueSkoLi4uYXJncyk7XG4gIGNvbnN0IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczogdW5rbm93bltdKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvciguLi5hcmdzKTtcblxuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9ICh2YWx1ZTogdW5rbm93biwgLi4ucmVzdDogdW5rbm93bltdKSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuXG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVkU2VsZWN0b3IsIHNlbGVjdG9yKTtcbiAgICByZXR1cm4gKHdyYXBwZWRTZWxlY3RvciBhcyBhbnkpO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvclxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yO1xufTtcbi8qKlxuICogXCJEcmFmdC1TYWZlXCIgdmVyc2lvbiBvZiBgcmVzZWxlY3RgJ3MgYGNyZWF0ZVNlbGVjdG9yYDpcbiAqIElmIGFuIGBpbW1lcmAtZHJhZnRlZCBvYmplY3QgaXMgcGFzc2VkIGludG8gdGhlIHJlc3VsdGluZyBzZWxlY3RvcidzIGZpcnN0IGFyZ3VtZW50LFxuICogdGhlIHNlbGVjdG9yIHdpbGwgYWN0IG9uIHRoZSBjdXJyZW50IGRyYWZ0IHZhbHVlLCBpbnN0ZWFkIG9mIHJldHVybmluZyBhIGNhY2hlZCB2YWx1ZVxuICogdGhhdCBtaWdodCBiZSBwb3NzaWJseSBvdXRkYXRlZCBpZiB0aGUgZHJhZnQgaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yKHdlYWtNYXBNZW1vaXplKTsiLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHsgUmVkdWNlciwgUmVkdWNlcnNNYXBPYmplY3QsIE1pZGRsZXdhcmUsIEFjdGlvbiwgU3RvcmVFbmhhbmNlciwgU3RvcmUsIFVua25vd25BY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBhcHBseU1pZGRsZXdhcmUsIGNyZWF0ZVN0b3JlLCBjb21wb3NlLCBjb21iaW5lUmVkdWNlcnMsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IERldlRvb2xzRW5oYW5jZXJPcHRpb25zIGFzIERldlRvb2xzT3B0aW9ucyB9IGZyb20gJy4vZGV2dG9vbHNFeHRlbnNpb24nO1xuaW1wb3J0IHsgY29tcG9zZVdpdGhEZXZUb29scyB9IGZyb20gJy4vZGV2dG9vbHNFeHRlbnNpb24nO1xuaW1wb3J0IHR5cGUgeyBUaHVua01pZGRsZXdhcmVGb3IsIEdldERlZmF1bHRNaWRkbGV3YXJlIH0gZnJvbSAnLi9nZXREZWZhdWx0TWlkZGxld2FyZSc7XG5pbXBvcnQgeyBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlIH0gZnJvbSAnLi9nZXREZWZhdWx0TWlkZGxld2FyZSc7XG5pbXBvcnQgdHlwZSB7IEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnMsIEV4dHJhY3RTdG9yZUV4dGVuc2lvbnMsIEV4dHJhY3RTdGF0ZUV4dGVuc2lvbnMsIFVua25vd25JZk5vblNwZWNpZmljIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHR5cGUgeyBUdXBsZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBHZXREZWZhdWx0RW5oYW5jZXJzIH0gZnJvbSAnLi9nZXREZWZhdWx0RW5oYW5jZXJzJztcbmltcG9ydCB7IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyB9IGZyb20gJy4vZ2V0RGVmYXVsdEVuaGFuY2Vycyc7XG5jb25zdCBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbi8qKlxuICogT3B0aW9ucyBmb3IgYGNvbmZpZ3VyZVN0b3JlKClgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ3VyZVN0b3JlT3B0aW9uczxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbiwgTSBleHRlbmRzIFR1cGxlPE1pZGRsZXdhcmVzPFM+PiA9IFR1cGxlPE1pZGRsZXdhcmVzPFM+PiwgRSBleHRlbmRzIFR1cGxlPEVuaGFuY2Vycz4gPSBUdXBsZTxFbmhhbmNlcnM+LCBQID0gUz4ge1xuICAvKipcbiAgICogQSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcm9vdCByZWR1Y2VyLCBvciBhblxuICAgKiBvYmplY3Qgb2Ygc2xpY2UgcmVkdWNlcnMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBgY29tYmluZVJlZHVjZXJzKClgLlxuICAgKi9cbiAgcmVkdWNlcjogUmVkdWNlcjxTLCBBLCBQPiB8IFJlZHVjZXJzTWFwT2JqZWN0PFMsIEEsIFA+O1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgUmVkdXggbWlkZGxld2FyZSB0byBpbnN0YWxsLCBvciBhIGNhbGxiYWNrIHJlY2VpdmluZyBgZ2V0RGVmYXVsdE1pZGRsZXdhcmVgIGFuZCByZXR1cm5pbmcgYSBUdXBsZSBvZiBtaWRkbGV3YXJlLlxuICAgKiBJZiBub3Qgc3VwcGxpZWQsIGRlZmF1bHRzIHRvIHRoZSBzZXQgb2YgbWlkZGxld2FyZSByZXR1cm5lZCBieSBgZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKWAuXG4gICAqXG4gICAqIEBleGFtcGxlIGBtaWRkbGV3YXJlOiAoZ0RNKSA9PiBnRE0oKS5jb25jYXQobG9nZ2VyLCBhcGlNaWRkbGV3YXJlLCB5b3VyQ3VzdG9tTWlkZGxld2FyZSlgXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUjaW50ZW5kZWQtdXNhZ2VcbiAgICovXG5cbiAgbWlkZGxld2FyZT86IChnZXREZWZhdWx0TWlkZGxld2FyZTogR2V0RGVmYXVsdE1pZGRsZXdhcmU8Uz4pID0+IE07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBSZWR1eCBEZXZUb29scyBpbnRlZ3JhdGlvbi4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKlxuICAgKiBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gY2FuIGJlIGRvbmUgYnkgcGFzc2luZyBSZWR1eCBEZXZUb29scyBvcHRpb25zXG4gICAqL1xuXG4gIGRldlRvb2xzPzogYm9vbGVhbiB8IERldlRvb2xzT3B0aW9ucztcbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHN0YXRlLCBzYW1lIGFzIFJlZHV4J3MgY3JlYXRlU3RvcmUuXG4gICAqIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0IHRvIGh5ZHJhdGUgdGhlIHN0YXRlXG4gICAqIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhIHByZXZpb3VzbHkgc2VyaWFsaXplZFxuICAgKiB1c2VyIHNlc3Npb24uIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2VycygpYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXJcbiAgICogZnVuY3Rpb24gKGVpdGhlciBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGJ5IHBhc3NpbmcgYW4gb2JqZWN0IGFzIGByZWR1Y2VyYCksXG4gICAqIHRoaXMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgcmVkdWNlciBtYXAga2V5cy5cbiAgICovXG4gIC8vIHdlIGluZmVyIGhlcmUsIGFuZCBpbnN0ZWFkIGNvbXBsYWluIGlmIHRoZSByZWR1Y2VyIGRvZXNuJ3QgbWF0Y2hcblxuICBwcmVsb2FkZWRTdGF0ZT86IFA7XG4gIC8qKlxuICAgKiBUaGUgc3RvcmUgZW5oYW5jZXJzIHRvIGFwcGx5LiBTZWUgUmVkdXgncyBgY3JlYXRlU3RvcmUoKWAuXG4gICAqIEFsbCBlbmhhbmNlcnMgd2lsbCBiZSBpbmNsdWRlZCBiZWZvcmUgdGhlIERldlRvb2xzIEV4dGVuc2lvbiBlbmhhbmNlci5cbiAgICogSWYgeW91IG5lZWQgdG8gY3VzdG9taXplIHRoZSBvcmRlciBvZiBlbmhhbmNlcnMsIHN1cHBseSBhIGNhbGxiYWNrXG4gICAqIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWNlaXZlIGEgYGdldERlZmF1bHRFbmhhbmNlcnNgIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFR1cGxlLFxuICAgKiBhbmQgc2hvdWxkIHJldHVybiBhIFR1cGxlIG9mIGVuaGFuY2VycyAoc3VjaCBhcyBgZ2V0RGVmYXVsdEVuaGFuY2VycygpLmNvbmNhdChvZmZsaW5lKWApLlxuICAgKiBJZiB5b3Ugb25seSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlLCB5b3UgY2FuIHVzZSB0aGUgYG1pZGRsZXdhcmVgIHBhcmFtZXRlciBpbnN0ZWFkLlxuICAgKi9cblxuICBlbmhhbmNlcnM/OiAoZ2V0RGVmYXVsdEVuaGFuY2VyczogR2V0RGVmYXVsdEVuaGFuY2VyczxNPikgPT4gRTtcbn1cbmV4cG9ydCB0eXBlIE1pZGRsZXdhcmVzPFM+ID0gUmVhZG9ubHlBcnJheTxNaWRkbGV3YXJlPHt9LCBTPj47XG50eXBlIEVuaGFuY2VycyA9IFJlYWRvbmx5QXJyYXk8U3RvcmVFbmhhbmNlcj47XG4vKipcbiAqIEEgUmVkdXggc3RvcmUgcmV0dXJuZWQgYnkgYGNvbmZpZ3VyZVN0b3JlKClgLiBTdXBwb3J0cyBkaXNwYXRjaGluZ1xuICogc2lkZS1lZmZlY3RmdWwgX3RodW5rc18gaW4gYWRkaXRpb24gdG8gcGxhaW4gYWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgRW5oYW5jZWRTdG9yZTxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbiwgRSBleHRlbmRzIEVuaGFuY2VycyA9IEVuaGFuY2Vycz4gPSBFeHRyYWN0U3RvcmVFeHRlbnNpb25zPEU+ICYgU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8RXh0cmFjdFN0YXRlRXh0ZW5zaW9uczxFPj4+O1xuLyoqXG4gKiBBIGZyaWVuZGx5IGFic3RyYWN0aW9uIG92ZXIgdGhlIHN0YW5kYXJkIFJlZHV4IGBjcmVhdGVTdG9yZSgpYCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgc3RvcmUgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIEEgY29uZmlndXJlZCBSZWR1eCBzdG9yZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlPFMgPSBhbnksIEEgZXh0ZW5kcyBBY3Rpb24gPSBVbmtub3duQWN0aW9uLCBNIGV4dGVuZHMgVHVwbGU8TWlkZGxld2FyZXM8Uz4+ID0gVHVwbGU8W1RodW5rTWlkZGxld2FyZUZvcjxTPl0+LCBFIGV4dGVuZHMgVHVwbGU8RW5oYW5jZXJzPiA9IFR1cGxlPFtTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnM8TT47XG59PiwgU3RvcmVFbmhhbmNlcl0+LCBQID0gUz4ob3B0aW9uczogQ29uZmlndXJlU3RvcmVPcHRpb25zPFMsIEEsIE0sIEUsIFA+KTogRW5oYW5jZWRTdG9yZTxTLCBBLCBFPiB7XG4gIGNvbnN0IGdldERlZmF1bHRNaWRkbGV3YXJlID0gYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZTxTPigpO1xuICBjb25zdCB7XG4gICAgcmVkdWNlciA9IHVuZGVmaW5lZCxcbiAgICBtaWRkbGV3YXJlLFxuICAgIGRldlRvb2xzID0gdHJ1ZSxcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZCxcbiAgICBlbmhhbmNlcnMgPSB1bmRlZmluZWRcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGxldCByb290UmVkdWNlcjogUmVkdWNlcjxTLCBBLCBQPjtcblxuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByb290UmVkdWNlciA9IHJlZHVjZXI7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xuICAgIHJvb3RSZWR1Y2VyID0gKChjb21iaW5lUmVkdWNlcnMocmVkdWNlcikgYXMgdW5rbm93bikgYXMgUmVkdWNlcjxTLCBBLCBQPik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogJ2ByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xuICB9XG5cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDIpIDogJ2BtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGxldCBmaW5hbE1pZGRsZXdhcmU6IFR1cGxlPE1pZGRsZXdhcmVzPFM+PjtcblxuICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcblxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDMpIDogJ3doZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG5cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5zb21lKChpdGVtOiBhbnkpID0+IHR5cGVvZiBpdGVtICE9PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQoNCkgOiAnZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2U7XG5cbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxuICAgICAgLi4uKHR5cGVvZiBkZXZUb29scyA9PT0gJ29iamVjdCcgJiYgZGV2VG9vbHMpXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoLi4uZmluYWxNaWRkbGV3YXJlKTtcbiAgY29uc3QgZ2V0RGVmYXVsdEVuaGFuY2VycyA9IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VyczxNPihtaWRkbGV3YXJlRW5oYW5jZXIpO1xuXG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBlbmhhbmNlcnMgJiYgdHlwZW9mIGVuaGFuY2VycyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTUoNSkgOiAnYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgc3RvcmVFbmhhbmNlcnMgPSB0eXBlb2YgZW5oYW5jZXJzID09PSAnZnVuY3Rpb24nID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuXG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiAhQXJyYXkuaXNBcnJheShzdG9yZUVuaGFuY2VycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2KDYpIDogJ2BlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5Jyk7XG4gIH1cblxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbTogYW55KSA9PiB0eXBlb2YgaXRlbSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U3KDcpIDogJ2VhY2ggZW5oYW5jZXIgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ21pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgJyk7XG4gIH1cblxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyOiBTdG9yZUVuaGFuY2VyPGFueT4gPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpO1xuICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIChwcmVsb2FkZWRTdGF0ZSBhcyBQKSwgY29tcG9zZWRFbmhhbmNlcik7XG59IiwiaW1wb3J0IHR5cGUgeyBBY3Rpb24sIEFjdGlvbkNyZWF0b3IsIFN0b3JlRW5oYW5jZXIgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAncmVkdXgnO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiB0aGUgaW5zdGFuY2UgbmFtZSB0byBiZSBzaG93ZWQgb24gdGhlIG1vbml0b3IgcGFnZS4gRGVmYXVsdCB2YWx1ZSBpcyBgZG9jdW1lbnQudGl0bGVgLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkIGFuZCB0aGVyZSdzIG5vIGRvY3VtZW50IHRpdGxlLCBpdCB3aWxsIGNvbnNpc3Qgb2YgYHRhYklkYCBhbmQgYGluc3RhbmNlSWRgLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIGFjdGlvbiBjcmVhdG9ycyBmdW5jdGlvbnMgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBEaXNwYXRjaGVyLlxuICAgKi9cblxuICBhY3Rpb25DcmVhdG9ycz86IEFjdGlvbkNyZWF0b3I8YW55PltdIHwge1xuICAgIFtrZXk6IHN0cmluZ106IEFjdGlvbkNyZWF0b3I8YW55PjtcbiAgfTtcbiAgLyoqXG4gICAqIGlmIG1vcmUgdGhhbiBvbmUgYWN0aW9uIGlzIGRpc3BhdGNoZWQgaW4gdGhlIGluZGljYXRlZCBpbnRlcnZhbCwgYWxsIG5ldyBhY3Rpb25zIHdpbGwgYmUgY29sbGVjdGVkIGFuZCBzZW50IGF0IG9uY2UuXG4gICAqIEl0IGlzIHRoZSBqb2ludCBiZXR3ZWVuIHBlcmZvcm1hbmNlIGFuZCBzcGVlZC4gV2hlbiBzZXQgdG8gYDBgLCBhbGwgYWN0aW9ucyB3aWxsIGJlIHNlbnQgaW5zdGFudGx5LlxuICAgKiBTZXQgaXQgdG8gYSBoaWdoZXIgdmFsdWUgd2hlbiBleHBlcmllbmNpbmcgcGVyZiBpc3N1ZXMgKGFsc28gYG1heEFnZWAgdG8gYSBsb3dlciB2YWx1ZSkuXG4gICAqXG4gICAqIEBkZWZhdWx0IDUwMCBtcy5cbiAgICovXG5cbiAgbGF0ZW5jeT86IG51bWJlcjtcbiAgLyoqXG4gICAqICg+IDEpIC0gbWF4aW11bSBhbGxvd2VkIGFjdGlvbnMgdG8gYmUgc3RvcmVkIGluIHRoZSBoaXN0b3J5IHRyZWUuIFRoZSBvbGRlc3QgYWN0aW9ucyBhcmUgcmVtb3ZlZCBvbmNlIG1heEFnZSBpcyByZWFjaGVkLiBJdCdzIGNyaXRpY2FsIGZvciBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogQGRlZmF1bHQgNTBcbiAgICovXG5cbiAgbWF4QWdlPzogbnVtYmVyO1xuICAvKipcbiAgICogQ3VzdG9taXplcyBob3cgYWN0aW9ucyBhbmQgc3RhdGUgYXJlIHNlcmlhbGl6ZWQgYW5kIGRlc2VyaWFsaXplZC4gQ2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3QuIElmIGdpdmVuIGEgYm9vbGVhbiwgdGhlIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGlmIHlvdVxuICAgKiB3ZXJlIHRvIHBhc3MgYW4gb2JqZWN0IGFuZCBzcGVjaWZ5IGBvcHRpb25zYCBhcyBhIGJvb2xlYW4uIEdpdmluZyBhbiBvYmplY3QgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjdXN0b21pemF0aW9uIHVzaW5nIHRoZSBgcmVwbGFjZXJgIGFuZCBgcmV2aXZlcmBcbiAgICogZnVuY3Rpb25zLlxuICAgKi9cblxuICBzZXJpYWxpemU/OiBib29sZWFuIHwge1xuICAgIC8qKlxuICAgICAqIC0gYHVuZGVmaW5lZGAgLSB3aWxsIHVzZSByZWd1bGFyIGBKU09OLnN0cmluZ2lmeWAgdG8gc2VuZCBkYXRhIChpdCdzIHRoZSBmYXN0IG1vZGUpLlxuICAgICAqIC0gYGZhbHNlYCAtIHdpbGwgaGFuZGxlIGFsc28gY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICAgKiAtIGB0cnVlYCAtIHdpbGwgaGFuZGxlIGFsc28gZGF0ZSwgcmVnZXgsIHVuZGVmaW5lZCwgZXJyb3Igb2JqZWN0cywgc3ltYm9scywgbWFwcywgc2V0cyBhbmQgZnVuY3Rpb25zLlxuICAgICAqIC0gb2JqZWN0LCB3aGljaCBjb250YWlucyBgZGF0ZWAsIGByZWdleGAsIGB1bmRlZmluZWRgLCBgZXJyb3JgLCBgc3ltYm9sYCwgYG1hcGAsIGBzZXRgIGFuZCBgZnVuY3Rpb25gIGtleXMuXG4gICAgICogICBGb3IgZWFjaCBvZiB0aGVtIHlvdSBjYW4gaW5kaWNhdGUgaWYgdG8gaW5jbHVkZSAoYnkgc2V0dGluZyBhcyBgdHJ1ZWApLlxuICAgICAqICAgRm9yIGBmdW5jdGlvbmAga2V5IHlvdSBjYW4gYWxzbyBzcGVjaWZ5IGEgY3VzdG9tIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgc2VyaWFsaXphdGlvbi5cbiAgICAgKiAgIFNlZSBbYGpzYW5gXShodHRwczovL2dpdGh1Yi5jb20va29sb2RueS9qc2FuKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIG9wdGlvbnM/OiB1bmRlZmluZWQgfCBib29sZWFuIHwge1xuICAgICAgZGF0ZT86IHRydWU7XG4gICAgICByZWdleD86IHRydWU7XG4gICAgICB1bmRlZmluZWQ/OiB0cnVlO1xuICAgICAgZXJyb3I/OiB0cnVlO1xuICAgICAgc3ltYm9sPzogdHJ1ZTtcbiAgICAgIG1hcD86IHRydWU7XG4gICAgICBzZXQ/OiB0cnVlO1xuICAgICAgZnVuY3Rpb24/OiB0cnVlIHwgKChmbjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID0+IHN0cmluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbSlNPTiByZXBsYWNlciBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjVGhlX3JlcGxhY2VyX3BhcmFtZXRlcikgdXNlZCBmb3IgYm90aCBhY3Rpb25zIGFuZCBzdGF0ZXMgc3RyaW5naWZ5LlxuICAgICAqIEluIGFkZGl0aW9uLCB5b3UgY2FuIHNwZWNpZnkgYSBkYXRhIHR5cGUgYnkgYWRkaW5nIGEgW2BfX3NlcmlhbGl6ZWRUeXBlX19gXShodHRwczovL2dpdGh1Yi5jb20vemFsbW94aXN1cy9yZW1vdGVkZXYtc2VyaWFsaXplL2Jsb2IvbWFzdGVyL2hlbHBlcnMvaW5kZXguanMjTDQpXG4gICAgICoga2V5LiBTbyB5b3UgY2FuIGRlc2VyaWFsaXplIGl0IGJhY2sgd2hpbGUgaW1wb3J0aW5nIG9yIHBlcnNpc3RpbmcgZGF0YS5cbiAgICAgKiBNb3Jlb3ZlciwgaXQgd2lsbCBhbHNvIFtzaG93IGEgbmljZSBwcmV2aWV3IHNob3dpbmcgdGhlIHByb3ZpZGVkIGN1c3RvbSB0eXBlXShodHRwczovL2Nsb3VkLmdpdGh1YnVzZXJjb250ZW50LmNvbS9hc3NldHMvNzk1Nzg1OS8yMTgxNDMzMC9hMTdkNTU2YS1kNzYxLTExZTYtODVlZi0xNTlkZDEyZjM2YzUucG5nKTpcbiAgICAgKi9cblxuICAgIHJlcGxhY2VyPzogKGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gYW55O1xuICAgIC8qKlxuICAgICAqIFtKU09OIGByZXZpdmVyYCBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9wYXJzZSNVc2luZ190aGVfcmV2aXZlcl9wYXJhbWV0ZXIpXG4gICAgICogdXNlZCBmb3IgcGFyc2luZyB0aGUgaW1wb3J0ZWQgYWN0aW9ucyBhbmQgc3RhdGVzLiBTZWUgW2ByZW1vdGVkZXYtc2VyaWFsaXplYF0oaHR0cHM6Ly9naXRodWIuY29tL3phbG1veGlzdXMvcmVtb3RlZGV2LXNlcmlhbGl6ZS9ibG9iL21hc3Rlci9pbW11dGFibGUvc2VyaWFsaXplLmpzI0w4LUw0MSlcbiAgICAgKiBhcyBhbiBleGFtcGxlIG9uIGhvdyB0byBzZXJpYWxpemUgc3BlY2lhbCBkYXRhIHR5cGVzIGFuZCBnZXQgdGhlbSBiYWNrLlxuICAgICAqL1xuXG4gICAgcmV2aXZlcj86IChrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pID0+IGFueTtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBpbW11dGFibGVqcyB2aWEgW3JlbW90ZWRldi1zZXJpYWxpemVdKGh0dHBzOi8vZ2l0aHViLmNvbS96YWxtb3hpc3VzL3JlbW90ZWRldi1zZXJpYWxpemUpLlxuICAgICAqIEp1c3QgcGFzcyB0aGUgSW1tdXRhYmxlIGxpYnJhcnkuIEl0IHdpbGwgc3VwcG9ydCBhbGwgSW1tdXRhYmxlSlMgc3RydWN0dXJlcy4gWW91IGNhbiBldmVuIGV4cG9ydCB0aGVtIGludG8gYSBmaWxlIGFuZCBnZXQgdGhlbSBiYWNrLlxuICAgICAqIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBgUmVjb3JkYCBjbGFzcywgZm9yIHdoaWNoIHlvdSBzaG91bGQgcGFzcyB0aGlzIGluIGFkZGl0aW9uIHRoZSByZWZlcmVuY2VzIHRvIHlvdXIgY2xhc3NlcyBpbiBgcmVmc2AuXG4gICAgICovXG5cbiAgICBpbW11dGFibGU/OiBhbnk7XG4gICAgLyoqXG4gICAgICogSW1tdXRhYmxlSlMgYFJlY29yZGAgY2xhc3NlcyB1c2VkIHRvIG1ha2UgcG9zc2libGUgcmVzdG9yZSBpdHMgaW5zdGFuY2VzIGJhY2sgd2hlbiBpbXBvcnRpbmcsIHBlcnNpc3RpbmcuLi5cbiAgICAgKi9cblxuICAgIHJlZnM/OiBhbnk7XG4gIH07XG4gIC8qKlxuICAgKiBmdW5jdGlvbiB3aGljaCB0YWtlcyBgYWN0aW9uYCBvYmplY3QgYW5kIGlkIG51bWJlciBhcyBhcmd1bWVudHMsIGFuZCBzaG91bGQgcmV0dXJuIGBhY3Rpb25gIG9iamVjdCBiYWNrLlxuICAgKi9cblxuICBhY3Rpb25TYW5pdGl6ZXI/OiA8QSBleHRlbmRzIEFjdGlvbj4oYWN0aW9uOiBBLCBpZDogbnVtYmVyKSA9PiBBO1xuICAvKipcbiAgICogZnVuY3Rpb24gd2hpY2ggdGFrZXMgYHN0YXRlYCBvYmplY3QgYW5kIGluZGV4IGFzIGFyZ3VtZW50cywgYW5kIHNob3VsZCByZXR1cm4gYHN0YXRlYCBvYmplY3QgYmFjay5cbiAgICovXG5cbiAgc3RhdGVTYW5pdGl6ZXI/OiA8Uz4oc3RhdGU6IFMsIGluZGV4OiBudW1iZXIpID0+IFM7XG4gIC8qKlxuICAgKiAqc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgYXMgcmVnZXgqIC0gYWN0aW9ucyB0eXBlcyB0byBiZSBoaWRkZW4gLyBzaG93biBpbiB0aGUgbW9uaXRvcnMgKHdoaWxlIHBhc3NlZCB0byB0aGUgcmVkdWNlcnMpLlxuICAgKiBJZiBgYWN0aW9uc0FsbG93bGlzdGAgc3BlY2lmaWVkLCBgYWN0aW9uc0RlbnlsaXN0YCBpcyBpZ25vcmVkLlxuICAgKi9cblxuICBhY3Rpb25zRGVueWxpc3Q/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgLyoqXG4gICAqICpzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBhcyByZWdleCogLSBhY3Rpb25zIHR5cGVzIHRvIGJlIGhpZGRlbiAvIHNob3duIGluIHRoZSBtb25pdG9ycyAod2hpbGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VycykuXG4gICAqIElmIGBhY3Rpb25zQWxsb3dsaXN0YCBzcGVjaWZpZWQsIGBhY3Rpb25zRGVueWxpc3RgIGlzIGlnbm9yZWQuXG4gICAqL1xuXG4gIGFjdGlvbnNBbGxvd2xpc3Q/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgLyoqXG4gICAqIGNhbGxlZCBmb3IgZXZlcnkgYWN0aW9uIGJlZm9yZSBzZW5kaW5nLCB0YWtlcyBgc3RhdGVgIGFuZCBgYWN0aW9uYCBvYmplY3QsIGFuZCByZXR1cm5zIGB0cnVlYCBpbiBjYXNlIGl0IGFsbG93cyBzZW5kaW5nIHRoZSBjdXJyZW50IGRhdGEgdG8gdGhlIG1vbml0b3IuXG4gICAqIFVzZSBpdCBhcyBhIG1vcmUgYWR2YW5jZWQgdmVyc2lvbiBvZiBgYWN0aW9uc0RlbnlsaXN0YC9gYWN0aW9uc0FsbG93bGlzdGAgcGFyYW1ldGVycy5cbiAgICovXG5cbiAgcHJlZGljYXRlPzogPFMsIEEgZXh0ZW5kcyBBY3Rpb24+KHN0YXRlOiBTLCBhY3Rpb246IEEpID0+IGJvb2xlYW47XG4gIC8qKlxuICAgKiBpZiBzcGVjaWZpZWQgYXMgYGZhbHNlYCwgaXQgd2lsbCBub3QgcmVjb3JkIHRoZSBjaGFuZ2VzIHRpbGwgY2xpY2tpbmcgb24gYFN0YXJ0IHJlY29yZGluZ2AgYnV0dG9uLlxuICAgKiBBdmFpbGFibGUgb25seSBmb3IgUmVkdXggZW5oYW5jZXIsIGZvciBvdGhlcnMgdXNlIGBhdXRvUGF1c2VgLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuXG4gIHNob3VsZFJlY29yZENoYW5nZXM/OiBib29sZWFuO1xuICAvKipcbiAgICogaWYgc3BlY2lmaWVkLCB3aGVuZXZlciBjbGlja2luZyBvbiBgUGF1c2UgcmVjb3JkaW5nYCBidXR0b24gYW5kIHRoZXJlIGFyZSBhY3Rpb25zIGluIHRoZSBoaXN0b3J5IGxvZywgd2lsbCBhZGQgdGhpcyBhY3Rpb24gdHlwZS5cbiAgICogSWYgbm90IHNwZWNpZmllZCwgd2lsbCBjb21taXQgd2hlbiBwYXVzZWQuIEF2YWlsYWJsZSBvbmx5IGZvciBSZWR1eCBlbmhhbmNlci5cbiAgICpcbiAgICogQGRlZmF1bHQgXCJAQFBBVVNFRFwiXCJcbiAgICovXG5cbiAgcGF1c2VBY3Rpb25UeXBlPzogc3RyaW5nO1xuICAvKipcbiAgICogYXV0byBwYXVzZXMgd2hlbiB0aGUgZXh0ZW5zaW9u4oCZcyB3aW5kb3cgaXMgbm90IG9wZW5lZCwgYW5kIHNvIGhhcyB6ZXJvIGltcGFjdCBvbiB5b3VyIGFwcCB3aGVuIG5vdCBpbiB1c2UuXG4gICAqIE5vdCBhdmFpbGFibGUgZm9yIFJlZHV4IGVuaGFuY2VyIChhcyBpdCBhbHJlYWR5IGRvZXMgaXQgYnV0IHN0b3JpbmcgdGhlIGRhdGEgdG8gYmUgc2VudCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuXG4gIGF1dG9QYXVzZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBpZiBzcGVjaWZpZWQgYXMgYHRydWVgLCBpdCB3aWxsIG5vdCBhbGxvdyBhbnkgbm9uLW1vbml0b3IgYWN0aW9ucyB0byBiZSBkaXNwYXRjaGVkIHRpbGwgY2xpY2tpbmcgb24gYFVubG9jayBjaGFuZ2VzYCBidXR0b24uXG4gICAqIEF2YWlsYWJsZSBvbmx5IGZvciBSZWR1eCBlbmhhbmNlci5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG5cbiAgc2hvdWxkU3RhcnRMb2NrZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogaWYgc2V0IHRvIGBmYWxzZWAsIHdpbGwgbm90IHJlY29tcHV0ZSB0aGUgc3RhdGVzIG9uIGhvdCByZWxvYWRpbmcgKG9yIG9uIHJlcGxhY2luZyB0aGUgcmVkdWNlcnMpLiBBdmFpbGFibGUgb25seSBmb3IgUmVkdXggZW5oYW5jZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG5cbiAgc2hvdWxkSG90UmVsb2FkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIGlmIHNwZWNpZmllZCBhcyBgdHJ1ZWAsIHdoZW5ldmVyIHRoZXJlJ3MgYW4gZXhjZXB0aW9uIGluIHJlZHVjZXJzLCB0aGUgbW9uaXRvcnMgd2lsbCBzaG93IHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgbmV4dCBhY3Rpb25zIHdpbGwgbm90IGJlIGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuXG4gIHNob3VsZENhdGNoRXJyb3JzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElmIHlvdSB3YW50IHRvIHJlc3RyaWN0IHRoZSBleHRlbnNpb24sIHNwZWNpZnkgdGhlIGZlYXR1cmVzIHlvdSBhbGxvdy5cbiAgICogSWYgbm90IHNwZWNpZmllZCwgYWxsIG9mIHRoZSBmZWF0dXJlcyBhcmUgZW5hYmxlZC4gV2hlbiBzZXQgYXMgYW4gb2JqZWN0LCBvbmx5IHRob3NlIGluY2x1ZGVkIGFzIGB0cnVlYCB3aWxsIGJlIGFsbG93ZWQuXG4gICAqIE5vdGUgdGhhdCBleGNlcHQgYHRydWVgL2BmYWxzZWAsIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBjYW4gYmUgc2V0IGFzIGBjdXN0b21gICh3aGljaCBpcyBieSBkZWZhdWx0IGZvciBSZWR1eCBlbmhhbmNlciksIG1lYW5pbmcgdGhhdCB0aGUgaW1wb3J0aW5nL2V4cG9ydGluZyBvY2N1cnMgb24gdGhlIGNsaWVudCBzaWRlLlxuICAgKiBPdGhlcndpc2UsIHlvdSdsbCBnZXQvc2V0IHRoZSBkYXRhIHJpZ2h0IGZyb20gdGhlIG1vbml0b3IgcGFydC5cbiAgICovXG5cbiAgZmVhdHVyZXM/OiB7XG4gICAgLyoqXG4gICAgICogc3RhcnQvcGF1c2UgcmVjb3JkaW5nIG9mIGRpc3BhdGNoZWQgYWN0aW9uc1xuICAgICAqL1xuICAgIHBhdXNlPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBsb2NrL3VubG9jayBkaXNwYXRjaGluZyBhY3Rpb25zIGFuZCBzaWRlIGVmZmVjdHNcbiAgICAgKi9cblxuICAgIGxvY2s/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIHBlcnNpc3Qgc3RhdGVzIG9uIHBhZ2UgcmVsb2FkaW5nXG4gICAgICovXG5cbiAgICBwZXJzaXN0PzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBleHBvcnQgaGlzdG9yeSBvZiBhY3Rpb25zIGluIGEgZmlsZVxuICAgICAqL1xuXG4gICAgZXhwb3J0PzogYm9vbGVhbiB8ICdjdXN0b20nO1xuICAgIC8qKlxuICAgICAqIGltcG9ydCBoaXN0b3J5IG9mIGFjdGlvbnMgZnJvbSBhIGZpbGVcbiAgICAgKi9cblxuICAgIGltcG9ydD86IGJvb2xlYW4gfCAnY3VzdG9tJztcbiAgICAvKipcbiAgICAgKiBqdW1wIGJhY2sgYW5kIGZvcnRoICh0aW1lIHRyYXZlbGxpbmcpXG4gICAgICovXG5cbiAgICBqdW1wPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBza2lwIChjYW5jZWwpIGFjdGlvbnNcbiAgICAgKi9cblxuICAgIHNraXA/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIGRyYWcgYW5kIGRyb3AgYWN0aW9ucyBpbiB0aGUgaGlzdG9yeSBsaXN0XG4gICAgICovXG5cbiAgICByZW9yZGVyPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBkaXNwYXRjaCBjdXN0b20gYWN0aW9ucyBvciBhY3Rpb24gY3JlYXRvcnNcbiAgICAgKi9cblxuICAgIGRpc3BhdGNoPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0ZXN0cyBmb3IgdGhlIHNlbGVjdGVkIGFjdGlvbnNcbiAgICAgKi9cblxuICAgIHRlc3Q/OiBib29sZWFuO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRvIHRydWUgb3IgYSBzdGFja3RyYWNlLXJldHVybmluZyBmdW5jdGlvbiB0byByZWNvcmQgY2FsbCBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgYWN0aW9ucy5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuXG4gIHRyYWNlPzogYm9vbGVhbiB8ICg8QSBleHRlbmRzIEFjdGlvbj4oYWN0aW9uOiBBKSA9PiBzdHJpbmcpO1xuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YWNrIHRyYWNlIGVudHJpZXMgdG8gcmVjb3JkIHBlciBhY3Rpb24uIERlZmF1bHRzIHRvIDEwLlxuICAgKi9cblxuICB0cmFjZUxpbWl0PzogbnVtYmVyO1xufVxudHlwZSBDb21wb3NlID0gdHlwZW9mIGNvbXBvc2U7XG5pbnRlcmZhY2UgQ29tcG9zZVdpdGhEZXZUb29scyB7XG4gIChvcHRpb25zOiBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyk6IENvbXBvc2U7XG4gIDxTdG9yZUV4dCBleHRlbmRzIHt9PiguLi5mdW5jczogU3RvcmVFbmhhbmNlcjxTdG9yZUV4dD5bXSk6IFN0b3JlRW5oYW5jZXI8U3RvcmVFeHQ+O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNvbXBvc2VXaXRoRGV2VG9vbHM6IENvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gKHdpbmRvdyBhcyBhbnkpLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JykgcmV0dXJuIGNvbXBvc2U7XG4gIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsICgoYXJndW1lbnRzIGFzIGFueSkgYXMgRnVuY3Rpb25bXSkpO1xufTtcbi8qKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBjb25zdCBkZXZUb29sc0VuaGFuY2VyOiB7XG4gIChvcHRpb25zOiBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyk6IFN0b3JlRW5oYW5jZXI8YW55Pjtcbn0gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/ICh3aW5kb3cgYXMgYW55KS5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vb3ApIHtcbiAgICByZXR1cm4gbm9vcDtcbiAgfTtcbn07IiwiaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHR5cGUgeyBUaHVua01pZGRsZXdhcmUgfSBmcm9tICdyZWR1eC10aHVuayc7XG5pbXBvcnQgeyB0aHVuayBhcyB0aHVua01pZGRsZXdhcmUsIHdpdGhFeHRyYUFyZ3VtZW50IH0gZnJvbSAncmVkdXgtdGh1bmsnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIH0gZnJvbSAnLi9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSc7XG5pbXBvcnQgdHlwZSB7IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSc7XG4vKiBQUk9EX1NUQVJUX1JFTU9WRV9VTUQgKi9cblxuaW1wb3J0IHsgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIH0gZnJvbSAnLi9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuLyogUFJPRF9TVE9QX1JFTU9WRV9VTUQgKi9cblxuaW1wb3J0IHR5cGUgeyBTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zIH0gZnJvbSAnLi9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIH0gZnJvbSAnLi9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuaW1wb3J0IHR5cGUgeyBFeGNsdWRlRnJvbVR1cGxlIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHsgVHVwbGUgfSBmcm9tICcuL3V0aWxzJztcblxuZnVuY3Rpb24gaXNCb29sZWFuKHg6IGFueSk6IHggaXMgYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5pbnRlcmZhY2UgVGh1bmtPcHRpb25zPEUgPSBhbnk+IHtcbiAgZXh0cmFBcmd1bWVudDogRTtcbn1cbmludGVyZmFjZSBHZXREZWZhdWx0TWlkZGxld2FyZU9wdGlvbnMge1xuICB0aHVuaz86IGJvb2xlYW4gfCBUaHVua09wdGlvbnM7XG4gIGltbXV0YWJsZUNoZWNrPzogYm9vbGVhbiB8IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnM7XG4gIHNlcmlhbGl6YWJsZUNoZWNrPzogYm9vbGVhbiB8IFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnM7XG4gIGFjdGlvbkNyZWF0b3JDaGVjaz86IGJvb2xlYW4gfCBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnM7XG59XG5leHBvcnQgdHlwZSBUaHVua01pZGRsZXdhcmVGb3I8UywgTyBleHRlbmRzIEdldERlZmF1bHRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9PiA9IE8gZXh0ZW5kcyB7XG4gIHRodW5rOiBmYWxzZTtcbn0gPyBuZXZlciA6IE8gZXh0ZW5kcyB7XG4gIHRodW5rOiB7XG4gICAgZXh0cmFBcmd1bWVudDogaW5mZXIgRTtcbiAgfTtcbn0gPyBUaHVua01pZGRsZXdhcmU8UywgVW5rbm93bkFjdGlvbiwgRT4gOiBUaHVua01pZGRsZXdhcmU8UywgVW5rbm93bkFjdGlvbj47XG5leHBvcnQgdHlwZSBHZXREZWZhdWx0TWlkZGxld2FyZTxTID0gYW55PiA9IDxPIGV4dGVuZHMgR2V0RGVmYXVsdE1pZGRsZXdhcmVPcHRpb25zID0ge1xuICB0aHVuazogdHJ1ZTtcbiAgaW1tdXRhYmxlQ2hlY2s6IHRydWU7XG4gIHNlcmlhbGl6YWJsZUNoZWNrOiB0cnVlO1xuICBhY3Rpb25DcmVhdG9yQ2hlY2s6IHRydWU7XG59PihvcHRpb25zPzogTykgPT4gVHVwbGU8RXhjbHVkZUZyb21UdXBsZTxbVGh1bmtNaWRkbGV3YXJlRm9yPFMsIE8+XSwgbmV2ZXI+PjtcbmV4cG9ydCBjb25zdCBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlID0gPFMgPSBhbnksPigpOiBHZXREZWZhdWx0TWlkZGxld2FyZTxTPiA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlPE1pZGRsZXdhcmVbXT4oKTtcblxuICBpZiAodGh1bmspIHtcbiAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2god2l0aEV4dHJhQXJndW1lbnQodGh1bmsuZXh0cmFBcmd1bWVudCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XG4gICAgICAvKiBQUk9EX1NUQVJUX1JFTU9WRV9VTUQgKi9cbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zOiBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zID0ge307XG5cbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG5cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XG4gICAgICAvKiBQUk9EX1NUT1BfUkVNT1ZFX1VNRCAqL1xuICAgIH1cblxuICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xuICAgICAgbGV0IHNlcmlhbGl6YWJsZU9wdGlvbnM6IFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgPSB7fTtcblxuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cblxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XG4gICAgICBsZXQgYWN0aW9uQ3JlYXRvck9wdGlvbnM6IEFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuXG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAobWlkZGxld2FyZUFycmF5IGFzIGFueSk7XG59OyIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IElzVW5rbm93bk9yTm9uSW5mZXJyYWJsZSwgSWZNYXliZVVuZGVmaW5lZCwgSWZWb2lkLCBJc0FueSB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IGhhc01hdGNoRnVuY3Rpb24gfSBmcm9tICcuL3RzSGVscGVycyc7XG4vKipcbiAqIEFuIGFjdGlvbiB3aXRoIGEgc3RyaW5nIHR5cGUgYW5kIGFuIGFzc29jaWF0ZWQgcGF5bG9hZC4gVGhpcyBpcyB0aGVcbiAqIHR5cGUgb2YgYWN0aW9uIHJldHVybmVkIGJ5IGBjcmVhdGVBY3Rpb24oKWAgYWN0aW9uIGNyZWF0b3JzLlxuICpcbiAqIEB0ZW1wbGF0ZSBQIFRoZSB0eXBlIG9mIHRoZSBhY3Rpb24ncyBwYXlsb2FkLlxuICogQHRlbXBsYXRlIFQgdGhlIHR5cGUgdXNlZCBmb3IgdGhlIGFjdGlvbiB0eXBlLlxuICogQHRlbXBsYXRlIE0gVGhlIHR5cGUgb2YgdGhlIGFjdGlvbidzIG1ldGEgKG9wdGlvbmFsKVxuICogQHRlbXBsYXRlIEUgVGhlIHR5cGUgb2YgdGhlIGFjdGlvbidzIGVycm9yIChvcHRpb25hbClcbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgUGF5bG9hZEFjdGlvbjxQID0gdm9pZCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgTSA9IG5ldmVyLCBFID0gbmV2ZXI+ID0ge1xuICBwYXlsb2FkOiBQO1xuICB0eXBlOiBUO1xufSAmIChbTV0gZXh0ZW5kcyBbbmV2ZXJdID8ge30gOiB7XG4gIG1ldGE6IE07XG59KSAmIChbRV0gZXh0ZW5kcyBbbmV2ZXJdID8ge30gOiB7XG4gIGVycm9yOiBFO1xufSk7XG4vKipcbiAqIEEgXCJwcmVwYXJlXCIgbWV0aG9kIHRvIGJlIHVzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgYGNyZWF0ZUFjdGlvbmAuXG4gKiBUYWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhIEZsdXggU3RhbmRhcmQgQWN0aW9uIHdpdGhvdXRcbiAqIHR5cGUgKHdpbGwgYmUgYWRkZWQgbGF0ZXIpIHRoYXQgKm11c3QqIGNvbnRhaW4gYSBwYXlsb2FkIChtaWdodCBiZSB1bmRlZmluZWQpLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgdHlwZSBQcmVwYXJlQWN0aW9uPFA+ID0gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBwYXlsb2FkOiBQO1xufSkgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gIHBheWxvYWQ6IFA7XG4gIG1ldGE6IGFueTtcbn0pIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBwYXlsb2FkOiBQO1xuICBlcnJvcjogYW55O1xufSkgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gIHBheWxvYWQ6IFA7XG4gIG1ldGE6IGFueTtcbiAgZXJyb3I6IGFueTtcbn0pO1xuLyoqXG4gKiBJbnRlcm5hbCB2ZXJzaW9uIG9mIGBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZGAuIE5vdCB0byBiZSB1c2VkIGV4dGVybmFsbHkuXG4gKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IHR5cGUgX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+IHwgdm9pZCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSBQQSBleHRlbmRzIFByZXBhcmVBY3Rpb248aW5mZXIgUD4gPyBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxQYXJhbWV0ZXJzPFBBPiwgUCwgVCwgUmV0dXJuVHlwZTxQQT4gZXh0ZW5kcyB7XG4gIGVycm9yOiBpbmZlciBFO1xufSA/IEUgOiBuZXZlciwgUmV0dXJuVHlwZTxQQT4gZXh0ZW5kcyB7XG4gIG1ldGE6IGluZmVyIE07XG59ID8gTSA6IG5ldmVyPiA6IHZvaWQ7XG4vKipcbiAqIEJhc2ljIHR5cGUgZm9yIGFsbCBhY3Rpb24gY3JlYXRvcnMuXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlQWN0aW9uQ3JlYXRvcjxQLCBUIGV4dGVuZHMgc3RyaW5nLCBNID0gbmV2ZXIsIEUgPSBuZXZlcj4ge1xuICB0eXBlOiBUO1xuICBtYXRjaDogKGFjdGlvbjogdW5rbm93bikgPT4gYWN0aW9uIGlzIFBheWxvYWRBY3Rpb248UCwgVCwgTSwgRT47XG59XG4vKipcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIHRoYXQgdGFrZXMgbXVsdGlwbGUgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZFxuICogdG8gYSBgUHJlcGFyZUFjdGlvbmAgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgZmluYWwgQWN0aW9uLlxuICogQHR5cGVQYXJhbSBBcmdzIGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbiBjcmVhdG9yIGZ1bmN0aW9uXG4gKiBAdHlwZVBhcmFtIFAgYHBheWxvYWRgIHR5cGVcbiAqIEB0eXBlUGFyYW0gVCBgdHlwZWAgbmFtZVxuICogQHR5cGVQYXJhbSBFIG9wdGlvbmFsIGBlcnJvcmAgdHlwZVxuICogQHR5cGVQYXJhbSBNIG9wdGlvbmFsIGBtZXRhYCB0eXBlXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8QXJncyBleHRlbmRzIHVua25vd25bXSwgUCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgRSA9IG5ldmVyLCBNID0gbmV2ZXI+IGV4dGVuZHMgQmFzZUFjdGlvbkNyZWF0b3I8UCwgVCwgTSwgRT4ge1xuICAvKipcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGBBcmdzYCB3aWxsIHJldHVyblxuICAgKiBhbiBBY3Rpb24gd2l0aCBhIHBheWxvYWQgb2YgdHlwZSBgUGAgYW5kIChkZXBlbmRpbmcgb24gdGhlIGBQcmVwYXJlQWN0aW9uYFxuICAgKiBtZXRob2QgdXNlZCkgYSBgbWV0YWAtIGFuZCBgZXJyb3JgIHByb3BlcnR5IG9mIHR5cGVzIGBNYCBhbmQgYEVgIHJlc3BlY3RpdmVseS5cbiAgICovXG4gICguLi5hcmdzOiBBcmdzKTogUGF5bG9hZEFjdGlvbjxQLCBULCBNLCBFPjtcbn1cbi8qKlxuICogQW4gYWN0aW9uIGNyZWF0b3Igb2YgdHlwZSBgVGAgdGhhdCB0YWtlcyBhbiBvcHRpb25hbCBwYXlsb2FkIG9mIHR5cGUgYFBgLlxuICpcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoT3B0aW9uYWxQYXlsb2FkPFAsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IGV4dGVuZHMgQmFzZUFjdGlvbkNyZWF0b3I8UCwgVD4ge1xuICAvKipcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGFuIGFyZ3VtZW50IHdpbGxcbiAgICogcmV0dXJuIGEge0BsaW5rIFBheWxvYWRBY3Rpb259IG9mIHR5cGUgYFRgIHdpdGggYSBwYXlsb2FkIG9mIGBQYC5cbiAgICogQ2FsbGluZyBpdCB3aXRob3V0IGFuIGFyZ3VtZW50IHdpbGwgcmV0dXJuIGEgUGF5bG9hZEFjdGlvbiB3aXRoIGEgcGF5bG9hZCBvZiBgdW5kZWZpbmVkYC5cbiAgICovXG4gIChwYXlsb2FkPzogUCk6IFBheWxvYWRBY3Rpb248UCwgVD47XG59XG4vKipcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIG9mIHR5cGUgYFRgIHRoYXQgdGFrZXMgbm8gcGF5bG9hZC5cbiAqXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQ8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gZXh0ZW5kcyBCYXNlQWN0aW9uQ3JlYXRvcjx1bmRlZmluZWQsIFQ+IHtcbiAgLyoqXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2lsbFxuICAgKiByZXR1cm4gYSB7QGxpbmsgUGF5bG9hZEFjdGlvbn0gb2YgdHlwZSBgVGAgd2l0aCBhIHBheWxvYWQgb2YgYHVuZGVmaW5lZGBcbiAgICovXG4gIChub0FyZ3VtZW50OiB2b2lkKTogUGF5bG9hZEFjdGlvbjx1bmRlZmluZWQsIFQ+O1xufVxuLyoqXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB0aGF0IHJlcXVpcmVzIGEgcGF5bG9hZCBvZiB0eXBlIFAuXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkPFAsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IGV4dGVuZHMgQmFzZUFjdGlvbkNyZWF0b3I8UCwgVD4ge1xuICAvKipcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGFuIGFyZ3VtZW50IHdpbGxcbiAgICogcmV0dXJuIGEge0BsaW5rIFBheWxvYWRBY3Rpb259IG9mIHR5cGUgYFRgIHdpdGggYSBwYXlsb2FkIG9mIGBQYFxuICAgKi9cbiAgKHBheWxvYWQ6IFApOiBQYXlsb2FkQWN0aW9uPFAsIFQ+O1xufVxuLyoqXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB3aG9zZSBgcGF5bG9hZGAgdHlwZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIEFjY2VwdHMgZXZlcnl0aGluZyBhcyBgcGF5bG9hZGAuXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhOb25JbmZlcnJhYmxlUGF5bG9hZDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPHVua25vd24sIFQ+IHtcbiAgLyoqXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2l0aCBhbiBhcmd1bWVudCB3aWxsXG4gICAqIHJldHVybiBhIHtAbGluayBQYXlsb2FkQWN0aW9ufSBvZiB0eXBlIGBUYCB3aXRoIGEgcGF5bG9hZFxuICAgKiBvZiBleGFjdGx5IHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudC5cbiAgICovXG4gIDxQVCBleHRlbmRzIHVua25vd24+KHBheWxvYWQ6IFBUKTogUGF5bG9hZEFjdGlvbjxQVCwgVD47XG59XG4vKipcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIHRoYXQgcHJvZHVjZXMgYWN0aW9ucyB3aXRoIGEgYHBheWxvYWRgIGF0dHJpYnV0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIFAgdGhlIGBwYXlsb2FkYCB0eXBlXG4gKiBAdHlwZVBhcmFtIFQgdGhlIGB0eXBlYCBvZiB0aGUgcmVzdWx0aW5nIGFjdGlvblxuICogQHR5cGVQYXJhbSBQQSBpZiB0aGUgcmVzdWx0aW5nIGFjdGlvbiBpcyBwcmVwcm9jZXNzZWQgYnkgYSBgcHJlcGFyZWAgbWV0aG9kLCB0aGUgc2lnbmF0dXJlIG9mIHNhaWQgbWV0aG9kLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgdHlwZSBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxQID0gdm9pZCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgUEEgZXh0ZW5kcyBQcmVwYXJlQWN0aW9uPFA+IHwgdm9pZCA9IHZvaWQ+ID0gSWZQcmVwYXJlQWN0aW9uTWV0aG9kUHJvdmlkZWQ8UEEsIF9BY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxQQSwgVD4sIC8vIGVsc2VcbklzQW55PFAsIEFjdGlvbkNyZWF0b3JXaXRoUGF5bG9hZDxhbnksIFQ+LCBJc1Vua25vd25Pck5vbkluZmVycmFibGU8UCwgQWN0aW9uQ3JlYXRvcldpdGhOb25JbmZlcnJhYmxlUGF5bG9hZDxUPiwgLy8gZWxzZVxuSWZWb2lkPFAsIEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZDxUPiwgLy8gZWxzZVxuSWZNYXliZVVuZGVmaW5lZDxQLCBBY3Rpb25DcmVhdG9yV2l0aE9wdGlvbmFsUGF5bG9hZDxQLCBUPiwgLy8gZWxzZVxuQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkPFAsIFQ+Pj4+Pj47XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gYWN0aW9uIGNyZWF0b3IgZm9yIHRoZSBnaXZlbiBhY3Rpb24gdHlwZVxuICogc3RyaW5nLiBUaGUgYWN0aW9uIGNyZWF0b3IgYWNjZXB0cyBhIHNpbmdsZSBhcmd1bWVudCwgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZFxuICogaW4gdGhlIGFjdGlvbiBvYmplY3QgYXMgYSBmaWVsZCBjYWxsZWQgcGF5bG9hZC4gVGhlIGFjdGlvbiBjcmVhdG9yIGZ1bmN0aW9uXG4gKiB3aWxsIGFsc28gaGF2ZSBpdHMgdG9TdHJpbmcoKSBvdmVycmlkZGVuIHNvIHRoYXQgaXQgcmV0dXJucyB0aGUgYWN0aW9uIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGUgVGhlIGFjdGlvbiB0eXBlIHRvIHVzZSBmb3IgY3JlYXRlZCBhY3Rpb25zLlxuICogQHBhcmFtIHByZXBhcmUgKG9wdGlvbmFsKSBhIG1ldGhvZCB0aGF0IHRha2VzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCByZXR1cm5zIHsgcGF5bG9hZCB9IG9yIHsgcGF5bG9hZCwgbWV0YSB9LlxuICogICAgICAgICAgICAgICAgSWYgdGhpcyBpcyBnaXZlbiwgdGhlIHJlc3VsdGluZyBhY3Rpb24gY3JlYXRvciB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCB0byBjYWxjdWxhdGUgcGF5bG9hZCAmIG1ldGEuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBY3Rpb248UCA9IHZvaWQsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KHR5cGU6IFQpOiBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxQLCBUPjtcbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBhY3Rpb24gY3JlYXRvciBmb3IgdGhlIGdpdmVuIGFjdGlvbiB0eXBlXG4gKiBzdHJpbmcuIFRoZSBhY3Rpb24gY3JlYXRvciBhY2NlcHRzIGEgc2luZ2xlIGFyZ3VtZW50LCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkXG4gKiBpbiB0aGUgYWN0aW9uIG9iamVjdCBhcyBhIGZpZWxkIGNhbGxlZCBwYXlsb2FkLiBUaGUgYWN0aW9uIGNyZWF0b3IgZnVuY3Rpb25cbiAqIHdpbGwgYWxzbyBoYXZlIGl0cyB0b1N0cmluZygpIG92ZXJyaWRkZW4gc28gdGhhdCBpdCByZXR1cm5zIHRoZSBhY3Rpb24gdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZSBUaGUgYWN0aW9uIHR5cGUgdG8gdXNlIGZvciBjcmVhdGVkIGFjdGlvbnMuXG4gKiBAcGFyYW0gcHJlcGFyZSAob3B0aW9uYWwpIGEgbWV0aG9kIHRoYXQgdGFrZXMgYW55IG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHJldHVybnMgeyBwYXlsb2FkIH0gb3IgeyBwYXlsb2FkLCBtZXRhIH0uXG4gKiAgICAgICAgICAgICAgICBJZiB0aGlzIGlzIGdpdmVuLCB0aGUgcmVzdWx0aW5nIGFjdGlvbiBjcmVhdG9yIHdpbGwgcGFzcyBpdHMgYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIHRvIGNhbGN1bGF0ZSBwYXlsb2FkICYgbWV0YS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbjxQQSBleHRlbmRzIFByZXBhcmVBY3Rpb248YW55PiwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4odHlwZTogVCwgcHJlcGFyZUFjdGlvbjogUEEpOiBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxSZXR1cm5UeXBlPFBBPlsncGF5bG9hZCddLCBULCBQQT47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGU6IHN0cmluZywgcHJlcGFyZUFjdGlvbj86IEZ1bmN0aW9uKTogYW55IHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzOiBhbnlbXSkge1xuICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XG4gICAgICBsZXQgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6ICdwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkLFxuICAgICAgICAuLi4oJ21ldGEnIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oJ2Vycm9yJyBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cblxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuXG4gIGFjdGlvbkNyZWF0b3IudHlwZSA9IHR5cGU7XG5cbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb246IHVua25vd24pOiBhY3Rpb24gaXMgUGF5bG9hZEFjdGlvbiA9PiBpc0FjdGlvbihhY3Rpb24pICYmIGFjdGlvbi50eXBlID09PSB0eXBlO1xuXG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYW4gUlRLLWxpa2UgYWN0aW9uIGNyZWF0b3IsIHdpdGggYSBzdGF0aWMgdHlwZSBwcm9wZXJ0eSBhbmQgbWF0Y2ggbWV0aG9kLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uOiB1bmtub3duKTogYWN0aW9uIGlzIEJhc2VBY3Rpb25DcmVhdG9yPHVua25vd24sIHN0cmluZz4gJiBGdW5jdGlvbiB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nICYmICd0eXBlJyBpbiBhY3Rpb24gJiYgLy8gaGFzTWF0Y2hGdW5jdGlvbiBvbmx5IHdhbnRzIE1hdGNoZXJzIGJ1dCBJIGRvbid0IHNlZSB0aGUgcG9pbnQgaW4gcmV3cml0aW5nIGl0XG4gIGhhc01hdGNoRnVuY3Rpb24oKGFjdGlvbiBhcyBhbnkpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGFuIGFjdGlvbiB3aXRoIGEgc3RyaW5nIHR5cGUgYW5kIHZhbGlkIEZsdXggU3RhbmRhcmQgQWN0aW9uIGtleXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRlNBKGFjdGlvbjogdW5rbm93bik6IGFjdGlvbiBpcyB7XG4gIHR5cGU6IHN0cmluZztcbiAgcGF5bG9hZD86IHVua25vd247XG4gIGVycm9yPzogdW5rbm93bjtcbiAgbWV0YT86IHVua25vd247XG59IHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXk6IHN0cmluZykge1xuICByZXR1cm4gWyd0eXBlJywgJ3BheWxvYWQnLCAnZXJyb3InLCAnbWV0YSddLmluZGV4T2Yoa2V5KSA+IC0xO1xufSAvLyBoZWxwZXIgdHlwZXMgZm9yIG1vcmUgcmVhZGFibGUgdHlwaW5nc1xuXG5cbnR5cGUgSWZQcmVwYXJlQWN0aW9uTWV0aG9kUHJvdmlkZWQ8UEEgZXh0ZW5kcyBQcmVwYXJlQWN0aW9uPGFueT4gfCB2b2lkLCBUcnVlLCBGYWxzZT4gPSBQQSBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55ID8gVHJ1ZSA6IEZhbHNlOyIsImltcG9ydCB0eXBlIHsgTWlkZGxld2FyZSwgU3RvcmVFbmhhbmNlciB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgVHVwbGUgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBzYWZlQXNzaWduPFQgZXh0ZW5kcyBvYmplY3Q+KHRhcmdldDogVCwgLi4uYXJnczogQXJyYXk8UGFydGlhbDxOb0luZmVyPFQ+Pj4pIHtcbiAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuLyoqXG4gKiByZXR1cm4gVHJ1ZSBpZiBUIGlzIGBhbnlgLCBvdGhlcndpc2UgcmV0dXJuIEZhbHNlXG4gKiB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qb29uaG9jaG8vdHNkZWZcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgdHlwZSBJc0FueTxULCBUcnVlLCBGYWxzZSA9IG5ldmVyPiA9IC8vIHRlc3QgaWYgd2UgYXJlIGdvaW5nIHRoZSBsZWZ0IEFORCByaWdodCBwYXRoIGluIHRoZSBjb25kaXRpb25cbnRydWUgfCBmYWxzZSBleHRlbmRzIChUIGV4dGVuZHMgbmV2ZXIgPyB0cnVlIDogZmFsc2UpID8gVHJ1ZSA6IEZhbHNlO1xuZXhwb3J0IHR5cGUgQ2FzdEFueTxULCBDYXN0VG8+ID0gSXNBbnk8VCwgQ2FzdFRvLCBUPjtcbi8qKlxuICogcmV0dXJuIFRydWUgaWYgVCBpcyBgdW5rbm93bmAsIG90aGVyd2lzZSByZXR1cm4gRmFsc2VcbiAqIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvb25ob2Noby90c2RlZlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCB0eXBlIElzVW5rbm93bjxULCBUcnVlLCBGYWxzZSA9IG5ldmVyPiA9IHVua25vd24gZXh0ZW5kcyBUID8gSXNBbnk8VCwgRmFsc2UsIFRydWU+IDogRmFsc2U7XG5leHBvcnQgdHlwZSBGYWxsYmFja0lmVW5rbm93bjxULCBGYWxsYmFjaz4gPSBJc1Vua25vd248VCwgRmFsbGJhY2ssIFQ+O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgdHlwZSBJZk1heWJlVW5kZWZpbmVkPFAsIFRydWUsIEZhbHNlPiA9IFt1bmRlZmluZWRdIGV4dGVuZHMgW1BdID8gVHJ1ZSA6IEZhbHNlO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgdHlwZSBJZlZvaWQ8UCwgVHJ1ZSwgRmFsc2U+ID0gW3ZvaWRdIGV4dGVuZHMgW1BdID8gVHJ1ZSA6IEZhbHNlO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgdHlwZSBJc0VtcHR5T2JqPFQsIFRydWUsIEZhbHNlID0gbmV2ZXI+ID0gVCBleHRlbmRzIGFueSA/IGtleW9mIFQgZXh0ZW5kcyBuZXZlciA/IElzVW5rbm93bjxULCBGYWxzZSwgSWZNYXliZVVuZGVmaW5lZDxULCBGYWxzZSwgSWZWb2lkPFQsIEZhbHNlLCBUcnVlPj4+IDogRmFsc2UgOiBuZXZlcjtcbi8qKlxuICogcmV0dXJucyBUcnVlIGlmIFRTIHZlcnNpb24gaXMgYWJvdmUgMy41LCBGYWxzZSBpZiBiZWxvdy5cbiAqIHVzZXMgZmVhdHVyZSBkZXRlY3Rpb24gdG8gZGV0ZWN0IFRTIHZlcnNpb24gPj0gMy41XG4gKiAqIHZlcnNpb25zIGJlbG93IDMuNSB3aWxsIHJldHVybiBge31gIGZvciB1bnJlc29sdmFibGUgaW50ZXJmZXJlbmNlXG4gKiAqIHZlcnNpb25zIGFib3ZlIHdpbGwgcmV0dXJuIGB1bmtub3duYFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCB0eXBlIEF0TGVhc3RUUzM1PFRydWUsIEZhbHNlPiA9IFtUcnVlLCBGYWxzZV1bSXNVbmtub3duPFJldHVyblR5cGU8PFQ+KCkgPT4gVD4sIDAsIDE+XTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IHR5cGUgSXNVbmtub3duT3JOb25JbmZlcnJhYmxlPFQsIFRydWUsIEZhbHNlPiA9IEF0TGVhc3RUUzM1PElzVW5rbm93bjxULCBUcnVlLCBGYWxzZT4sIElzRW1wdHlPYmo8VCwgVHJ1ZSwgSXNVbmtub3duPFQsIFRydWUsIEZhbHNlPj4+O1xuLyoqXG4gKiBDb252ZXJ0IGEgVW5pb24gdHlwZSBgKEF8QilgIHRvIGFuIGludGVyc2VjdGlvbiB0eXBlIGAoQSZCKWBcbiAqL1xuXG5leHBvcnQgdHlwZSBVbmlvblRvSW50ZXJzZWN0aW9uPFU+ID0gKFUgZXh0ZW5kcyBhbnkgPyAoazogVSkgPT4gdm9pZCA6IG5ldmVyKSBleHRlbmRzIChrOiBpbmZlciBJKSA9PiB2b2lkID8gSSA6IG5ldmVyOyAvLyBBcHBlYXJzIHRvIGhhdmUgYSBjb252ZW5pZW50IHNpZGUgZWZmZWN0IG9mIGlnbm9yaW5nIGBuZXZlcmAgZXZlbiBpZiB0aGF0J3Mgbm90IHdoYXQgeW91IHNwZWNpZmllZFxuXG5leHBvcnQgdHlwZSBFeGNsdWRlRnJvbVR1cGxlPFQsIEUsIEFjYyBleHRlbmRzIHVua25vd25bXSA9IFtdPiA9IFQgZXh0ZW5kcyBbaW5mZXIgSGVhZCwgLi4uaW5mZXIgVGFpbF0gPyBFeGNsdWRlRnJvbVR1cGxlPFRhaWwsIEUsIFsuLi5BY2MsIC4uLihbSGVhZF0gZXh0ZW5kcyBbRV0gPyBbXSA6IFtIZWFkXSldPiA6IEFjYztcbnR5cGUgRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxNaWRkbGV3YXJlVHVwbGUgZXh0ZW5kcyByZWFkb25seSBhbnlbXSwgQWNjIGV4dGVuZHMge30+ID0gTWlkZGxld2FyZVR1cGxlIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxUYWlsLCBBY2MgJiAoSGVhZCBleHRlbmRzIE1pZGRsZXdhcmU8aW5mZXIgRD4gPyBJc0FueTxELCB7fSwgRD4gOiB7fSk+IDogQWNjO1xuZXhwb3J0IHR5cGUgRXh0cmFjdERpc3BhdGNoRXh0ZW5zaW9uczxNPiA9IE0gZXh0ZW5kcyBUdXBsZTxpbmZlciBNaWRkbGV3YXJlVHVwbGU+ID8gRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxNaWRkbGV3YXJlVHVwbGUsIHt9PiA6IE0gZXh0ZW5kcyBSZWFkb25seUFycmF5PE1pZGRsZXdhcmU+ID8gRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxbLi4uTV0sIHt9PiA6IG5ldmVyO1xudHlwZSBFeHRyYWN0U3RvcmVFeHRlbnNpb25zRnJvbUVuaGFuY2VyVHVwbGU8RW5oYW5jZXJUdXBsZSBleHRlbmRzIHJlYWRvbmx5IGFueVtdLCBBY2MgZXh0ZW5kcyB7fT4gPSBFbmhhbmNlclR1cGxlIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXh0cmFjdFN0b3JlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPFRhaWwsIEFjYyAmIChIZWFkIGV4dGVuZHMgU3RvcmVFbmhhbmNlcjxpbmZlciBFeHQ+ID8gSXNBbnk8RXh0LCB7fSwgRXh0PiA6IHt9KT4gOiBBY2M7XG5leHBvcnQgdHlwZSBFeHRyYWN0U3RvcmVFeHRlbnNpb25zPEU+ID0gRSBleHRlbmRzIFR1cGxlPGluZmVyIEVuaGFuY2VyVHVwbGU+ID8gRXh0cmFjdFN0b3JlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPEVuaGFuY2VyVHVwbGUsIHt9PiA6IEUgZXh0ZW5kcyBSZWFkb25seUFycmF5PFN0b3JlRW5oYW5jZXI+ID8gVW5pb25Ub0ludGVyc2VjdGlvbjxFW251bWJlcl0gZXh0ZW5kcyBTdG9yZUVuaGFuY2VyPGluZmVyIEV4dD4gPyBFeHQgZXh0ZW5kcyB7fSA/IElzQW55PEV4dCwge30sIEV4dD4gOiB7fSA6IHt9PiA6IG5ldmVyO1xudHlwZSBFeHRyYWN0U3RhdGVFeHRlbnNpb25zRnJvbUVuaGFuY2VyVHVwbGU8RW5oYW5jZXJUdXBsZSBleHRlbmRzIHJlYWRvbmx5IGFueVtdLCBBY2MgZXh0ZW5kcyB7fT4gPSBFbmhhbmNlclR1cGxlIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXh0cmFjdFN0YXRlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPFRhaWwsIEFjYyAmIChIZWFkIGV4dGVuZHMgU3RvcmVFbmhhbmNlcjxhbnksIGluZmVyIFN0YXRlRXh0PiA/IElzQW55PFN0YXRlRXh0LCB7fSwgU3RhdGVFeHQ+IDoge30pPiA6IEFjYztcbmV4cG9ydCB0eXBlIEV4dHJhY3RTdGF0ZUV4dGVuc2lvbnM8RT4gPSBFIGV4dGVuZHMgVHVwbGU8aW5mZXIgRW5oYW5jZXJUdXBsZT4gPyBFeHRyYWN0U3RhdGVFeHRlbnNpb25zRnJvbUVuaGFuY2VyVHVwbGU8RW5oYW5jZXJUdXBsZSwge30+IDogRSBleHRlbmRzIFJlYWRvbmx5QXJyYXk8U3RvcmVFbmhhbmNlcj4gPyBVbmlvblRvSW50ZXJzZWN0aW9uPEVbbnVtYmVyXSBleHRlbmRzIFN0b3JlRW5oYW5jZXI8YW55LCBpbmZlciBTdGF0ZUV4dD4gPyBTdGF0ZUV4dCBleHRlbmRzIHt9ID8gSXNBbnk8U3RhdGVFeHQsIHt9LCBTdGF0ZUV4dD4gOiB7fSA6IHt9PiA6IG5ldmVyO1xuLyoqXG4gKiBIZWxwZXIgdHlwZS4gUGFzc2VzIFQgb3V0IGFnYWluLCBidXQgYm94ZXMgaXQgaW4gYSB3YXkgdGhhdCBpdCBjYW5ub3RcbiAqIFwid2lkZW5cIiB0aGUgdHlwZSBieSBhY2NpZGVudCBpZiBpdCBpcyBhIGdlbmVyaWMgdGhhdCBzaG91bGQgYmUgaW5mZXJyZWRcbiAqIGZyb20gZWxzZXdoZXJlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCB0eXBlIE5vSW5mZXI8VD4gPSBbVF1bVCBleHRlbmRzIGFueSA/IDAgOiBuZXZlcl07XG5leHBvcnQgdHlwZSBOb25VbmRlZmluZWQ8VD4gPSBUIGV4dGVuZHMgdW5kZWZpbmVkID8gbmV2ZXIgOiBUO1xuZXhwb3J0IHR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgYW55PiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XG5leHBvcnQgdHlwZSBXaXRoUmVxdWlyZWRQcm9wPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IE9taXQ8VCwgSz4gJiBSZXF1aXJlZDxQaWNrPFQsIEs+PjtcbmV4cG9ydCB0eXBlIFdpdGhPcHRpb25hbFByb3A8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gT21pdDxULCBLPiAmIFBhcnRpYWw8UGljazxULCBLPj47XG5leHBvcnQgaW50ZXJmYWNlIFR5cGVHdWFyZDxUPiB7XG4gICh2YWx1ZTogYW55KTogdmFsdWUgaXMgVDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSGFzTWF0Y2hGdW5jdGlvbjxUPiB7XG4gIG1hdGNoOiBUeXBlR3VhcmQ8VD47XG59XG5leHBvcnQgY29uc3QgaGFzTWF0Y2hGdW5jdGlvbiA9IDxULD4odjogTWF0Y2hlcjxUPik6IHYgaXMgSGFzTWF0Y2hGdW5jdGlvbjxUPiA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiAodiBhcyBIYXNNYXRjaEZ1bmN0aW9uPFQ+KS5tYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKiogQHB1YmxpYyAqL1xuXG5leHBvcnQgdHlwZSBNYXRjaGVyPFQ+ID0gSGFzTWF0Y2hGdW5jdGlvbjxUPiB8IFR5cGVHdWFyZDxUPjtcbi8qKiBAcHVibGljICovXG5cbmV4cG9ydCB0eXBlIEFjdGlvbkZyb21NYXRjaGVyPE0gZXh0ZW5kcyBNYXRjaGVyPGFueT4+ID0gTSBleHRlbmRzIE1hdGNoZXI8aW5mZXIgVD4gPyBUIDogbmV2ZXI7XG5leHBvcnQgdHlwZSBJZDxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gfSAmIHt9O1xuZXhwb3J0IHR5cGUgVGFpbDxUIGV4dGVuZHMgYW55W10+ID0gVCBleHRlbmRzIFthbnksIC4uLmluZmVyIFRhaWxdID8gVGFpbCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgVW5rbm93bklmTm9uU3BlY2lmaWM8VD4gPSB7fSBleHRlbmRzIFQgPyB1bmtub3duIDogVDtcbi8qKlxuICogQSBQcm9taXNlIHRoYXQgd2lsbCBuZXZlciByZWplY3QuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlZHV4LXRvb2xraXQvaXNzdWVzLzQxMDFcbiAqL1xuXG5leHBvcnQgdHlwZSBTYWZlUHJvbWlzZTxUPiA9IFByb21pc2U8VD4gJiB7XG4gIF9fbGludGVyQnJhbmRzOiAnU2FmZVByb21pc2UnO1xufTtcbi8qKlxuICogUHJvcGVybHkgd3JhcHMgYSBQcm9taXNlIGFzIGEge0BsaW5rIFNhZmVQcm9taXNlfSB3aXRoIC5jYXRjaChmYWxsYmFjaykuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFzU2FmZVByb21pc2U8UmVzb2x2ZWQsIFJlamVjdGVkPihwcm9taXNlOiBQcm9taXNlPFJlc29sdmVkPiwgZmFsbGJhY2s6IChlcnJvcjogdW5rbm93bikgPT4gUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIChwcm9taXNlLmNhdGNoKGZhbGxiYWNrKSBhcyBTYWZlUHJvbWlzZTxSZXNvbHZlZCB8IFJlamVjdGVkPik7XG59IiwiaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgaXNBY3Rpb25DcmVhdG9yIGFzIGlzUlRLQWN0aW9uIH0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nO1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRvIGlkZW50aWZ5IHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBhY3Rpb24gY3JlYXRvci5cbiAgICogVGhlIGRlZmF1bHQgY2hlY2tzIGZvciBhIGZ1bmN0aW9uIHdpdGggYSBzdGF0aWMgdHlwZSBwcm9wZXJ0eSBhbmQgbWF0Y2ggbWV0aG9kLlxuICAgKi9cbiAgaXNBY3Rpb25DcmVhdG9yPzogKGFjdGlvbjogdW5rbm93bikgPT4gYWN0aW9uIGlzIEZ1bmN0aW9uICYge1xuICAgIHR5cGU/OiB1bmtub3duO1xuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2UodHlwZT86IHVua25vd24pIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdCgnLycpIDogW107XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBzcGxpdFR5cGVbc3BsaXRUeXBlLmxlbmd0aCAtIDFdIHx8ICdhY3Rpb25DcmVhdG9yJztcbiAgcmV0dXJuIGBEZXRlY3RlZCBhbiBhY3Rpb24gY3JlYXRvciB3aXRoIHR5cGUgXCIke3R5cGUgfHwgJ3Vua25vd24nfVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zOiBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgPSB7fSk6IE1pZGRsZXdhcmUge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiBuZXh0KGFjdGlvbik7XG4gIH1cblxuICBjb25zdCB7XG4gICAgaXNBY3Rpb25DcmVhdG9yID0gaXNSVEtBY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcihhY3Rpb24pKSB7XG4gICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmUsIFN0b3JlRW5oYW5jZXIgfSBmcm9tICdyZWR1eCc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheTogbnVtYmVyLCBmbk5hbWU6IHN0cmluZykge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWU8VD4oZm46ICgpID0+IFQpOiBUIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdhcm5JZkV4Y2VlZGVkKCkge1xuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7Zm5OYW1lfSB0b29rICR7ZWxhcHNlZH1tcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiAke21heERlbGF5fW1zLiBcbklmIHlvdXIgc3RhdGUgb3IgYWN0aW9ucyBhcmUgdmVyeSBsYXJnZSwgeW91IG1heSB3YW50IHRvIGRpc2FibGUgdGhlIG1pZGRsZXdhcmUgYXMgaXQgbWlnaHQgY2F1c2UgdG9vIG11Y2ggb2YgYSBzbG93ZG93biBpbiBkZXZlbG9wbWVudCBtb2RlLiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUgZm9yIGluc3RydWN0aW9ucy5cbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5KG1zOiBudW1iZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4oaXRlcmFibGU6IEl0ZXJhYmxlPFQ+LCBjb21wYXJhdG9yOiAoaXRlbTogVCkgPT4gYm9vbGVhbik6IFQgfCB1bmRlZmluZWQge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoZW50cnkpKSB7XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBjbGFzcyBUdXBsZTxJdGVtcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8dW5rbm93bj4gPSBbXT4gZXh0ZW5kcyBBcnJheTxJdGVtc1tudW1iZXJdPiB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aDogbnVtYmVyKTtcbiAgY29uc3RydWN0b3IoLi4uaXRlbXM6IEl0ZW1zKTtcblxuICBjb25zdHJ1Y3RvciguLi5pdGVtczogYW55W10pIHtcbiAgICBzdXBlciguLi5pdGVtcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFR1cGxlLnByb3RvdHlwZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIChUdXBsZSBhcyBhbnkpO1xuICB9XG5cbiAgY29uY2F0PEFkZGl0aW9uYWxJdGVtcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8dW5rbm93bj4+KGl0ZW1zOiBUdXBsZTxBZGRpdGlvbmFsSXRlbXM+KTogVHVwbGU8Wy4uLkl0ZW1zLCAuLi5BZGRpdGlvbmFsSXRlbXNdPjtcbiAgY29uY2F0PEFkZGl0aW9uYWxJdGVtcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8dW5rbm93bj4+KGl0ZW1zOiBBZGRpdGlvbmFsSXRlbXMpOiBUdXBsZTxbLi4uSXRlbXMsIC4uLkFkZGl0aW9uYWxJdGVtc10+O1xuICBjb25jYXQ8QWRkaXRpb25hbEl0ZW1zIGV4dGVuZHMgUmVhZG9ubHlBcnJheTx1bmtub3duPj4oLi4uaXRlbXM6IEFkZGl0aW9uYWxJdGVtcyk6IFR1cGxlPFsuLi5JdGVtcywgLi4uQWRkaXRpb25hbEl0ZW1zXT47XG5cbiAgY29uY2F0KC4uLmFycjogYW55W10pIHtcbiAgICByZXR1cm4gc3VwZXIuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XG4gIH1cblxuICBwcmVwZW5kPEFkZGl0aW9uYWxJdGVtcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8dW5rbm93bj4+KGl0ZW1zOiBUdXBsZTxBZGRpdGlvbmFsSXRlbXM+KTogVHVwbGU8Wy4uLkFkZGl0aW9uYWxJdGVtcywgLi4uSXRlbXNdPjtcbiAgcHJlcGVuZDxBZGRpdGlvbmFsSXRlbXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PHVua25vd24+PihpdGVtczogQWRkaXRpb25hbEl0ZW1zKTogVHVwbGU8Wy4uLkFkZGl0aW9uYWxJdGVtcywgLi4uSXRlbXNdPjtcbiAgcHJlcGVuZDxBZGRpdGlvbmFsSXRlbXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PHVua25vd24+PiguLi5pdGVtczogQWRkaXRpb25hbEl0ZW1zKTogVHVwbGU8Wy4uLkFkZGl0aW9uYWxJdGVtcywgLi4uSXRlbXNdPjtcblxuICBwcmVwZW5kKC4uLmFycjogYW55W10pIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcbiAgICAgIHJldHVybiBuZXcgVHVwbGUoLi4uYXJyWzBdLmNvbmNhdCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUdXBsZSguLi5hcnIuY29uY2F0KHRoaXMpKTtcbiAgfVxuXG59XG5leHBvcnQgZnVuY3Rpb24gZnJlZXplRHJhZnRhYmxlPFQ+KHZhbDogVCkge1xuICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsICgpID0+IHt9KSA6IHZhbDtcbn1cbmludGVyZmFjZSBXZWFrTWFwRW1wbGFjZUhhbmRsZXI8SyBleHRlbmRzIG9iamVjdCwgVj4ge1xuICAvKipcbiAgICogV2lsbCBiZSBjYWxsZWQgdG8gZ2V0IHZhbHVlLCBpZiBubyB2YWx1ZSBpcyBjdXJyZW50bHkgaW4gbWFwLlxuICAgKi9cbiAgaW5zZXJ0PyhrZXk6IEssIG1hcDogV2Vha01hcDxLLCBWPik6IFY7XG4gIC8qKlxuICAgKiBXaWxsIGJlIGNhbGxlZCB0byB1cGRhdGUgYSB2YWx1ZSwgaWYgb25lIGV4aXN0cyBhbHJlYWR5LlxuICAgKi9cblxuICB1cGRhdGU/KHByZXZpb3VzOiBWLCBrZXk6IEssIG1hcDogV2Vha01hcDxLLCBWPik6IFY7XG59XG5pbnRlcmZhY2UgTWFwRW1wbGFjZUhhbmRsZXI8SywgVj4ge1xuICAvKipcbiAgICogV2lsbCBiZSBjYWxsZWQgdG8gZ2V0IHZhbHVlLCBpZiBubyB2YWx1ZSBpcyBjdXJyZW50bHkgaW4gbWFwLlxuICAgKi9cbiAgaW5zZXJ0PyhrZXk6IEssIG1hcDogTWFwPEssIFY+KTogVjtcbiAgLyoqXG4gICAqIFdpbGwgYmUgY2FsbGVkIHRvIHVwZGF0ZSBhIHZhbHVlLCBpZiBvbmUgZXhpc3RzIGFscmVhZHkuXG4gICAqL1xuXG4gIHVwZGF0ZT8ocHJldmlvdXM6IFYsIGtleTogSywgbWFwOiBNYXA8SywgVj4pOiBWO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVtcGxhY2U8SywgVj4obWFwOiBNYXA8SywgVj4sIGtleTogSywgaGFuZGxlcjogTWFwRW1wbGFjZUhhbmRsZXI8SywgVj4pOiBWO1xuZXhwb3J0IGZ1bmN0aW9uIGVtcGxhY2U8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEssIGhhbmRsZXI6IFdlYWtNYXBFbXBsYWNlSGFuZGxlcjxLLCBWPik6IFY7XG4vKipcbiAqIEFsbG93IGluc2VydGluZyBhIG5ldyB2YWx1ZSwgb3IgdXBkYXRpbmcgYW4gZXhpc3Rpbmcgb25lXG4gKiBAdGhyb3dzIGlmIGNhbGxlZCBmb3IgYSBrZXkgd2l0aCBubyBjdXJyZW50IHZhbHVlIGFuZCBubyBgaW5zZXJ0YCBoYW5kbGVyIGlzIHByb3ZpZGVkXG4gKiBAcmV0dXJucyBjdXJyZW50IHZhbHVlIGluIG1hcCAoYWZ0ZXIgaW5zZXJ0aW9uL3VwZGF0aW5nKVxuICogYGBgdHNcbiAqIC8vIHJldHVybiBjdXJyZW50IHZhbHVlIGlmIGFscmVhZHkgaW4gbWFwLCBvdGhlcndpc2UgaW5pdGlhbGlzZSB0byAwIGFuZCByZXR1cm4gdGhhdFxuICogY29uc3QgbnVtID0gZW1wbGFjZShtYXAsIGtleSwge1xuICogICBpbnNlcnQ6ICgpID0+IDBcbiAqIH0pXG4gKlxuICogLy8gaW5jcmVhc2UgY3VycmVudCB2YWx1ZSBieSBvbmUgaWYgYWxyZWFkeSBpbiBtYXAsIG90aGVyd2lzZSBpbml0aWFsaXNlIHRvIDBcbiAqIGNvbnN0IG51bSA9IGVtcGxhY2UobWFwLCBrZXksIHtcbiAqICAgdXBkYXRlOiAobikgPT4gbiArIDEsXG4gKiAgIGluc2VydDogKCkgPT4gMCxcbiAqIH0pXG4gKlxuICogLy8gb25seSB1cGRhdGUgaWYgdmFsdWUncyBhbHJlYWR5IGluIHRoZSBtYXAgLSBhbmQgaW5jcmVhc2UgaXQgYnkgb25lXG4gKiBpZiAobWFwLmhhcyhrZXkpKSB7XG4gKiAgIGNvbnN0IG51bSA9IGVtcGxhY2UobWFwLCBrZXksIHtcbiAqICAgICB1cGRhdGU6IChuKSA9PiBuICsgMSxcbiAqICAgfSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC11cHNlcnQgY3VycmVudGx5IGluIFN0YWdlIDIgLSBtYXliZSBpbiBhIGZldyB5ZWFycyB3ZSdsbCBiZSBhYmxlIHRvIHJlcGxhY2UgdGhpcyB3aXRoIGRpcmVjdCBtZXRob2QgY2FsbHNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1wbGFjZTxLIGV4dGVuZHMgb2JqZWN0LCBWPihtYXA6IFdlYWtNYXA8SywgVj4sIGtleTogSywgaGFuZGxlcjogV2Vha01hcEVtcGxhY2VIYW5kbGVyPEssIFY+KTogViB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICBsZXQgdmFsdWUgPSAobWFwLmdldChrZXkpIGFzIFYpO1xuXG4gICAgaWYgKGhhbmRsZXIudXBkYXRlKSB7XG4gICAgICB2YWx1ZSA9IGhhbmRsZXIudXBkYXRlKHZhbHVlLCBrZXksIG1hcCk7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICghaGFuZGxlci5pbnNlcnQpIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiAnTm8gaW5zZXJ0IHByb3ZpZGVkIGZvciBrZXkgbm90IGFscmVhZHkgaW4gbWFwJyk7XG4gIGNvbnN0IGluc2VydGVkID0gaGFuZGxlci5pbnNlcnQoa2V5LCBtYXApO1xuICBtYXAuc2V0KGtleSwgaW5zZXJ0ZWQpO1xuICByZXR1cm4gaW5zZXJ0ZWQ7XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBnZXRUaW1lTWVhc3VyZVV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG50eXBlIEVudHJ5UHJvY2Vzc29yID0gKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGBpc0ltbXV0YWJsZWAgZnVuY3Rpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWU6IHVua25vd24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlOiBJc0ltbXV0YWJsZUZ1bmMsIGlnbm9yZVBhdGhzOiBJZ25vcmVQYXRocyB8IHVuZGVmaW5lZCwgb2JqOiBhbnkpIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG5cbiAgfTtcbn1cbmludGVyZmFjZSBUcmFja2VkUHJvcGVydHkge1xuICB2YWx1ZTogYW55O1xuICBjaGlsZHJlbjogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlOiBJc0ltbXV0YWJsZUZ1bmMsIGlnbm9yZVBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLCBvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHBhdGg6IHN0cmluZyA9ICcnLCBjaGVja2VkT2JqZWN0czogU2V0PFJlY29yZDxzdHJpbmcsIGFueT4+ID0gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQ6IFBhcnRpYWw8VHJhY2tlZFByb3BlcnR5PiA9IHtcbiAgICB2YWx1ZTogb2JqXG4gIH07XG5cbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICh0cmFja2VkIGFzIFRyYWNrZWRQcm9wZXJ0eSk7XG59XG5cbnR5cGUgSWdub3JlUGF0aHMgPSByZWFkb25seSAoc3RyaW5nIHwgUmVnRXhwKVtdO1xuXG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGU6IElzSW1tdXRhYmxlRnVuYywgaWdub3JlZFBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHk6IFRyYWNrZWRQcm9wZXJ0eSwgb2JqOiBhbnksIHNhbWVQYXJlbnRSZWY6IGJvb2xlYW4gPSBmYWxzZSwgcGF0aDogc3RyaW5nID0gJycpOiB7XG4gIHdhc011dGF0ZWQ6IGJvb2xlYW47XG4gIHBhdGg/OiBzdHJpbmc7XG59IHtcbiAgY29uc3QgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcblxuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgICB9O1xuICB9IC8vIEdhdGhlciBhbGwga2V5cyBmcm9tIHByZXYgKHRyYWNrZWQpIGFuZCBhZnRlciBvYmpzXG5cblxuICBjb25zdCBrZXlzVG9EZXRlY3Q6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG5cbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcblxuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKGlnbm9yZWQgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBuZXN0ZWRQYXRoKTtcblxuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gIH07XG59XG5cbnR5cGUgSXNJbW11dGFibGVGdW5jID0gKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG4vKipcbiAqIE9wdGlvbnMgZm9yIGBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgY29uc2lkZXJlZCB0byBiZSBpbW11dGFibGUuXG4gICAgVGhpcyBmdW5jdGlvbiBpcyBhcHBsaWVkIHJlY3Vyc2l2ZWx5IHRvIGV2ZXJ5IHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgc3RhdGUuXG4gICAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCByZXR1cm4gdHJ1ZSBmb3IgcHJpbWl0aXZlIHR5cGVzIFxuICAgIChsaWtlIG51bWJlcnMsIHN0cmluZ3MsIGJvb2xlYW5zLCBudWxsIGFuZCB1bmRlZmluZWQpLlxuICAgKi9cbiAgaXNJbW11dGFibGU/OiBJc0ltbXV0YWJsZUZ1bmM7XG4gIC8qKiBcbiAgICBBbiBhcnJheSBvZiBkb3Qtc2VwYXJhdGVkIHBhdGggc3RyaW5ncyB0aGF0IG1hdGNoIG5hbWVkIG5vZGVzIGZyb20gXG4gICAgdGhlIHJvb3Qgc3RhdGUgdG8gaWdub3JlIHdoZW4gY2hlY2tpbmcgZm9yIGltbXV0YWJpbGl0eS5cbiAgICBEZWZhdWx0cyB0byB1bmRlZmluZWRcbiAgICovXG5cbiAgaWdub3JlZFBhdGhzPzogSWdub3JlUGF0aHM7XG4gIC8qKiBQcmludCBhIHdhcm5pbmcgaWYgY2hlY2tzIHRha2UgbG9uZ2VyIHRoYW4gTiBtcy4gRGVmYXVsdDogMzJtcyAqL1xuXG4gIHdhcm5BZnRlcj86IG51bWJlcjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1pZGRsZXdhcmUgdGhhdCBjaGVja3Mgd2hldGhlciBhbnkgc3RhdGUgd2FzIG11dGF0ZWQgaW4gYmV0d2VlblxuICogZGlzcGF0Y2hlcyBvciBkdXJpbmcgYSBkaXNwYXRjaC4gSWYgYW55IG11dGF0aW9ucyBhcmUgZGV0ZWN0ZWQsIGFuIGVycm9yIGlzXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgTWlkZGxld2FyZSBvcHRpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnM6IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgPSB7fSk6IE1pZGRsZXdhcmUge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KG9iajogYW55LCBzZXJpYWxpemVyPzogRW50cnlQcm9jZXNzb3IsIGluZGVudD86IHN0cmluZyB8IG51bWJlciwgZGVjeWNsZXI/OiBFbnRyeVByb2Nlc3Nvcik6IHN0cmluZyB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyPzogRW50cnlQcm9jZXNzb3IsIGRlY3ljbGVyPzogRW50cnlQcm9jZXNzb3IpOiBFbnRyeVByb2Nlc3NvciB7XG4gICAgICBsZXQgc3RhY2s6IGFueVtdID0gW10sXG4gICAgICAgICAga2V5czogYW55W10gPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpIGRlY3ljbGVyID0gZnVuY3Rpb24gKF86IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH4uJyArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXM6IGFueSwga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkgdmFsdWUgPSBkZWN5Y2xlciEuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIGlzSW1tdXRhYmxlID0gaXNJbW11dGFibGVEZWZhdWx0LFxuICAgICAgaWdub3JlZFBhdGhzLFxuICAgICAgd2FybkFmdGVyID0gMzJcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrRm9yTXV0YXRpb25zLmJpbmQobnVsbCwgaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyk7XG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRTdGF0ZVxuICAgIH0pID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICBsZXQgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICByZXR1cm4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgJ0ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZScpO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpOyAvLyBUcmFjayBiZWZvcmUgcG90ZW50aWFsbHkgbm90IG1lZXRpbmcgdGhlIGludmFyaWFudFxuXG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8ICcnfScuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZWRBY3Rpb24gPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7IC8vIFRyYWNrIGJlZm9yZSBwb3RlbnRpYWxseSBub3QgbWVldGluZyB0aGUgaW52YXJpYW50XG5cbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDIwKSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBpbnNpZGUgYSBkaXNwYXRjaCwgaW4gdGhlIHBhdGg6ICR7cmVzdWx0LnBhdGggfHwgJyd9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5KGFjdGlvbil9LiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZWRBY3Rpb247XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn0iLCJpbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBpc0FjdGlvbiwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGdldFRpbWVNZWFzdXJlVXRpbHMgfSBmcm9tICcuL3V0aWxzJztcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgXCJwbGFpblwiLCBpLmUuIGEgdmFsdWUgdGhhdCBpcyBlaXRoZXJcbiAqIGRpcmVjdGx5IEpTT04tc2VyaWFsaXphYmxlIChib29sZWFuLCBudW1iZXIsIHN0cmluZywgYXJyYXksIHBsYWluIG9iamVjdClcbiAqIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbih2YWw6IGFueSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdib29sZWFuJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBBcnJheS5pc0FycmF5KHZhbCkgfHwgaXNQbGFpbk9iamVjdCh2YWwpO1xufVxuaW50ZXJmYWNlIE5vblNlcmlhbGl6YWJsZVZhbHVlIHtcbiAga2V5UGF0aDogc3RyaW5nO1xuICB2YWx1ZTogdW5rbm93bjtcbn1cbnR5cGUgSWdub3JlUGF0aHMgPSByZWFkb25seSAoc3RyaW5nIHwgUmVnRXhwKVtdO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZTogdW5rbm93biwgcGF0aDogc3RyaW5nID0gJycsIGlzU2VyaWFsaXphYmxlOiAodmFsdWU6IHVua25vd24pID0+IGJvb2xlYW4gPSBpc1BsYWluLCBnZXRFbnRyaWVzPzogKHZhbHVlOiB1bmtub3duKSA9PiBbc3RyaW5nLCBhbnldW10sIGlnbm9yZWRQYXRoczogSWdub3JlUGF0aHMgPSBbXSwgY2FjaGU/OiBXZWFrU2V0PG9iamVjdD4pOiBOb25TZXJpYWxpemFibGVWYWx1ZSB8IGZhbHNlIHtcbiAgbGV0IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlOiBOb25TZXJpYWxpemFibGVWYWx1ZSB8IGZhbHNlO1xuXG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgJzxyb290PicsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY2FjaGU/Lmhhcyh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcblxuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKGlnbm9yZWQgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuXG4gICAgICBpZiAoZm91bmROZXN0ZWRTZXJpYWxpemFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpIGNhY2hlLmFkZCh2YWx1ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZTogb2JqZWN0KSB7XG4gIGlmICghT2JqZWN0LmlzRnJvemVuKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoY29uc3QgbmVzdGVkVmFsdWUgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpIHtcbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlICE9PSAnb2JqZWN0JyB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBPcHRpb25zIGZvciBgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKClgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgY29uc2lkZXJlZCBzZXJpYWxpemFibGUuIFRoaXNcbiAgICogZnVuY3Rpb24gaXMgYXBwbGllZCByZWN1cnNpdmVseSB0byBldmVyeSB2YWx1ZSBjb250YWluZWQgaW4gdGhlXG4gICAqIHN0YXRlLiBEZWZhdWx0cyB0byBgaXNQbGFpbigpYC5cbiAgICovXG4gIGlzU2VyaWFsaXphYmxlPzogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmV0cmlldmUgZW50cmllcyBmcm9tIGVhY2hcbiAgICogdmFsdWUuICBJZiB1bnNwZWNpZmllZCwgYE9iamVjdC5lbnRyaWVzYCB3aWxsIGJlIHVzZWQuIERlZmF1bHRzXG4gICAqIHRvIGB1bmRlZmluZWRgLlxuICAgKi9cblxuICBnZXRFbnRyaWVzPzogKHZhbHVlOiBhbnkpID0+IFtzdHJpbmcsIGFueV1bXTtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGFjdGlvbiB0eXBlcyB0byBpZ25vcmUgd2hlbiBjaGVja2luZyBmb3Igc2VyaWFsaXphYmlsaXR5LlxuICAgKiBEZWZhdWx0cyB0byBbXVxuICAgKi9cblxuICBpZ25vcmVkQWN0aW9ucz86IHN0cmluZ1tdO1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgZG90LXNlcGFyYXRlZCBwYXRoIHN0cmluZ3Mgb3IgcmVndWxhciBleHByZXNzaW9ucyB0byBpZ25vcmVcbiAgICogd2hlbiBjaGVja2luZyBmb3Igc2VyaWFsaXphYmlsaXR5LCBEZWZhdWx0cyB0b1xuICAgKiBbJ21ldGEuYXJnJywgJ21ldGEuYmFzZVF1ZXJ5TWV0YSddXG4gICAqL1xuXG4gIGlnbm9yZWRBY3Rpb25QYXRocz86IChzdHJpbmcgfCBSZWdFeHApW107XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBkb3Qtc2VwYXJhdGVkIHBhdGggc3RyaW5ncyBvciByZWd1bGFyIGV4cHJlc3Npb25zIHRvIGlnbm9yZVxuICAgKiB3aGVuIGNoZWNraW5nIGZvciBzZXJpYWxpemFiaWxpdHksIERlZmF1bHRzIHRvIFtdXG4gICAqL1xuXG4gIGlnbm9yZWRQYXRocz86IChzdHJpbmcgfCBSZWdFeHApW107XG4gIC8qKlxuICAgKiBFeGVjdXRpb24gdGltZSB3YXJuaW5nIHRocmVzaG9sZC4gSWYgdGhlIG1pZGRsZXdhcmUgdGFrZXMgbG9uZ2VyXG4gICAqIHRoYW4gYHdhcm5BZnRlcmAgbXMsIGEgd2FybmluZyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgY29uc29sZS5cbiAgICogRGVmYXVsdHMgdG8gMzJtcy5cbiAgICovXG5cbiAgd2FybkFmdGVyPzogbnVtYmVyO1xuICAvKipcbiAgICogT3B0IG91dCBvZiBjaGVja2luZyBzdGF0ZS4gV2hlbiBzZXQgdG8gYHRydWVgLCBvdGhlciBzdGF0ZS1yZWxhdGVkIHBhcmFtcyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqL1xuXG4gIGlnbm9yZVN0YXRlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIE9wdCBvdXQgb2YgY2hlY2tpbmcgYWN0aW9ucy4gV2hlbiBzZXQgdG8gYHRydWVgLCBvdGhlciBhY3Rpb24tcmVsYXRlZCBwYXJhbXMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKi9cblxuICBpZ25vcmVBY3Rpb25zPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIE9wdCBvdXQgb2YgY2FjaGluZyB0aGUgcmVzdWx0cy4gVGhlIGNhY2hlIHVzZXMgYSBXZWFrU2V0IGFuZCBzcGVlZHMgdXAgcmVwZWF0ZWQgY2hlY2tpbmcgcHJvY2Vzc2VzLlxuICAgKiBUaGUgY2FjaGUgaXMgYXV0b21hdGljYWxseSBkaXNhYmxlZCBpZiBubyBicm93c2VyIHN1cHBvcnQgZm9yIFdlYWtTZXQgaXMgcHJlc2VudC5cbiAgICovXG5cbiAgZGlzYWJsZUNhY2hlPzogYm9vbGVhbjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1pZGRsZXdhcmUgdGhhdCwgYWZ0ZXIgZXZlcnkgc3RhdGUgY2hhbmdlLCBjaGVja3MgaWYgdGhlIG5ld1xuICogc3RhdGUgaXMgc2VyaWFsaXphYmxlLiBJZiBhIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgaXMgZm91bmQgd2l0aGluIHRoZVxuICogc3RhdGUsIGFuIGVycm9yIGlzIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgTWlkZGxld2FyZSBvcHRpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnM6IFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgPSB7fSk6IE1pZGRsZXdhcmUge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxuICAgICAgZ2V0RW50cmllcyxcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXG4gICAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbJ21ldGEuYXJnJywgJ21ldGEuYmFzZVF1ZXJ5TWV0YSddLFxuICAgICAgaWdub3JlZFBhdGhzID0gW10sXG4gICAgICB3YXJuQWZ0ZXIgPSAzMixcbiAgICAgIGlnbm9yZVN0YXRlID0gZmFsc2UsXG4gICAgICBpZ25vcmVBY3Rpb25zID0gZmFsc2UsXG4gICAgICBkaXNhYmxlQ2FjaGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhY2hlOiBXZWFrU2V0PG9iamVjdD4gfCB1bmRlZmluZWQgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdG9yZUFQSSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgICBpZiAoIWlzQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsICdTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnKTtcblxuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoKGFjdGlvbi50eXBlIGFzIGFueSkpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgJycsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkQWN0aW9uUGF0aHMsIGNhY2hlKTtcblxuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsICdcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiAnLCBhY3Rpb24sICdcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKScsICdcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsICcnLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG5cbiAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxuVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhpcyBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX0uXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59IiwiaW1wb3J0IHR5cGUgeyBTdG9yZUVuaGFuY2VyIH0gZnJvbSAncmVkdXgnO1xuZXhwb3J0IGNvbnN0IFNIT1VMRF9BVVRPQkFUQ0ggPSAnUlRLX2F1dG9CYXRjaCc7XG5leHBvcnQgY29uc3QgcHJlcGFyZUF1dG9CYXRjaGVkID0gPFQsPigpID0+IChwYXlsb2FkOiBUKToge1xuICBwYXlsb2FkOiBUO1xuICBtZXRhOiB1bmtub3duO1xufSA9PiAoe1xuICBwYXlsb2FkLFxuICBtZXRhOiB7XG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gIH1cbn0pO1xuXG5jb25zdCBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0OiBudW1iZXIpID0+IHtcbiAgcmV0dXJuIChub3RpZnk6ICgpID0+IHZvaWQpID0+IHtcbiAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XG4gIH07XG59OyAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd29uJ3QgZXhpc3QgaW4gU1NSIGVudmlyb25tZW50cy5cbi8vIEZhbGwgYmFjayB0byBhIHZhZ3VlIGFwcHJveGltYXRpb24ganVzdCB0byBrZWVwIGZyb20gZXJyb3JpbmcuXG5cblxuY29uc3QgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcigxMCk7XG5leHBvcnQgdHlwZSBBdXRvQmF0Y2hPcHRpb25zID0ge1xuICB0eXBlOiAndGljayc7XG59IHwge1xuICB0eXBlOiAndGltZXInO1xuICB0aW1lb3V0OiBudW1iZXI7XG59IHwge1xuICB0eXBlOiAncmFmJztcbn0gfCB7XG4gIHR5cGU6ICdjYWxsYmFjayc7XG4gIHF1ZXVlTm90aWZpY2F0aW9uOiAobm90aWZ5OiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xufTtcbi8qKlxuICogQSBSZWR1eCBzdG9yZSBlbmhhbmNlciB0aGF0IHdhdGNoZXMgZm9yIFwibG93LXByaW9yaXR5XCIgYWN0aW9ucywgYW5kIGRlbGF5c1xuICogbm90aWZ5aW5nIHN1YnNjcmliZXJzIHVudGlsIGVpdGhlciB0aGUgcXVldWVkIGNhbGxiYWNrIGV4ZWN1dGVzIG9yIHRoZVxuICogbmV4dCBcInN0YW5kYXJkLXByaW9yaXR5XCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gKlxuICogVGhpcyBhbGxvd3MgZGlzcGF0Y2hpbmcgbXVsdGlwbGUgXCJsb3ctcHJpb3JpdHlcIiBhY3Rpb25zIGluIGEgcm93IHdpdGggb25seVxuICogYSBzaW5nbGUgc3Vic2NyaWJlciBub3RpZmljYXRpb24gdG8gdGhlIFVJIGFmdGVyIHRoZSBzZXF1ZW5jZSBvZiBhY3Rpb25zXG4gKiBpcyBmaW5pc2hlZCwgdGh1cyBpbXByb3ZpbmcgVUkgcmUtcmVuZGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIFdhdGNoZXMgZm9yIGFjdGlvbnMgd2l0aCB0aGUgYGFjdGlvbi5tZXRhW1NIT1VMRF9BVVRPQkFUQ0hdYCBhdHRyaWJ1dGUuXG4gKiBUaGlzIGNhbiBiZSBhZGRlZCB0byBgYWN0aW9uLm1ldGFgIG1hbnVhbGx5LCBvciBieSB1c2luZyB0aGVcbiAqIGBwcmVwYXJlQXV0b0JhdGNoZWRgIGhlbHBlci5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCB3aWxsIHF1ZXVlIGEgbm90aWZpY2F0aW9uIGZvciB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHRpY2suXG4gKiBIb3dldmVyLCB5b3UgY2FuIHBhc3Mgc2V2ZXJhbCBvdGhlciBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgYmVoYXZpb3I6XG4gKiAtIGB7dHlwZTogJ3RpY2snfWA6IHF1ZXVlcyB1c2luZyBgcXVldWVNaWNyb3Rhc2tgXG4gKiAtIGB7dHlwZTogJ3RpbWVyJywgdGltZW91dDogbnVtYmVyfWA6IHF1ZXVlcyB1c2luZyBgc2V0VGltZW91dGBcbiAqIC0gYHt0eXBlOiAncmFmJ31gOiBxdWV1ZXMgdXNpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgKGRlZmF1bHQpXG4gKiAtIGB7dHlwZTogJ2NhbGxiYWNrJywgcXVldWVOb3RpZmljYXRpb246IChub3RpZnk6ICgpID0+IHZvaWQpID0+IHZvaWR9YDogbGV0cyB5b3UgcHJvdmlkZSB5b3VyIG93biBjYWxsYmFja1xuICpcbiAqXG4gKi9cblxuZXhwb3J0IGNvbnN0IGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnM6IEF1dG9CYXRjaE9wdGlvbnMgPSB7XG4gIHR5cGU6ICdyYWYnXG59KTogU3RvcmVFbmhhbmNlciA9PiBuZXh0ID0+ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gbmV4dCguLi5hcmdzKTtcbiAgbGV0IG5vdGlmeWluZyA9IHRydWU7XG4gIGxldCBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICBsZXQgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVycyA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKTtcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gJ3RpY2snID8gcXVldWVNaWNyb3Rhc2sgOiBvcHRpb25zLnR5cGUgPT09ICdyYWYnID8gckFGIDogb3B0aW9ucy50eXBlID09PSAnY2FsbGJhY2snID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XG5cbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIC8vIFdlJ3JlIHJ1bm5pbmcgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCB0aWNrLlxuICAgIC8vIFJ1biB0aGUgcmVhbCBsaXN0ZW5lciBjYWxsYmFja3MgdG8gYWN0dWFsbHkgdXBkYXRlIHRoZSBVSS5cbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcblxuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGwgPT4gbCgpKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXI6ICgpID0+IHZvaWQpIHtcbiAgICAgIC8vIEVhY2ggd3JhcHBlZCBsaXN0ZW5lciB3aWxsIG9ubHkgY2FsbCB0aGUgcmVhbCBsaXN0ZW5lciBpZlxuICAgICAgLy8gdGhlIGBub3RpZnlpbmdgIGZsYWcgaXMgY3VycmVudGx5IGFjdGl2ZSB3aGVuIGl0J3MgY2FsbGVkLlxuICAgICAgLy8gVGhpcyBsZXRzIHRoZSBiYXNlIHN0b3JlIHdvcmsgYXMgbm9ybWFsLCB3aGlsZSB0aGUgYWN0dWFsIFVJXG4gICAgICAvLyB1cGRhdGUgYmVjb21lcyBjb250cm9sbGVkIGJ5IHRoaXMgZW5oYW5jZXIuXG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXI6IHR5cGVvZiBsaXN0ZW5lciA9ICgpID0+IG5vdGlmeWluZyAmJiBsaXN0ZW5lcigpO1xuXG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb246IGFueSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiBkb2VzIF9ub3RfIGhhdmUgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcsXG4gICAgICAgIC8vIHdlIHJlc3VtZS9jb250aW51ZSBub3JtYWwgbm90aWZ5LWFmdGVyLWVhY2gtZGlzcGF0Y2ggYmVoYXZpb3JcbiAgICAgICAgbm90aWZ5aW5nID0gIWFjdGlvbj8ubWV0YT8uW1NIT1VMRF9BVVRPQkFUQ0hdOyAvLyBJZiBhIGBub3RpZnlMaXN0ZW5lcnNgIG1pY3JvdGFzayB3YXMgcXVldWVkLCB5b3UgY2FuJ3QgY2FuY2VsIGl0LlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBzZXQgYSBmbGFnIHNvIHRoYXQgaXQncyBhIG5vLW9wIHdoZW4gaXQgZG9lcyBydW5cblxuICAgICAgICBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9ICFub3RpZnlpbmc7XG5cbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgLy8gV2UndmUgc2VlbiBhdCBsZWFzdCAxIGFjdGlvbiB3aXRoIGBTSE9VTERfQVVUT0JBVENIYC4gVHJ5IHRvIHF1ZXVlXG4gICAgICAgICAgLy8gYSBtaWNyb3Rhc2sgdG8gbm90aWZ5IGxpc3RlbmVycyBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHRpY2suXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgZW5xdWV1ZSB0aGlzIF9vbmNlXyBwZXIgdGljay5cbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gR28gYWhlYWQgYW5kIHByb2Nlc3MgdGhlIGFjdGlvbiBhcyB1c3VhbCwgaW5jbHVkaW5nIHJlZHVjZXJzLlxuICAgICAgICAvLyBJZiBub3JtYWwgbm90aWZpY2F0aW9uIGJlaGF2aW9yIGlzIGVuYWJsZWQsIHRoZSBzdG9yZSB3aWxsIG5vdGlmeVxuICAgICAgICAvLyBhbGwgb2YgaXRzIG93biBsaXN0ZW5lcnMsIGFuZCB0aGUgd3JhcHBlciBjYWxsYmFja3MgYWJvdmUgd2lsbFxuICAgICAgICAvLyBzZWUgYG5vdGlmeWluZ2AgaXMgdHJ1ZSBhbmQgcGFzcyBvbiB0byB0aGUgcmVhbCBsaXN0ZW5lciBjYWxsYmFja3MuXG4gICAgICAgIC8vIElmIHdlJ3JlIFwiYmF0Y2hpbmdcIiBiZWhhdmlvciwgdGhlbiB0aGUgd3JhcHBlZCBjYWxsYmFja3Mgd2lsbFxuICAgICAgICAvLyBiYWlsIG91dCwgY2F1c2luZyB0aGUgYmFzZSBzdG9yZSBub3RpZmljYXRpb24gYmVoYXZpb3IgdG8gYmUgbm8tb3BzLlxuXG5cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBBc3N1bWUgd2UncmUgYmFjayB0byBub3JtYWwgYmVoYXZpb3IgYWZ0ZXIgZWFjaCBhY3Rpb25cbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59OyIsImltcG9ydCB0eXBlIHsgU3RvcmVFbmhhbmNlciB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgQXV0b0JhdGNoT3B0aW9ucyB9IGZyb20gJy4vYXV0b0JhdGNoRW5oYW5jZXInO1xuaW1wb3J0IHsgYXV0b0JhdGNoRW5oYW5jZXIgfSBmcm9tICcuL2F1dG9CYXRjaEVuaGFuY2VyJztcbmltcG9ydCB7IFR1cGxlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmVzIH0gZnJvbSAnLi9jb25maWd1cmVTdG9yZSc7XG5pbXBvcnQgdHlwZSB7IEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnMgfSBmcm9tICcuL3RzSGVscGVycyc7XG50eXBlIEdldERlZmF1bHRFbmhhbmNlcnNPcHRpb25zID0ge1xuICBhdXRvQmF0Y2g/OiBib29sZWFuIHwgQXV0b0JhdGNoT3B0aW9ucztcbn07XG5leHBvcnQgdHlwZSBHZXREZWZhdWx0RW5oYW5jZXJzPE0gZXh0ZW5kcyBNaWRkbGV3YXJlczxhbnk+PiA9IChvcHRpb25zPzogR2V0RGVmYXVsdEVuaGFuY2Vyc09wdGlvbnMpID0+IFR1cGxlPFtTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnM8TT47XG59Pl0+O1xuZXhwb3J0IGNvbnN0IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IDxNIGV4dGVuZHMgTWlkZGxld2FyZXM8YW55Piw+KG1pZGRsZXdhcmVFbmhhbmNlcjogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHRyYWN0RGlzcGF0Y2hFeHRlbnNpb25zPE0+O1xufT4pOiBHZXREZWZhdWx0RW5oYW5jZXJzPE0+ID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGU8U3RvcmVFbmhhbmNlcltdPihtaWRkbGV3YXJlRW5oYW5jZXIpO1xuXG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gJ29iamVjdCcgPyBhdXRvQmF0Y2ggOiB1bmRlZmluZWQpKTtcbiAgfVxuXG4gIHJldHVybiAoZW5oYW5jZXJBcnJheSBhcyBhbnkpO1xufTsiLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHsgRHJhZnQgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdCwgaXNEcmFmdGFibGUgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiwgUmVkdWNlciwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXIgfSBmcm9tICcuL21hcEJ1aWxkZXJzJztcbmltcG9ydCB7IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIH0gZnJvbSAnLi9tYXBCdWlsZGVycyc7XG5pbXBvcnQgdHlwZSB7IE5vSW5mZXIsIFR5cGVHdWFyZCB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IGZyZWV6ZURyYWZ0YWJsZSB9IGZyb20gJy4vdXRpbHMnO1xuLyoqXG4gKiBEZWZpbmVzIGEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBjb3JyZXNwb25kaW5nIGFjdGlvbiBvYmplY3Qgc2hhcGVzLlxuICpcbiAqIEBkZXByZWNhdGVkIFRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIG1hbnVhbGx5IC0gaXQgaXMgb25seSB1c2VkIGZvciBpbnRlcm5hbFxuICogICAgICAgICAgICAgaW5mZXJlbmNlIHB1cnBvc2VzIGFuZCBzaG91bGQgbm90IGhhdmUgYW55IGZ1cnRoZXIgdmFsdWUuXG4gKiAgICAgICAgICAgICBJdCBtaWdodCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgQWN0aW9uczxUIGV4dGVuZHMga2V5b2YgYW55ID0gc3RyaW5nPiA9IFJlY29yZDxULCBBY3Rpb24+O1xuZXhwb3J0IHR5cGUgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uPFMsIEEgZXh0ZW5kcyBBY3Rpb24+ID0ge1xuICBtYXRjaGVyOiBUeXBlR3VhcmQ8QT47XG4gIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIE5vSW5mZXI8QT4+O1xufTtcbmV4cG9ydCB0eXBlIFJlYWRvbmx5QWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvbjxTPiA9IFJlYWRvbmx5QXJyYXk8QWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uPFMsIGFueT4+O1xuZXhwb3J0IHR5cGUgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvbjxTPiA9IEFycmF5PEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbjxTLCBhbnk+Pjtcbi8qKlxuICogQSAqY2FzZSByZWR1Y2VyKiBpcyBhIHJlZHVjZXIgZnVuY3Rpb24gZm9yIGEgc3BlY2lmaWMgYWN0aW9uIHR5cGUuIENhc2VcbiAqIHJlZHVjZXJzIGNhbiBiZSBjb21wb3NlZCB0byBmdWxsIHJlZHVjZXJzIHVzaW5nIGBjcmVhdGVSZWR1Y2VyKClgLlxuICpcbiAqIFVubGlrZSBhIG5vcm1hbCBSZWR1eCByZWR1Y2VyLCBhIGNhc2UgcmVkdWNlciBpcyBuZXZlciBjYWxsZWQgd2l0aCBhblxuICogYHVuZGVmaW5lZGAgc3RhdGUgdG8gZGV0ZXJtaW5lIHRoZSBpbml0aWFsIHN0YXRlLiBJbnN0ZWFkLCB0aGUgaW5pdGlhbFxuICogc3RhdGUgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYXMgYW4gYXJndW1lbnQgdG8gYGNyZWF0ZVJlZHVjZXIoKWAuXG4gKlxuICogSW4gYWRkaXRpb24sIGEgY2FzZSByZWR1Y2VyIGNhbiBjaG9vc2UgdG8gbXV0YXRlIHRoZSBwYXNzZWQtaW4gYHN0YXRlYFxuICogdmFsdWUgZGlyZWN0bHkgaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBuZXcgc3RhdGUuIFRoaXMgZG9lcyBub3QgYWN0dWFsbHlcbiAqIGNhdXNlIHRoZSBzdG9yZSBzdGF0ZSB0byBiZSBtdXRhdGVkIGRpcmVjdGx5OyBpbnN0ZWFkLCB0aGFua3MgdG9cbiAqIFtpbW1lcl0oaHR0cHM6Ly9naXRodWIuY29tL213ZXN0c3RyYXRlL2ltbWVyKSwgdGhlIG11dGF0aW9ucyBhcmVcbiAqIHRyYW5zbGF0ZWQgdG8gY29weSBvcGVyYXRpb25zIHRoYXQgcmVzdWx0IGluIGEgbmV3IHN0YXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgdHlwZSBDYXNlUmVkdWNlcjxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbj4gPSAoc3RhdGU6IERyYWZ0PFM+LCBhY3Rpb246IEEpID0+IE5vSW5mZXI8Uz4gfCB2b2lkIHwgRHJhZnQ8Tm9JbmZlcjxTPj47XG4vKipcbiAqIEEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBjYXNlIHJlZHVjZXJzIGZvciBgY3JlYXRlUmVkdWNlcigpYC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIHNob3VsZCBub3QgYmUgdXNlZCBtYW51YWxseSAtIGl0IGlzIG9ubHkgdXNlZFxuICogICAgICAgICAgICAgZm9yIGludGVybmFsIGluZmVyZW5jZSBwdXJwb3NlcyBhbmQgdXNpbmcgaXQgbWFudWFsbHlcbiAqICAgICAgICAgICAgIHdvdWxkIGxlYWQgdG8gdHlwZSBlcmFzdXJlLlxuICogICAgICAgICAgICAgSXQgbWlnaHQgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCB0eXBlIENhc2VSZWR1Y2VyczxTLCBBUyBleHRlbmRzIEFjdGlvbnM+ID0geyBbVCBpbiBrZXlvZiBBU106IEFTW1RdIGV4dGVuZHMgQWN0aW9uID8gQ2FzZVJlZHVjZXI8UywgQVNbVF0+IDogdm9pZCB9O1xuZXhwb3J0IHR5cGUgTm90RnVuY3Rpb248VD4gPSBUIGV4dGVuZHMgRnVuY3Rpb24gPyBuZXZlciA6IFQ7XG5cbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbjxTPih4OiB1bmtub3duKTogeCBpcyAoKSA9PiBTIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgdHlwZSBSZWR1Y2VyV2l0aEluaXRpYWxTdGF0ZTxTIGV4dGVuZHMgTm90RnVuY3Rpb248YW55Pj4gPSBSZWR1Y2VyPFM+ICYge1xuICBnZXRJbml0aWFsU3RhdGU6ICgpID0+IFM7XG59O1xuLyoqXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZGVmaW5pbmcgYSByZWR1Y2VyIGFzIGEgbWFwcGluZyBmcm9tIGFjdGlvblxuICogdHlwZSB0byAqY2FzZSByZWR1Y2VyKiBmdW5jdGlvbnMgdGhhdCBoYW5kbGUgdGhlc2UgYWN0aW9uIHR5cGVzLiBUaGVcbiAqIHJlZHVjZXIncyBpbml0aWFsIHN0YXRlIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBib2R5IG9mIGV2ZXJ5IGNhc2UgcmVkdWNlciBpcyBpbXBsaWNpdGx5IHdyYXBwZWQgd2l0aCBhIGNhbGwgdG9cbiAqIGBwcm9kdWNlKClgIGZyb20gdGhlIFtpbW1lcl0oaHR0cHM6Ly9naXRodWIuY29tL213ZXN0c3RyYXRlL2ltbWVyKSBsaWJyYXJ5LlxuICogVGhpcyBtZWFucyB0aGF0IHJhdGhlciB0aGFuIHJldHVybmluZyBhIG5ldyBzdGF0ZSBvYmplY3QsIHlvdSBjYW4gYWxzb1xuICogbXV0YXRlIHRoZSBwYXNzZWQtaW4gc3RhdGUgb2JqZWN0IGRpcmVjdGx5OyB0aGVzZSBtdXRhdGlvbnMgd2lsbCB0aGVuIGJlXG4gKiBhdXRvbWF0aWNhbGx5IGFuZCBlZmZpY2llbnRseSB0cmFuc2xhdGVkIGludG8gY29waWVzLCBnaXZpbmcgeW91IGJvdGhcbiAqIGNvbnZlbmllbmNlIGFuZCBpbW11dGFiaWxpdHkuXG4gKlxuICogQG92ZXJsb2FkU3VtbWFyeVxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyBhIGBidWlsZGVyYCBvYmplY3QgYXMgaXRzIGFyZ3VtZW50LlxuICogVGhhdCBidWlsZGVyIHByb3ZpZGVzIGBhZGRDYXNlYCwgYGFkZE1hdGNoZXJgIGFuZCBgYWRkRGVmYXVsdENhc2VgIGZ1bmN0aW9ucyB0aGF0IG1heSBiZVxuICogY2FsbGVkIHRvIGRlZmluZSB3aGF0IGFjdGlvbnMgdGhpcyByZWR1Y2VyIHdpbGwgaGFuZGxlLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgLSBgU3RhdGUgfCAoKCkgPT4gU3RhdGUpYDogVGhlIGluaXRpYWwgc3RhdGUgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSByZWR1Y2VyIGlzIGNhbGxlZCB0aGUgZmlyc3QgdGltZS4gVGhpcyBtYXkgYWxzbyBiZSBhIFwibGF6eSBpbml0aWFsaXplclwiIGZ1bmN0aW9uLCB3aGljaCBzaG91bGQgcmV0dXJuIGFuIGluaXRpYWwgc3RhdGUgdmFsdWUgd2hlbiBjYWxsZWQuIFRoaXMgd2lsbCBiZSB1c2VkIHdoZW5ldmVyIHRoZSByZWR1Y2VyIGlzIGNhbGxlZCB3aXRoIGB1bmRlZmluZWRgIGFzIGl0cyBzdGF0ZSB2YWx1ZSwgYW5kIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGNhc2VzIGxpa2UgcmVhZGluZyBpbml0aWFsIHN0YXRlIGZyb20gYGxvY2FsU3RvcmFnZWAuXG4gKiBAcGFyYW0gYnVpbGRlckNhbGxiYWNrIC0gYChidWlsZGVyOiBCdWlsZGVyKSA9PiB2b2lkYCBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgYSAqYnVpbGRlciogb2JqZWN0IHRvIGRlZmluZVxuICogICBjYXNlIHJlZHVjZXJzIHZpYSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlKGFjdGlvbkNyZWF0b3JPclR5cGUsIHJlZHVjZXIpYC5cbiAqIEBleGFtcGxlXG5gYGB0c1xuaW1wb3J0IHtcbiAgY3JlYXRlQWN0aW9uLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBVbmtub3duQWN0aW9uLFxuICBQYXlsb2FkQWN0aW9uLFxufSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG5jb25zdCBpbmNyZW1lbnQgPSBjcmVhdGVBY3Rpb248bnVtYmVyPihcImluY3JlbWVudFwiKTtcbmNvbnN0IGRlY3JlbWVudCA9IGNyZWF0ZUFjdGlvbjxudW1iZXI+KFwiZGVjcmVtZW50XCIpO1xuXG5mdW5jdGlvbiBpc0FjdGlvbldpdGhOdW1iZXJQYXlsb2FkKFxuICBhY3Rpb246IFVua25vd25BY3Rpb25cbik6IGFjdGlvbiBpcyBQYXlsb2FkQWN0aW9uPG51bWJlcj4ge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbi5wYXlsb2FkID09PSBcIm51bWJlclwiO1xufVxuXG5jb25zdCByZWR1Y2VyID0gY3JlYXRlUmVkdWNlcihcbiAge1xuICAgIGNvdW50ZXI6IDAsXG4gICAgc3VtT2ZOdW1iZXJQYXlsb2FkczogMCxcbiAgICB1bmhhbmRsZWRBY3Rpb25zOiAwLFxuICB9LFxuICAoYnVpbGRlcikgPT4ge1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDYXNlKGluY3JlbWVudCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gYWN0aW9uIGlzIGluZmVycmVkIGNvcnJlY3RseSBoZXJlXG4gICAgICAgIHN0YXRlLmNvdW50ZXIgKz0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICB9KVxuICAgICAgLy8gWW91IGNhbiBjaGFpbiBjYWxscywgb3IgaGF2ZSBzZXBhcmF0ZSBgYnVpbGRlci5hZGRDYXNlKClgIGxpbmVzIGVhY2ggdGltZVxuICAgICAgLmFkZENhc2UoZGVjcmVtZW50LCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICBzdGF0ZS5jb3VudGVyIC09IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgfSlcbiAgICAgIC8vIFlvdSBjYW4gYXBwbHkgYSBcIm1hdGNoZXIgZnVuY3Rpb25cIiB0byBpbmNvbWluZyBhY3Rpb25zXG4gICAgICAuYWRkTWF0Y2hlcihpc0FjdGlvbldpdGhOdW1iZXJQYXlsb2FkLCAoc3RhdGUsIGFjdGlvbikgPT4ge30pXG4gICAgICAvLyBhbmQgcHJvdmlkZSBhIGRlZmF1bHQgY2FzZSBpZiBubyBvdGhlciBoYW5kbGVycyBtYXRjaGVkXG4gICAgICAuYWRkRGVmYXVsdENhc2UoKHN0YXRlLCBhY3Rpb24pID0+IHt9KTtcbiAgfVxuKTtcbmBgYFxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWR1Y2VyPFMgZXh0ZW5kcyBOb3RGdW5jdGlvbjxhbnk+Pihpbml0aWFsU3RhdGU6IFMgfCAoKCkgPT4gUyksIG1hcE9yQnVpbGRlckNhbGxiYWNrOiAoYnVpbGRlcjogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8Uz4pID0+IHZvaWQpOiBSZWR1Y2VyV2l0aEluaXRpYWxTdGF0ZTxTPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spOyAvLyBFbnN1cmUgdGhlIGluaXRpYWwgc3RhdGUgZ2V0cyBmcm96ZW4gZWl0aGVyIHdheSAoaWYgZHJhZnRhYmxlKVxuXG4gIGxldCBnZXRJbml0aWFsU3RhdGU6ICgpID0+IFM7XG5cbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcblxuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKSwgYWN0aW9uOiBhbnkpOiBTIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyXG4gICAgfSkgPT4gcmVkdWNlcildO1xuXG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoY3IgPT4gISFjcikubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYXNlUmVkdWNlcnMgPSBbZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdO1xuICAgIH1cblxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcik6IFMgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0KHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGEgZHJhZnQsIHdlIG11c3QgYWxyZWFkeSBiZSBpbnNpZGUgYSBgY3JlYXRlTmV4dFN0YXRlYCBjYWxsLFxuICAgICAgICAgIC8vIGxpa2VseSBiZWNhdXNlIHRoaXMgaXMgYmVpbmcgd3JhcHBlZCBpbiBgY3JlYXRlUmVkdWNlcmAsIGBjcmVhdGVTbGljZWAsIG9yIG5lc3RlZFxuICAgICAgICAgIC8vIGluc2lkZSBhbiBleGlzdGluZyBkcmFmdC4gSXQncyBzYWZlIHRvIGp1c3QgcGFzcyB0aGUgZHJhZnQgdG8gdGhlIG11dGF0b3IuXG4gICAgICAgICAgY29uc3QgZHJhZnQgPSAocHJldmlvdXNTdGF0ZSBhcyBEcmFmdDxTPik7IC8vIFdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhbHJlYWR5IGEgZHJhZnRcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCBhcyBTKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNEcmFmdGFibGUocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICAvLyBJZiBzdGF0ZSBpcyBub3QgZHJhZnRhYmxlIChleDogYSBwcmltaXRpdmUsIHN1Y2ggYXMgMCksIHdlIHdhbnQgdG8gZGlyZWN0bHlcbiAgICAgICAgICAvLyByZXR1cm4gdGhlIGNhc2VSZWR1Y2VyIGZ1bmMgYW5kIG5vdCB3cmFwIGl0IHdpdGggcHJvZHVjZS5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcigocHJldmlvdXNTdGF0ZSBhcyBhbnkpLCBhY3Rpb24pO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMig5KSA6ICdBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAocmVzdWx0IGFzIFMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgY3JlYXRlTmV4dFN0YXRlKCkgcHJvZHVjZXMgYW4gSW1tdXRhYmxlPERyYWZ0PFM+PiByYXRoZXJcbiAgICAgICAgICAvLyB0aGFuIGFuIEltbXV0YWJsZTxTPiwgYW5kIFR5cGVTY3JpcHQgY2Fubm90IGZpbmQgb3V0IGhvdyB0byByZWNvbmNpbGVcbiAgICAgICAgICAvLyB0aGVzZSB0d28gdHlwZXMuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZShwcmV2aW91c1N0YXRlLCAoZHJhZnQ6IERyYWZ0PFM+KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG5cbiAgcmVkdWNlci5nZXRJbml0aWFsU3RhdGUgPSBnZXRJbml0aWFsU3RhdGU7XG4gIHJldHVybiAocmVkdWNlciBhcyBSZWR1Y2VyV2l0aEluaXRpYWxTdGF0ZTxTPik7XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTUgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgQ2FzZVJlZHVjZXIsIENhc2VSZWR1Y2VycywgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvbiB9IGZyb20gJy4vY3JlYXRlUmVkdWNlcic7XG5pbXBvcnQgdHlwZSB7IFR5cGVHdWFyZCB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRBY3Rpb25DcmVhdG9yPFR5cGUgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgKC4uLmFyZ3M6IGFueVtdKTogQWN0aW9uPFR5cGU+O1xuICB0eXBlOiBUeXBlO1xufVxuLyoqXG4gKiBBIGJ1aWxkZXIgZm9yIGFuIGFjdGlvbiA8LT4gcmVkdWNlciBtYXAuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+IHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjYXNlIHJlZHVjZXIgdG8gaGFuZGxlIGEgc2luZ2xlIGV4YWN0IGFjdGlvbiB0eXBlLlxuICAgKiBAcmVtYXJrc1xuICAgKiBBbGwgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkQ2FzZWAgbXVzdCBjb21lIGJlZm9yZSBhbnkgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgb3IgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgLlxuICAgKiBAcGFyYW0gYWN0aW9uQ3JlYXRvciAtIEVpdGhlciBhIHBsYWluIGFjdGlvbiB0eXBlIHN0cmluZywgb3IgYW4gYWN0aW9uIGNyZWF0b3IgZ2VuZXJhdGVkIGJ5IFtgY3JlYXRlQWN0aW9uYF0oLi9jcmVhdGVBY3Rpb24pIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhY3Rpb24gdHlwZS5cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICovXG4gIGFkZENhc2U8QWN0aW9uQ3JlYXRvciBleHRlbmRzIFR5cGVkQWN0aW9uQ3JlYXRvcjxzdHJpbmc+PihhY3Rpb25DcmVhdG9yOiBBY3Rpb25DcmVhdG9yLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxBY3Rpb25DcmVhdG9yPj4pOiBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTdGF0ZT47XG4gIC8qKlxuICAgKiBBZGRzIGEgY2FzZSByZWR1Y2VyIHRvIGhhbmRsZSBhIHNpbmdsZSBleGFjdCBhY3Rpb24gdHlwZS5cbiAgICogQHJlbWFya3NcbiAgICogQWxsIGNhbGxzIHRvIGBidWlsZGVyLmFkZENhc2VgIG11c3QgY29tZSBiZWZvcmUgYW55IGNhbGxzIHRvIGBidWlsZGVyLmFkZE1hdGNoZXJgIG9yIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYC5cbiAgICogQHBhcmFtIGFjdGlvbkNyZWF0b3IgLSBFaXRoZXIgYSBwbGFpbiBhY3Rpb24gdHlwZSBzdHJpbmcsIG9yIGFuIGFjdGlvbiBjcmVhdG9yIGdlbmVyYXRlZCBieSBbYGNyZWF0ZUFjdGlvbmBdKC4vY3JlYXRlQWN0aW9uKSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgYWN0aW9uIHR5cGUuXG4gICAqIEBwYXJhbSByZWR1Y2VyIC0gVGhlIGFjdHVhbCBjYXNlIHJlZHVjZXIgZnVuY3Rpb24uXG4gICAqL1xuXG4gIGFkZENhc2U8VHlwZSBleHRlbmRzIHN0cmluZywgQSBleHRlbmRzIEFjdGlvbjxUeXBlPj4odHlwZTogVHlwZSwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEE+KTogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+O1xuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byBtYXRjaCB5b3VyIGluY29taW5nIGFjdGlvbnMgYWdhaW5zdCB5b3VyIG93biBmaWx0ZXIgZnVuY3Rpb24gaW5zdGVhZCBvZiBvbmx5IHRoZSBgYWN0aW9uLnR5cGVgIHByb3BlcnR5LlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBtdWx0aXBsZSBtYXRjaGVyIHJlZHVjZXJzIG1hdGNoLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlclxuICAgKiB0aGV5IHdlcmUgZGVmaW5lZCBpbiAtIGV2ZW4gaWYgYSBjYXNlIHJlZHVjZXIgYWxyZWFkeSBtYXRjaGVkLlxuICAgKiBBbGwgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgbXVzdCBjb21lIGFmdGVyIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlYCBhbmQgYmVmb3JlIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAuXG4gICAqIEBwYXJhbSBtYXRjaGVyIC0gQSBtYXRjaGVyIGZ1bmN0aW9uLiBJbiBUeXBlU2NyaXB0LCB0aGlzIHNob3VsZCBiZSBhIFt0eXBlIHByZWRpY2F0ZV0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svMi9uYXJyb3dpbmcuaHRtbCN1c2luZy10eXBlLXByZWRpY2F0ZXMpXG4gICAqICAgZnVuY3Rpb25cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgYGBgdHNcbiAgaW1wb3J0IHtcbiAgY3JlYXRlQWN0aW9uLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBBc3luY1RodW5rLFxuICBVbmtub3duQWN0aW9uLFxuICB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG4gIHR5cGUgR2VuZXJpY0FzeW5jVGh1bmsgPSBBc3luY1RodW5rPHVua25vd24sIHVua25vd24sIGFueT47XG4gIHR5cGUgUGVuZGluZ0FjdGlvbiA9IFJldHVyblR5cGU8R2VuZXJpY0FzeW5jVGh1bmtbXCJwZW5kaW5nXCJdPjtcbiAgdHlwZSBSZWplY3RlZEFjdGlvbiA9IFJldHVyblR5cGU8R2VuZXJpY0FzeW5jVGh1bmtbXCJyZWplY3RlZFwiXT47XG4gIHR5cGUgRnVsZmlsbGVkQWN0aW9uID0gUmV0dXJuVHlwZTxHZW5lcmljQXN5bmNUaHVua1tcImZ1bGZpbGxlZFwiXT47XG4gIGNvbnN0IGluaXRpYWxTdGF0ZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBjb25zdCByZXNldEFjdGlvbiA9IGNyZWF0ZUFjdGlvbihcInJlc2V0LXRyYWNrZWQtbG9hZGluZy1zdGF0ZVwiKTtcbiAgZnVuY3Rpb24gaXNQZW5kaW5nQWN0aW9uKGFjdGlvbjogVW5rbm93bkFjdGlvbik6IGFjdGlvbiBpcyBQZW5kaW5nQWN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBhY3Rpb24udHlwZS5lbmRzV2l0aChcIi9wZW5kaW5nXCIpO1xuICB9XG4gIGNvbnN0IHJlZHVjZXIgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgKGJ1aWxkZXIpID0+IHtcbiAgYnVpbGRlclxuICAgIC5hZGRDYXNlKHJlc2V0QWN0aW9uLCAoKSA9PiBpbml0aWFsU3RhdGUpXG4gICAgLy8gbWF0Y2hlciBjYW4gYmUgZGVmaW5lZCBvdXRzaWRlIGFzIGEgdHlwZSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAgICAuYWRkTWF0Y2hlcihpc1BlbmRpbmdBY3Rpb24sIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZVthY3Rpb24ubWV0YS5yZXF1ZXN0SWRdID0gXCJwZW5kaW5nXCI7XG4gICAgfSlcbiAgICAuYWRkTWF0Y2hlcihcbiAgICAgIC8vIG1hdGNoZXIgY2FuIGJlIGRlZmluZWQgaW5saW5lIGFzIGEgdHlwZSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAgICAgIChhY3Rpb24pOiBhY3Rpb24gaXMgUmVqZWN0ZWRBY3Rpb24gPT4gYWN0aW9uLnR5cGUuZW5kc1dpdGgoXCIvcmVqZWN0ZWRcIiksXG4gICAgICAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5yZXF1ZXN0SWRdID0gXCJyZWplY3RlZFwiO1xuICAgICAgfVxuICAgIClcbiAgICAvLyBtYXRjaGVyIGNhbiBqdXN0IHJldHVybiBib29sZWFuIGFuZCB0aGUgbWF0Y2hlciBjYW4gcmVjZWl2ZSBhIGdlbmVyaWMgYXJndW1lbnRcbiAgICAuYWRkTWF0Y2hlcjxGdWxmaWxsZWRBY3Rpb24+KFxuICAgICAgKGFjdGlvbikgPT4gYWN0aW9uLnR5cGUuZW5kc1dpdGgoXCIvZnVsZmlsbGVkXCIpLFxuICAgICAgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgc3RhdGVbYWN0aW9uLm1ldGEucmVxdWVzdElkXSA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG4gIGBgYFxuICAgKi9cblxuICBhZGRNYXRjaGVyPEE+KG1hdGNoZXI6IFR5cGVHdWFyZDxBPiB8ICgoYWN0aW9uOiBhbnkpID0+IGJvb2xlYW4pLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQSBleHRlbmRzIEFjdGlvbiA/IEEgOiBBICYgQWN0aW9uPik6IE9taXQ8QWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+LCAnYWRkQ2FzZSc+O1xuICAvKipcbiAgICogQWRkcyBhIFwiZGVmYXVsdCBjYXNlXCIgcmVkdWNlciB0aGF0IGlzIGV4ZWN1dGVkIGlmIG5vIGNhc2UgcmVkdWNlciBhbmQgbm8gbWF0Y2hlclxuICAgKiByZWR1Y2VyIHdhcyBleGVjdXRlZCBmb3IgdGhpcyBhY3Rpb24uXG4gICAqIEBwYXJhbSByZWR1Y2VyIC0gVGhlIGZhbGxiYWNrIFwiZGVmYXVsdCBjYXNlXCIgcmVkdWNlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgYGBgdHNcbiAgaW1wb3J0IHsgY3JlYXRlUmVkdWNlciB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnXG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHsgb3RoZXJBY3Rpb25zOiAwIH1cbiAgY29uc3QgcmVkdWNlciA9IGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBidWlsZGVyID0+IHtcbiAgYnVpbGRlclxuICAgIC8vIC5hZGRDYXNlKC4uLilcbiAgICAvLyAuYWRkTWF0Y2hlciguLi4pXG4gICAgLmFkZERlZmF1bHRDYXNlKChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5vdGhlckFjdGlvbnMrK1xuICAgIH0pXG4gIH0pXG4gIGBgYFxuICAgKi9cblxuICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQWN0aW9uPik6IHt9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrPFM+KGJ1aWxkZXJDYWxsYmFjazogKGJ1aWxkZXI6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFM+KSA9PiB2b2lkKTogW0Nhc2VSZWR1Y2VyczxTLCBhbnk+LCBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+LCBDYXNlUmVkdWNlcjxTLCBBY3Rpb24+IHwgdW5kZWZpbmVkXSB7XG4gIGNvbnN0IGFjdGlvbnNNYXA6IENhc2VSZWR1Y2VyczxTLCBhbnk+ID0ge307XG4gIGNvbnN0IGFjdGlvbk1hdGNoZXJzOiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+ID0gW107XG4gIGxldCBkZWZhdWx0Q2FzZVJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIEFjdGlvbj4gfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGJ1aWxkZXIgPSB7XG4gICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yOiBzdHJpbmcgfCBUeXBlZEFjdGlvbkNyZWF0b3I8YW55PiwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8Uz4pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8qXG4gICAgICAgICB0byBrZWVwIHRoZSBkZWZpbml0aW9uIGJ5IHRoZSB1c2VyIGluIGxpbmUgd2l0aCBhY3R1YWwgYmVoYXZpb3IsXG4gICAgICAgICB3ZSBlbmZvcmNlIGBhZGRDYXNlYCB0byBhbHdheXMgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBhZGRNYXRjaGVyYFxuICAgICAgICAgYXMgbWF0Y2hpbmcgY2FzZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbWF0Y2hlcnNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6ICdgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDI3KSA6ICdgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSAnc3RyaW5nJyA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG5cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDI4KSA6ICdgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0KDI5KSA6ICdgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZSAnICsgYCcke3R5cGV9J2ApO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG5cbiAgICBhZGRNYXRjaGVyPEE+KG1hdGNoZXI6IFR5cGVHdWFyZDxBPiwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8UywgQSBleHRlbmRzIEFjdGlvbiA/IEEgOiBBICYgQWN0aW9uPikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTUoMzApIDogJ2BidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhY3Rpb25NYXRjaGVycy5wdXNoKHtcbiAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgcmVkdWNlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcjogQ2FzZVJlZHVjZXI8UywgQWN0aW9uPikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYoMzEpIDogJ2BidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG5cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufSIsIi8vIEJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FpL25hbm9pZC9ibG9iLzMuMC4yL25vbi1zZWN1cmUvaW5kZXguanNcbi8vIFRoaXMgYWxwaGFiZXQgdXNlcyBgQS1aYS16MC05Xy1gIHN5bWJvbHMuIEEgZ2VuZXRpYyBhbGdvcml0aG0gaGVscGVkXG4vLyBvcHRpbWl6ZSB0aGUgZ3ppcCBjb21wcmVzc2lvbiBmb3IgdGhpcyBhbHBoYWJldC5cbmxldCB1cmxBbHBoYWJldCA9ICdNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXJztcbi8qKlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgbGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJyc7IC8vIEEgY29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKWAuXG5cbiAgbGV0IGkgPSBzaXplO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICAvLyBgfCAwYCBpcyBtb3JlIGNvbXBhY3QgYW5kIGZhc3RlciB0aGFuIGBNYXRoLmZsb29yKClgLlxuICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICB9XG5cbiAgcmV0dXJuIGlkO1xufTsiLCJpbXBvcnQgdHlwZSB7IEFjdGlvbkZyb21NYXRjaGVyLCBNYXRjaGVyLCBVbmlvblRvSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHsgaGFzTWF0Y2hGdW5jdGlvbiB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgQXN5bmNUaHVuaywgQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3IsIEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvciwgQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvciB9IGZyb20gJy4vY3JlYXRlQXN5bmNUaHVuayc7XG4vKiogQHB1YmxpYyAqL1xuXG5leHBvcnQgdHlwZSBBY3Rpb25NYXRjaGluZ0FueU9mPE1hdGNoZXJzIGV4dGVuZHMgWy4uLk1hdGNoZXI8YW55PltdXT4gPSBBY3Rpb25Gcm9tTWF0Y2hlcjxNYXRjaGVyc1tudW1iZXJdPjtcbi8qKiBAcHVibGljICovXG5cbmV4cG9ydCB0eXBlIEFjdGlvbk1hdGNoaW5nQWxsT2Y8TWF0Y2hlcnMgZXh0ZW5kcyBbLi4uTWF0Y2hlcjxhbnk+W11dPiA9IFVuaW9uVG9JbnRlcnNlY3Rpb248QWN0aW9uTWF0Y2hpbmdBbnlPZjxNYXRjaGVycz4+O1xuXG5jb25zdCBtYXRjaGVzID0gKG1hdGNoZXI6IE1hdGNoZXI8YW55PiwgYWN0aW9uOiBhbnkpID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIG1hdGNoZXMgYW55IG9uZSBvZiB0aGUgc3VwcGxpZWQgdHlwZSBndWFyZHMgb3IgYWN0aW9uXG4gKiBjcmVhdG9ycy5cbiAqXG4gKiBAcGFyYW0gbWF0Y2hlcnMgVGhlIHR5cGUgZ3VhcmRzIG9yIGFjdGlvbiBjcmVhdG9ycyB0byBtYXRjaCBhZ2FpbnN0LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FueU9mPE1hdGNoZXJzIGV4dGVuZHMgWy4uLk1hdGNoZXI8YW55PltdXT4oLi4ubWF0Y2hlcnM6IE1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgQWN0aW9uTWF0Y2hpbmdBbnlPZjxNYXRjaGVycz4gPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5zb21lKG1hdGNoZXIgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gbWF0Y2hlcyBhbGwgb2YgdGhlIHN1cHBsaWVkIHR5cGUgZ3VhcmRzIG9yIGFjdGlvblxuICogY3JlYXRvcnMuXG4gKlxuICogQHBhcmFtIG1hdGNoZXJzIFRoZSB0eXBlIGd1YXJkcyBvciBhY3Rpb24gY3JlYXRvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWxsT2Y8TWF0Y2hlcnMgZXh0ZW5kcyBbLi4uTWF0Y2hlcjxhbnk+W11dPiguLi5tYXRjaGVyczogTWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBBY3Rpb25NYXRjaGluZ0FsbE9mPE1hdGNoZXJzPiA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KG1hdGNoZXIgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIGFjdGlvbiBBIHJlZHV4IGFjdGlvblxuICogQHBhcmFtIHZhbGlkU3RhdHVzIEFuIGFycmF5IG9mIHZhbGlkIG1ldGEucmVxdWVzdFN0YXR1cyB2YWx1ZXNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uOiBhbnksIHZhbGlkU3RhdHVzOiByZWFkb25seSBzdHJpbmdbXSkge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0SWQgPSB0eXBlb2YgYWN0aW9uLm1ldGEucmVxdWVzdElkID09PSAnc3RyaW5nJztcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBcnJheShhOiBbYW55XSB8IEFueUFzeW5jVGh1bmtbXSk6IGEgaXMgQW55QXN5bmNUaHVua1tdIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSAnZnVuY3Rpb24nICYmICdwZW5kaW5nJyBpbiBhWzBdICYmICdmdWxmaWxsZWQnIGluIGFbMF0gJiYgJ3JlamVjdGVkJyBpbiBhWzBdO1xufVxuXG5leHBvcnQgdHlwZSBVbmtub3duQXN5bmNUaHVua1BlbmRpbmdBY3Rpb24gPSBSZXR1cm5UeXBlPEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvcjx1bmtub3duPj47XG5leHBvcnQgdHlwZSBQZW5kaW5nQWN0aW9uRnJvbUFzeW5jVGh1bms8VCBleHRlbmRzIEFueUFzeW5jVGh1bms+ID0gQWN0aW9uRnJvbU1hdGNoZXI8VFsncGVuZGluZyddPjtcbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gd2FzIGNyZWF0ZWQgYnkgYW4gYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3IsIGFuZCB0aGF0XG4gKiB0aGUgYWN0aW9uIGlzIHBlbmRpbmcuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BlbmRpbmcoKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uO1xuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNoZWNrXG4gKiB3aGV0aGVyIGFuIGFjdGlvbiBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgcHJvdmlkZWQgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzLFxuICogYW5kIHRoYXQgdGhlIGFjdGlvbiBpcyBwZW5kaW5nLlxuICpcbiAqIEBwYXJhbSBhc3luY1RodW5rcyAob3B0aW9uYWwpIFRoZSBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGVuZGluZzxBc3luY1RodW5rcyBleHRlbmRzIFtBbnlBc3luY1RodW5rLCAuLi5BbnlBc3luY1RodW5rW11dPiguLi5hc3luY1RodW5rczogQXN5bmNUaHVua3MpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBQZW5kaW5nQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT47XG4vKipcbiAqIFRlc3RzIGlmIGBhY3Rpb25gIGlzIGEgcGVuZGluZyB0aHVuayBhY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQZW5kaW5nKGFjdGlvbjogYW55KTogYWN0aW9uIGlzIFVua25vd25Bc3luY1RodW5rUGVuZGluZ0FjdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBpc1BlbmRpbmc8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzIHwgW2FueV0pIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uOiBhbnkpID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgWydwZW5kaW5nJ10pO1xuICB9XG5cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG5cbiAgcmV0dXJuIChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBQZW5kaW5nQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT4gPT4ge1xuICAgIC8vIG5vdGU6IHRoaXMgdHlwZSB3aWxsIGJlIGNvcnJlY3QgYmVjYXVzZSB3ZSBoYXZlIGF0IGxlYXN0IDEgYXN5bmNUaHVua1xuICAgIGNvbnN0IG1hdGNoZXJzOiBbTWF0Y2hlcjxhbnk+LCAuLi5NYXRjaGVyPGFueT5bXV0gPSAoYXN5bmNUaHVua3MubWFwKGFzeW5jVGh1bmsgPT4gYXN5bmNUaHVuay5wZW5kaW5nKSBhcyBhbnkpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmV4cG9ydCB0eXBlIFVua25vd25Bc3luY1RodW5rUmVqZWN0ZWRBY3Rpb24gPSBSZXR1cm5UeXBlPEFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbkNyZWF0b3I8dW5rbm93biwgdW5rbm93bj4+O1xuZXhwb3J0IHR5cGUgUmVqZWN0ZWRBY3Rpb25Gcm9tQXN5bmNUaHVuazxUIGV4dGVuZHMgQW55QXN5bmNUaHVuaz4gPSBBY3Rpb25Gcm9tTWF0Y2hlcjxUWydyZWplY3RlZCddPjtcbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gd2FzIGNyZWF0ZWQgYnkgYW4gYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3IsIGFuZCB0aGF0XG4gKiB0aGUgYWN0aW9uIGlzIHJlamVjdGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWplY3RlZCgpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uO1xuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNoZWNrXG4gKiB3aGV0aGVyIGFuIGFjdGlvbiBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgcHJvdmlkZWQgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzLFxuICogYW5kIHRoYXQgdGhlIGFjdGlvbiBpcyByZWplY3RlZC5cbiAqXG4gKiBAcGFyYW0gYXN5bmNUaHVua3MgKG9wdGlvbmFsKSBUaGUgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlamVjdGVkPEFzeW5jVGh1bmtzIGV4dGVuZHMgW0FueUFzeW5jVGh1bmssIC4uLkFueUFzeW5jVGh1bmtbXV0+KC4uLmFzeW5jVGh1bmtzOiBBc3luY1RodW5rcyk6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIFJlamVjdGVkQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT47XG4vKipcbiAqIFRlc3RzIGlmIGBhY3Rpb25gIGlzIGEgcmVqZWN0ZWQgdGh1bmsgYWN0aW9uXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWQoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBpc1JlamVjdGVkPEFzeW5jVGh1bmtzIGV4dGVuZHMgW0FueUFzeW5jVGh1bmssIC4uLkFueUFzeW5jVGh1bmtbXV0+KC4uLmFzeW5jVGh1bmtzOiBBc3luY1RodW5rcyB8IFthbnldKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbjogYW55KSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFsncmVqZWN0ZWQnXSk7XG4gIH1cblxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG5cbiAgcmV0dXJuIChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBSZWplY3RlZEFjdGlvbkZyb21Bc3luY1RodW5rPEFzeW5jVGh1bmtzW251bWJlcl0+ID0+IHtcbiAgICAvLyBub3RlOiB0aGlzIHR5cGUgd2lsbCBiZSBjb3JyZWN0IGJlY2F1c2Ugd2UgaGF2ZSBhdCBsZWFzdCAxIGFzeW5jVGh1bmtcbiAgICBjb25zdCBtYXRjaGVyczogW01hdGNoZXI8YW55PiwgLi4uTWF0Y2hlcjxhbnk+W11dID0gKGFzeW5jVGh1bmtzLm1hcChhc3luY1RodW5rID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpIGFzIGFueSk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZXhwb3J0IHR5cGUgVW5rbm93bkFzeW5jVGh1bmtSZWplY3RlZFdpdGhWYWx1ZUFjdGlvbiA9IFJldHVyblR5cGU8QXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvcjx1bmtub3duLCB1bmtub3duPj47XG5leHBvcnQgdHlwZSBSZWplY3RlZFdpdGhWYWx1ZUFjdGlvbkZyb21Bc3luY1RodW5rPFQgZXh0ZW5kcyBBbnlBc3luY1RodW5rPiA9IEFjdGlvbkZyb21NYXRjaGVyPFRbJ3JlamVjdGVkJ10+ICYgKFQgZXh0ZW5kcyBBc3luY1RodW5rPGFueSwgYW55LCB7XG4gIHJlamVjdFZhbHVlOiBpbmZlciBSZWplY3RlZFZhbHVlO1xufT4gPyB7XG4gIHBheWxvYWQ6IFJlamVjdGVkVmFsdWU7XG59IDogdW5rbm93bik7XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IGFuIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9yLCBhbmQgdGhhdFxuICogdGhlIGFjdGlvbiBpcyByZWplY3RlZCB3aXRoIHZhbHVlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSgpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uO1xuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNoZWNrXG4gKiB3aGV0aGVyIGFuIGFjdGlvbiBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgcHJvdmlkZWQgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzLFxuICogYW5kIHRoYXQgdGhlIGFjdGlvbiBpcyByZWplY3RlZCB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBhc3luY1RodW5rcyAob3B0aW9uYWwpIFRoZSBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWU8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgUmVqZWN0ZWRXaXRoVmFsdWVBY3Rpb25Gcm9tQXN5bmNUaHVuazxBc3luY1RodW5rc1tudW1iZXJdPjtcbi8qKlxuICogVGVzdHMgaWYgYGFjdGlvbmAgaXMgYSByZWplY3RlZCB0aHVuayBhY3Rpb24gd2l0aCB2YWx1ZVxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlamVjdGVkV2l0aFZhbHVlKGFjdGlvbjogYW55KTogYWN0aW9uIGlzIFVua25vd25Bc3luY1RodW5rUmVqZWN0ZWRBY3Rpb247XG5leHBvcnQgZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZTxBc3luY1RodW5rcyBleHRlbmRzIFtBbnlBc3luY1RodW5rLCAuLi5BbnlBc3luY1RodW5rW11dPiguLi5hc3luY1RodW5rczogQXN5bmNUaHVua3MgfCBbYW55XSkge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbjogYW55KTogYWN0aW9uIGlzIGFueSA9PiB7XG4gICAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZTtcbiAgfTtcblxuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb246IGFueSkgPT4ge1xuICAgICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XG4gIH1cblxuICByZXR1cm4gKGFjdGlvbjogYW55KTogYWN0aW9uIGlzIFJlamVjdGVkQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT4gPT4ge1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmV4cG9ydCB0eXBlIFVua25vd25Bc3luY1RodW5rRnVsZmlsbGVkQWN0aW9uID0gUmV0dXJuVHlwZTxBc3luY1RodW5rRnVsZmlsbGVkQWN0aW9uQ3JlYXRvcjx1bmtub3duLCB1bmtub3duPj47XG5leHBvcnQgdHlwZSBGdWxmaWxsZWRBY3Rpb25Gcm9tQXN5bmNUaHVuazxUIGV4dGVuZHMgQW55QXN5bmNUaHVuaz4gPSBBY3Rpb25Gcm9tTWF0Y2hlcjxUWydmdWxmaWxsZWQnXT47XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IGFuIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9yLCBhbmQgdGhhdFxuICogdGhlIGFjdGlvbiBpcyBmdWxmaWxsZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGZpbGxlZCgpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbjtcbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gYmVsb25ncyB0byBvbmUgb2YgdGhlIHByb3ZpZGVkIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9ycyxcbiAqIGFuZCB0aGF0IHRoZSBhY3Rpb24gaXMgZnVsZmlsbGVkLlxuICpcbiAqIEBwYXJhbSBhc3luY1RodW5rcyAob3B0aW9uYWwpIFRoZSBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVsZmlsbGVkPEFzeW5jVGh1bmtzIGV4dGVuZHMgW0FueUFzeW5jVGh1bmssIC4uLkFueUFzeW5jVGh1bmtbXV0+KC4uLmFzeW5jVGh1bmtzOiBBc3luY1RodW5rcyk6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIEZ1bGZpbGxlZEFjdGlvbkZyb21Bc3luY1RodW5rPEFzeW5jVGh1bmtzW251bWJlcl0+O1xuLyoqXG4gKiBUZXN0cyBpZiBgYWN0aW9uYCBpcyBhIGZ1bGZpbGxlZCB0aHVuayBhY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGdWxmaWxsZWQoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb247XG5leHBvcnQgZnVuY3Rpb24gaXNGdWxmaWxsZWQ8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzIHwgW2FueV0pIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uOiBhbnkpID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgWydmdWxmaWxsZWQnXSk7XG4gIH1cblxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0Z1bGZpbGxlZCgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuXG4gIHJldHVybiAoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgRnVsZmlsbGVkQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT4gPT4ge1xuICAgIC8vIG5vdGU6IHRoaXMgdHlwZSB3aWxsIGJlIGNvcnJlY3QgYmVjYXVzZSB3ZSBoYXZlIGF0IGxlYXN0IDEgYXN5bmNUaHVua1xuICAgIGNvbnN0IG1hdGNoZXJzOiBbTWF0Y2hlcjxhbnk+LCAuLi5NYXRjaGVyPGFueT5bXV0gPSAoYXN5bmNUaHVua3MubWFwKGFzeW5jVGh1bmsgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpIGFzIGFueSk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZXhwb3J0IHR5cGUgVW5rbm93bkFzeW5jVGh1bmtBY3Rpb24gPSBVbmtub3duQXN5bmNUaHVua1BlbmRpbmdBY3Rpb24gfCBVbmtub3duQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uIHwgVW5rbm93bkFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb247XG5leHBvcnQgdHlwZSBBbnlBc3luY1RodW5rID0ge1xuICBwZW5kaW5nOiB7XG4gICAgbWF0Y2g6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIGFueTtcbiAgfTtcbiAgZnVsZmlsbGVkOiB7XG4gICAgbWF0Y2g6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIGFueTtcbiAgfTtcbiAgcmVqZWN0ZWQ6IHtcbiAgICBtYXRjaDogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgYW55O1xuICB9O1xufTtcbmV4cG9ydCB0eXBlIEFjdGlvbnNGcm9tQXN5bmNUaHVuazxUIGV4dGVuZHMgQW55QXN5bmNUaHVuaz4gPSBBY3Rpb25Gcm9tTWF0Y2hlcjxUWydwZW5kaW5nJ10+IHwgQWN0aW9uRnJvbU1hdGNoZXI8VFsnZnVsZmlsbGVkJ10+IHwgQWN0aW9uRnJvbU1hdGNoZXI8VFsncmVqZWN0ZWQnXT47XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IGFuIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9yLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKCk6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIFVua25vd25Bc3luY1RodW5rQWN0aW9uO1xuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNoZWNrXG4gKiB3aGV0aGVyIGFuIGFjdGlvbiBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgcHJvdmlkZWQgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzLlxuICpcbiAqIEBwYXJhbSBhc3luY1RodW5rcyAob3B0aW9uYWwpIFRoZSBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbjxBc3luY1RodW5rcyBleHRlbmRzIFtBbnlBc3luY1RodW5rLCAuLi5BbnlBc3luY1RodW5rW11dPiguLi5hc3luY1RodW5rczogQXN5bmNUaHVua3MpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBBY3Rpb25zRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT47XG4vKipcbiAqIFRlc3RzIGlmIGBhY3Rpb25gIGlzIGEgdGh1bmsgYWN0aW9uXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbihhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua0FjdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb248QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzIHwgW2FueV0pIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uOiBhbnkpID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgWydwZW5kaW5nJywgJ2Z1bGZpbGxlZCcsICdyZWplY3RlZCddKTtcbiAgfVxuXG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuXG4gIHJldHVybiAoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgQWN0aW9uc0Zyb21Bc3luY1RodW5rPEFzeW5jVGh1bmtzW251bWJlcl0+ID0+IHtcbiAgICAvLyBub3RlOiB0aGlzIHR5cGUgd2lsbCBiZSBjb3JyZWN0IGJlY2F1c2Ugd2UgaGF2ZSBhdCBsZWFzdCAxIGFzeW5jVGh1bmtcbiAgICBjb25zdCBtYXRjaGVyczogW01hdGNoZXI8YW55PiwgLi4uTWF0Y2hlcjxhbnk+W11dID0gKFtdIGFzIGFueSk7XG5cbiAgICBmb3IgKGNvbnN0IGFzeW5jVGh1bmsgb2YgYXN5bmNUaHVua3MpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2goYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufSIsImltcG9ydCB0eXBlIHsgRGlzcGF0Y2gsIFVua25vd25BY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IFBheWxvYWRBY3Rpb24sIEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkIH0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIH0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nO1xuaW1wb3J0IHR5cGUgeyBUaHVua0Rpc3BhdGNoIH0gZnJvbSAncmVkdXgtdGh1bmsnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25Gcm9tTWF0Y2hlciwgRmFsbGJhY2tJZlVua25vd24sIElkLCBJc0FueSwgSXNVbmtub3duLCBTYWZlUHJvbWlzZSwgVHlwZUd1YXJkIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnLi9uYW5vaWQnO1xuaW1wb3J0IHsgaXNBbnlPZiB9IGZyb20gJy4vbWF0Y2hlcnMnOyAvLyBAdHMtaWdub3JlIHdlIG5lZWQgdGhlIGltcG9ydCBvZiB0aGVzZSB0eXBlcyBkdWUgdG8gYSBidW5kbGluZyBpc3N1ZS5cblxudHlwZSBfS2VlcCA9IFBheWxvYWRBY3Rpb24gfCBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxhbnksIHVua25vd24+O1xuZXhwb3J0IHR5cGUgQmFzZVRodW5rQVBJPFMsIEUsIEQgZXh0ZW5kcyBEaXNwYXRjaCA9IERpc3BhdGNoLCBSZWplY3RlZFZhbHVlID0gdW5rbm93biwgUmVqZWN0ZWRNZXRhID0gdW5rbm93biwgRnVsZmlsbGVkTWV0YSA9IHVua25vd24+ID0ge1xuICBkaXNwYXRjaDogRDtcbiAgZ2V0U3RhdGU6ICgpID0+IFM7XG4gIGV4dHJhOiBFO1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbDtcbiAgYWJvcnQ6IChyZWFzb24/OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHJlamVjdFdpdGhWYWx1ZTogSXNVbmtub3duPFJlamVjdGVkTWV0YSwgKHZhbHVlOiBSZWplY3RlZFZhbHVlKSA9PiBSZWplY3RXaXRoVmFsdWU8UmVqZWN0ZWRWYWx1ZSwgUmVqZWN0ZWRNZXRhPiwgKHZhbHVlOiBSZWplY3RlZFZhbHVlLCBtZXRhOiBSZWplY3RlZE1ldGEpID0+IFJlamVjdFdpdGhWYWx1ZTxSZWplY3RlZFZhbHVlLCBSZWplY3RlZE1ldGE+PjtcbiAgZnVsZmlsbFdpdGhWYWx1ZTogSXNVbmtub3duPEZ1bGZpbGxlZE1ldGEsIDxGdWxmaWxsZWRWYWx1ZT4odmFsdWU6IEZ1bGZpbGxlZFZhbHVlKSA9PiBGdWxmaWxsZWRWYWx1ZSwgPEZ1bGZpbGxlZFZhbHVlPih2YWx1ZTogRnVsZmlsbGVkVmFsdWUsIG1ldGE6IEZ1bGZpbGxlZE1ldGEpID0+IEZ1bGZpbGxXaXRoTWV0YTxGdWxmaWxsZWRWYWx1ZSwgRnVsZmlsbGVkTWV0YT4+O1xufTtcbi8qKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXplZEVycm9yIHtcbiAgbmFtZT86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgc3RhY2s/OiBzdHJpbmc7XG4gIGNvZGU/OiBzdHJpbmc7XG59XG5jb25zdCBjb21tb25Qcm9wZXJ0aWVzOiBBcnJheTxrZXlvZiBTZXJpYWxpemVkRXJyb3I+ID0gWyduYW1lJywgJ21lc3NhZ2UnLCAnc3RhY2snLCAnY29kZSddO1xuXG5jbGFzcyBSZWplY3RXaXRoVmFsdWU8UGF5bG9hZCwgUmVqZWN0ZWRNZXRhPiB7XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfdHlwZSE6ICdSZWplY3RXaXRoVmFsdWUnO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBwYXlsb2FkOiBQYXlsb2FkLCBwdWJsaWMgcmVhZG9ubHkgbWV0YTogUmVqZWN0ZWRNZXRhKSB7fVxuXG59XG5cbmNsYXNzIEZ1bGZpbGxXaXRoTWV0YTxQYXlsb2FkLCBGdWxmaWxsZWRNZXRhPiB7XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfdHlwZSE6ICdGdWxmaWxsV2l0aE1ldGEnO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBwYXlsb2FkOiBQYXlsb2FkLCBwdWJsaWMgcmVhZG9ubHkgbWV0YTogRnVsZmlsbGVkTWV0YSkge31cblxufVxuLyoqXG4gKiBTZXJpYWxpemVzIGFuIGVycm9yIGludG8gYSBwbGFpbiBvYmplY3QuXG4gKiBSZXdvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2VyaWFsaXplLWVycm9yXG4gKlxuICogQHB1YmxpY1xuICovXG5cblxuZXhwb3J0IGNvbnN0IG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZTogYW55KTogU2VyaWFsaXplZEVycm9yID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICBjb25zdCBzaW1wbGVFcnJvcjogU2VyaWFsaXplZEVycm9yID0ge307XG5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBTdHJpbmcodmFsdWUpXG4gIH07XG59O1xuZXhwb3J0IHR5cGUgQXN5bmNUaHVua0NvbmZpZyA9IHtcbiAgc3RhdGU/OiB1bmtub3duO1xuICBkaXNwYXRjaD86IERpc3BhdGNoO1xuICBleHRyYT86IHVua25vd247XG4gIHJlamVjdFZhbHVlPzogdW5rbm93bjtcbiAgc2VyaWFsaXplZEVycm9yVHlwZT86IHVua25vd247XG4gIHBlbmRpbmdNZXRhPzogdW5rbm93bjtcbiAgZnVsZmlsbGVkTWV0YT86IHVua25vd247XG4gIHJlamVjdGVkTWV0YT86IHVua25vd247XG59O1xudHlwZSBHZXRTdGF0ZTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgc3RhdGU6IGluZmVyIFN0YXRlO1xufSA/IFN0YXRlIDogdW5rbm93bjtcbnR5cGUgR2V0RXh0cmE8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7XG4gIGV4dHJhOiBpbmZlciBFeHRyYTtcbn0gPyBFeHRyYSA6IHVua25vd247XG50eXBlIEdldERpc3BhdGNoPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xuICBkaXNwYXRjaDogaW5mZXIgRGlzcGF0Y2g7XG59ID8gRmFsbGJhY2tJZlVua25vd248RGlzcGF0Y2gsIFRodW5rRGlzcGF0Y2g8R2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LCBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4sIFVua25vd25BY3Rpb24+PiA6IFRodW5rRGlzcGF0Y2g8R2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LCBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4sIFVua25vd25BY3Rpb24+O1xuZXhwb3J0IHR5cGUgR2V0VGh1bmtBUEk8VGh1bmtBcGlDb25maWc+ID0gQmFzZVRodW5rQVBJPEdldFN0YXRlPFRodW5rQXBpQ29uZmlnPiwgR2V0RXh0cmE8VGh1bmtBcGlDb25maWc+LCBHZXREaXNwYXRjaDxUaHVua0FwaUNvbmZpZz4sIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPiwgR2V0UmVqZWN0ZWRNZXRhPFRodW5rQXBpQ29uZmlnPiwgR2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz4+O1xudHlwZSBHZXRSZWplY3RWYWx1ZTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgcmVqZWN0VmFsdWU6IGluZmVyIFJlamVjdFZhbHVlO1xufSA/IFJlamVjdFZhbHVlIDogdW5rbm93bjtcbnR5cGUgR2V0UGVuZGluZ01ldGE8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7XG4gIHBlbmRpbmdNZXRhOiBpbmZlciBQZW5kaW5nTWV0YTtcbn0gPyBQZW5kaW5nTWV0YSA6IHVua25vd247XG50eXBlIEdldEZ1bGZpbGxlZE1ldGE8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7XG4gIGZ1bGZpbGxlZE1ldGE6IGluZmVyIEZ1bGZpbGxlZE1ldGE7XG59ID8gRnVsZmlsbGVkTWV0YSA6IHVua25vd247XG50eXBlIEdldFJlamVjdGVkTWV0YTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgcmVqZWN0ZWRNZXRhOiBpbmZlciBSZWplY3RlZE1ldGE7XG59ID8gUmVqZWN0ZWRNZXRhIDogdW5rbm93bjtcbnR5cGUgR2V0U2VyaWFsaXplZEVycm9yVHlwZTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgc2VyaWFsaXplZEVycm9yVHlwZTogaW5mZXIgR2V0U2VyaWFsaXplZEVycm9yVHlwZTtcbn0gPyBHZXRTZXJpYWxpemVkRXJyb3JUeXBlIDogU2VyaWFsaXplZEVycm9yO1xudHlwZSBNYXliZVByb21pc2U8VD4gPSBUIHwgUHJvbWlzZTxUPiB8IChUIGV4dGVuZHMgYW55ID8gUHJvbWlzZTxUPiA6IG5ldmVyKTtcbi8qKlxuICogQSB0eXBlIGRlc2NyaWJpbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYHBheWxvYWRDcmVhdG9yYCBhcmd1bWVudCB0byBgY3JlYXRlQXN5bmNUaHVua2AuXG4gKiBNaWdodCBiZSB1c2VmdWwgZm9yIHdyYXBwaW5nIGBjcmVhdGVBc3luY1RodW5rYCBpbiBjdXN0b20gYWJzdHJhY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgdHlwZSBBc3luY1RodW5rUGF5bG9hZENyZWF0b3JSZXR1cm5WYWx1ZTxSZXR1cm5lZCwgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPiA9IE1heWJlUHJvbWlzZTxJc1Vua25vd248R2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz4sIFJldHVybmVkLCBGdWxmaWxsV2l0aE1ldGE8UmV0dXJuZWQsIEdldEZ1bGZpbGxlZE1ldGE8VGh1bmtBcGlDb25maWc+Pj4gfCBSZWplY3RXaXRoVmFsdWU8R2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+LCBHZXRSZWplY3RlZE1ldGE8VGh1bmtBcGlDb25maWc+Pj47XG4vKipcbiAqIEEgdHlwZSBkZXNjcmliaW5nIHRoZSBgcGF5bG9hZENyZWF0b3JgIGFyZ3VtZW50IHRvIGBjcmVhdGVBc3luY1RodW5rYC5cbiAqIE1pZ2h0IGJlIHVzZWZ1bCBmb3Igd3JhcHBpbmcgYGNyZWF0ZUFzeW5jVGh1bmtgIGluIGN1c3RvbSBhYnN0cmFjdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcgPSB2b2lkLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWcgPSB7fT4gPSAoYXJnOiBUaHVua0FyZywgdGh1bmtBUEk6IEdldFRodW5rQVBJPFRodW5rQXBpQ29uZmlnPikgPT4gQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yUmV0dXJuVmFsdWU8UmV0dXJuZWQsIFRodW5rQXBpQ29uZmlnPjtcbi8qKlxuICogQSBUaHVua0FjdGlvbiBjcmVhdGVkIGJ5IGBjcmVhdGVBc3luY1RodW5rYC5cbiAqIERpc3BhdGNoaW5nIGl0IHJldHVybnMgYSBQcm9taXNlIGZvciBlaXRoZXIgYVxuICogZnVsZmlsbGVkIG9yIHJlamVjdGVkIGFjdGlvbi5cbiAqIEFsc28sIHRoZSByZXR1cm5lZCB2YWx1ZSBjb250YWlucyBhbiBgYWJvcnQoKWAgbWV0aG9kXG4gKiB0aGF0IGFsbG93cyB0aGUgYXN5bmNBY3Rpb24gdG8gYmUgY2FuY2VsbGVkIGZyb20gdGhlIG91dHNpZGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWc+ID0gKGRpc3BhdGNoOiBHZXREaXNwYXRjaDxUaHVua0FwaUNvbmZpZz4sIGdldFN0YXRlOiAoKSA9PiBHZXRTdGF0ZTxUaHVua0FwaUNvbmZpZz4sIGV4dHJhOiBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4pID0+IFNhZmVQcm9taXNlPFJldHVyblR5cGU8QXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnPj4gfCBSZXR1cm5UeXBlPEFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbkNyZWF0b3I8VGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPj4+ICYge1xuICBhYm9ydDogKHJlYXNvbj86IHN0cmluZykgPT4gdm9pZDtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIGFyZzogVGh1bmtBcmc7XG4gIHVud3JhcDogKCkgPT4gUHJvbWlzZTxSZXR1cm5lZD47XG59O1xudHlwZSBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZz4gPSBJc0FueTxUaHVua0FyZywgLy8gYW55IGhhbmRsaW5nXG4oYXJnOiBUaHVua0FyZykgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiwgLy8gdW5rbm93biBoYW5kbGluZ1xudW5rbm93biBleHRlbmRzIFRodW5rQXJnID8gKGFyZzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gLy8gYXJndW1lbnQgbm90IHNwZWNpZmllZCBvciBzcGVjaWZpZWQgYXMgdm9pZCBvciB1bmRlZmluZWRcbjogW1RodW5rQXJnXSBleHRlbmRzIFt2b2lkXSB8IFt1bmRlZmluZWRdID8gKCkgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiAvLyBhcmd1bWVudCBjb250YWlucyB2b2lkXG46IFt2b2lkXSBleHRlbmRzIFtUaHVua0FyZ10gLy8gbWFrZSBvcHRpb25hbFxuPyAoYXJnPzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gLy8gYXJndW1lbnQgY29udGFpbnMgdW5kZWZpbmVkXG46IFt1bmRlZmluZWRdIGV4dGVuZHMgW1RodW5rQXJnXSA/IFdpdGhTdHJpY3ROdWxsQ2hlY2tzPCAvLyB3aXRoIHN0cmljdCBudWxsQ2hlY2tzOiBtYWtlIG9wdGlvbmFsXG4oYXJnPzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4sIC8vIHdpdGhvdXQgc3RyaWN0IG51bGwgY2hlY2tzIHRoaXMgd2lsbCBtYXRjaCBldmVyeXRoaW5nLCBzbyBkb24ndCBtYWtlIGl0IG9wdGlvbmFsXG4oYXJnOiBUaHVua0FyZykgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPj4gLy8gZGVmYXVsdCBjYXNlOiBub3JtYWwgYXJndW1lbnRcbjogKGFyZzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4+O1xuLyoqXG4gKiBPcHRpb25zIG9iamVjdCBmb3IgYGNyZWF0ZUFzeW5jVGh1bmtgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgdHlwZSBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZyA9IHZvaWQsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZyA9IHt9PiA9IHtcbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgYXN5bmNUaHVuayBzaG91bGQgYmUgZXhlY3V0ZWQuIEhhcyBhY2Nlc3MgdG8gdGhlXG4gICAqIGBhcmdgLCBgYXBpLmdldFN0YXRlKClgIGFuZCBgYXBpLmV4dHJhYCBhcmd1bWVudHMuXG4gICAqXG4gICAqIEByZXR1cm5zIGBmYWxzZWAgaWYgaXQgc2hvdWxkIGJlIHNraXBwZWRcbiAgICovXG4gIGNvbmRpdGlvbj8oYXJnOiBUaHVua0FyZywgYXBpOiBQaWNrPEdldFRodW5rQVBJPFRodW5rQXBpQ29uZmlnPiwgJ2dldFN0YXRlJyB8ICdleHRyYSc+KTogTWF5YmVQcm9taXNlPGJvb2xlYW4gfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogSWYgYGNvbmRpdGlvbmAgcmV0dXJucyBgZmFsc2VgLCB0aGUgYXN5bmNUaHVuayB3aWxsIGJlIHNraXBwZWQuXG4gICAqIFRoaXMgb3B0aW9uIGFsbG93cyB5b3UgdG8gY29udHJvbCB3aGV0aGVyIGEgYHJlamVjdGVkYCBhY3Rpb24gd2l0aCBgbWV0YS5jb25kaXRpb24gPT0gZmFsc2VgXG4gICAqIHdpbGwgYmUgZGlzcGF0Y2hlZCBvciBub3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG5cbiAgZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24/OiBib29sZWFuO1xuICBzZXJpYWxpemVFcnJvcj86ICh4OiB1bmtub3duKSA9PiBHZXRTZXJpYWxpemVkRXJyb3JUeXBlPFRodW5rQXBpQ29uZmlnPjtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyB0aGUgYHJlcXVlc3RJZGAgZm9yIHRoZSByZXF1ZXN0IHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgbmFub2lkYFxuICAgKi9cblxuICBpZEdlbmVyYXRvcj86IChhcmc6IFRodW5rQXJnKSA9PiBzdHJpbmc7XG59ICYgSXNVbmtub3duPEdldFBlbmRpbmdNZXRhPFRodW5rQXBpQ29uZmlnPiwge1xuICAvKipcbiAgICogQSBtZXRob2QgdG8gZ2VuZXJhdGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIGBtZXRhYCBvZiB0aGUgcGVuZGluZyBhY3Rpb24uXG4gICAqXG4gICAqIFVzaW5nIHRoaXMgb3B0aW9uYWwgb3ZlcmxvYWQgd2lsbCBub3QgbW9kaWZ5IHRoZSB0eXBlcyBjb3JyZWN0bHksIHRoaXMgb3ZlcmxvYWQgaXMgb25seSBpbiBwbGFjZSB0byBzdXBwb3J0IEphdmFTY3JpcHQgdXNlcnMuXG4gICAqIFBsZWFzZSB1c2UgdGhlIGBUaHVua0FwaUNvbmZpZ2AgcGFyYW1ldGVyIGBwZW5kaW5nTWV0YWAgdG8gZ2V0IGFjY2VzcyB0byBhIGNvcnJlY3RseSB0eXBlZCBvdmVybG9hZFxuICAgKi9cbiAgZ2V0UGVuZGluZ01ldGE/KGJhc2U6IHtcbiAgICBhcmc6IFRodW5rQXJnO1xuICAgIHJlcXVlc3RJZDogc3RyaW5nO1xuICB9LCBhcGk6IFBpY2s8R2V0VGh1bmtBUEk8VGh1bmtBcGlDb25maWc+LCAnZ2V0U3RhdGUnIHwgJ2V4dHJhJz4pOiBHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz47XG59LCB7XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBnZW5lcmF0ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gYG1ldGFgIG9mIHRoZSBwZW5kaW5nIGFjdGlvbi5cbiAgICovXG4gIGdldFBlbmRpbmdNZXRhKGJhc2U6IHtcbiAgICBhcmc6IFRodW5rQXJnO1xuICAgIHJlcXVlc3RJZDogc3RyaW5nO1xuICB9LCBhcGk6IFBpY2s8R2V0VGh1bmtBUEk8VGh1bmtBcGlDb25maWc+LCAnZ2V0U3RhdGUnIHwgJ2V4dHJhJz4pOiBHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz47XG59PjtcbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWcgPSB7fT4gPSBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxbc3RyaW5nLCBUaHVua0FyZywgR2V0UGVuZGluZ01ldGE8VGh1bmtBcGlDb25maWc+P10sIHVuZGVmaW5lZCwgc3RyaW5nLCBuZXZlciwge1xuICBhcmc6IFRodW5rQXJnO1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgcmVxdWVzdFN0YXR1czogJ3BlbmRpbmcnO1xufSAmIEdldFBlbmRpbmdNZXRhPFRodW5rQXBpQ29uZmlnPj47XG5leHBvcnQgdHlwZSBBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZyA9IHt9PiA9IEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFtFcnJvciB8IG51bGwsIHN0cmluZywgVGh1bmtBcmcsIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPj8sIEdldFJlamVjdGVkTWV0YTxUaHVua0FwaUNvbmZpZz4/XSwgR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+IHwgdW5kZWZpbmVkLCBzdHJpbmcsIEdldFNlcmlhbGl6ZWRFcnJvclR5cGU8VGh1bmtBcGlDb25maWc+LCB7XG4gIGFyZzogVGh1bmtBcmc7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICByZXF1ZXN0U3RhdHVzOiAncmVqZWN0ZWQnO1xuICBhYm9ydGVkOiBib29sZWFuO1xuICBjb25kaXRpb246IGJvb2xlYW47XG59ICYgKCh7XG4gIHJlamVjdGVkV2l0aFZhbHVlOiBmYWxzZTtcbn0gJiB7IFtLIGluIGtleW9mIEdldFJlamVjdGVkTWV0YTxUaHVua0FwaUNvbmZpZz5dPzogdW5kZWZpbmVkIH0pIHwgKHtcbiAgcmVqZWN0ZWRXaXRoVmFsdWU6IHRydWU7XG59ICYgR2V0UmVqZWN0ZWRNZXRhPFRodW5rQXBpQ29uZmlnPikpPjtcbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb25DcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWcgPSB7fT4gPSBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxbUmV0dXJuZWQsIHN0cmluZywgVGh1bmtBcmcsIEdldEZ1bGZpbGxlZE1ldGE8VGh1bmtBcGlDb25maWc+P10sIFJldHVybmVkLCBzdHJpbmcsIG5ldmVyLCB7XG4gIGFyZzogVGh1bmtBcmc7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICByZXF1ZXN0U3RhdHVzOiAnZnVsZmlsbGVkJztcbn0gJiBHZXRGdWxmaWxsZWRNZXRhPFRodW5rQXBpQ29uZmlnPj47XG4vKipcbiAqIEEgdHlwZSBkZXNjcmliaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgYGNyZWF0ZUFzeW5jVGh1bmtgLlxuICogTWlnaHQgYmUgdXNlZnVsIGZvciB3cmFwcGluZyBgY3JlYXRlQXN5bmNUaHVua2AgaW4gY3VzdG9tIGFic3RyYWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgQXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZz4gPSBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiAmIHtcbiAgcGVuZGluZzogQXN5bmNUaHVua1BlbmRpbmdBY3Rpb25DcmVhdG9yPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz47XG4gIHJlamVjdGVkOiBBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz47XG4gIGZ1bGZpbGxlZDogQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz47IC8vIG1hdGNoU2V0dGxlZD9cblxuICBzZXR0bGVkOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBSZXR1cm5UeXBlPEFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbkNyZWF0b3I8VGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiB8IEFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb25DcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+PjtcbiAgdHlwZVByZWZpeDogc3RyaW5nO1xufTtcbmV4cG9ydCB0eXBlIE92ZXJyaWRlVGh1bmtBcGlDb25maWdzPE9sZENvbmZpZywgTmV3Q29uZmlnPiA9IElkPE5ld0NvbmZpZyAmIE9taXQ8T2xkQ29uZmlnLCBrZXlvZiBOZXdDb25maWc+PjtcbnR5cGUgQ3JlYXRlQXN5bmNUaHVuazxDdXJyaWVkVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPiA9IHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlUHJlZml4XG4gICAqIEBwYXJhbSBwYXlsb2FkQ3JlYXRvclxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICAvLyBzZXBhcmF0ZSBzaWduYXR1cmUgd2l0aG91dCBgQXN5bmNUaHVua0NvbmZpZ2AgZm9yIGJldHRlciBpbmZlcmVuY2VcbiAgPFJldHVybmVkLCBUaHVua0FyZyA9IHZvaWQ+KHR5cGVQcmVmaXg6IHN0cmluZywgcGF5bG9hZENyZWF0b3I6IEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIEN1cnJpZWRUaHVua0FwaUNvbmZpZz4sIG9wdGlvbnM/OiBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZywgQ3VycmllZFRodW5rQXBpQ29uZmlnPik6IEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBDdXJyaWVkVGh1bmtBcGlDb25maWc+O1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHR5cGVQcmVmaXhcbiAgICogQHBhcmFtIHBheWxvYWRDcmVhdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPih0eXBlUHJlZml4OiBzdHJpbmcsIHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBPdmVycmlkZVRodW5rQXBpQ29uZmlnczxDdXJyaWVkVGh1bmtBcGlDb25maWcsIFRodW5rQXBpQ29uZmlnPj4sIG9wdGlvbnM/OiBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZywgT3ZlcnJpZGVUaHVua0FwaUNvbmZpZ3M8Q3VycmllZFRodW5rQXBpQ29uZmlnLCBUaHVua0FwaUNvbmZpZz4+KTogQXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIE92ZXJyaWRlVGh1bmtBcGlDb25maWdzPEN1cnJpZWRUaHVua0FwaUNvbmZpZywgVGh1bmtBcGlDb25maWc+PjtcbiAgd2l0aFR5cGVzPFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZz4oKTogQ3JlYXRlQXN5bmNUaHVuazxPdmVycmlkZVRodW5rQXBpQ29uZmlnczxDdXJyaWVkVGh1bmtBcGlDb25maWcsIFRodW5rQXBpQ29uZmlnPj47XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFzeW5jVGh1bmsgPSAvKiBAX19QVVJFX18gKi8oKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPih0eXBlUHJlZml4OiBzdHJpbmcsIHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4sIG9wdGlvbnM/OiBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+KTogQXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiB7XG4gICAgdHlwZSBSZWplY3RlZFZhbHVlID0gR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+O1xuICAgIHR5cGUgUGVuZGluZ01ldGEgPSBHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz47XG4gICAgdHlwZSBGdWxmaWxsZWRNZXRhID0gR2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz47XG4gICAgdHlwZSBSZWplY3RlZE1ldGEgPSBHZXRSZWplY3RlZE1ldGE8VGh1bmtBcGlDb25maWc+O1xuICAgIGNvbnN0IGZ1bGZpbGxlZDogQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArICcvZnVsZmlsbGVkJywgKHBheWxvYWQ6IFJldHVybmVkLCByZXF1ZXN0SWQ6IHN0cmluZywgYXJnOiBUaHVua0FyZywgbWV0YT86IEZ1bGZpbGxlZE1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgbWV0YTogeyAuLi4oKG1ldGEgYXMgYW55KSB8fCB7fSksXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiAoJ2Z1bGZpbGxlZCcgYXMgY29uc3QpXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmc6IEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+ID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyAnL3BlbmRpbmcnLCAocmVxdWVzdElkOiBzdHJpbmcsIGFyZzogVGh1bmtBcmcsIG1ldGE/OiBQZW5kaW5nTWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgIG1ldGE6IHsgLi4uKChtZXRhIGFzIGFueSkgfHwge30pLFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogKCdwZW5kaW5nJyBhcyBjb25zdClcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQ6IEFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbkNyZWF0b3I8VGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgJy9yZWplY3RlZCcsIChlcnJvcjogRXJyb3IgfCBudWxsLCByZXF1ZXN0SWQ6IHN0cmluZywgYXJnOiBUaHVua0FyZywgcGF5bG9hZD86IFJlamVjdGVkVmFsdWUsIG1ldGE/OiBSZWplY3RlZE1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6ICgob3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZUVycm9yIHx8IG1pbmlTZXJpYWxpemVFcnJvcikoZXJyb3IgfHwgJ1JlamVjdGVkJykgYXMgR2V0U2VyaWFsaXplZEVycm9yVHlwZTxUaHVua0FwaUNvbmZpZz4pLFxuICAgICAgbWV0YTogeyAuLi4oKG1ldGEgYXMgYW55KSB8fCB7fSksXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiAoJ3JlamVjdGVkJyBhcyBjb25zdCksXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSAnQWJvcnRFcnJvcicsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09ICdDb25kaXRpb25FcnJvcidcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZzogVGh1bmtBcmcpOiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IHtcbiAgICAgIHJldHVybiAoZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBvcHRpb25zPy5pZEdlbmVyYXRvciA/IG9wdGlvbnMuaWRHZW5lcmF0b3IoYXJnKSA6IG5hbm9pZCgpO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGxldCBhYm9ydEhhbmRsZXI6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uPzogc3RyaW5nKSB7XG4gICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb247XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxldCBmaW5hbEFjdGlvbjogUmV0dXJuVHlwZTx0eXBlb2YgZnVsZmlsbGVkIHwgdHlwZW9mIHJlamVjdGVkPjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSBmYWxzZSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25FcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Fib3J0ZWQgZHVlIHRvIGNvbmRpdGlvbiBjYWxsYmFjayByZXR1cm5pbmcgZmFsc2UuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ0Fib3J0RXJyb3InLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWJvcnRSZWFzb24gfHwgJ0Fib3J0ZWQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCBvcHRpb25zPy5nZXRQZW5kaW5nTWV0YT8uKHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KSkgYXMgYW55KSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICgoKHZhbHVlOiBSZWplY3RlZFZhbHVlLCBtZXRhPzogUmVqZWN0ZWRNZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWplY3RXaXRoVmFsdWUodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9KSBhcyBhbnkpLFxuICAgICAgICAgICAgICBmdWxmaWxsV2l0aFZhbHVlOiAoKCh2YWx1ZTogdW5rbm93biwgbWV0YT86IEZ1bGZpbGxlZE1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH0pIGFzIGFueSlcbiAgICAgICAgICAgIH0pKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQucGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQoKHJlc3VsdCBhcyBhbnkpLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKChlcnIgYXMgYW55KSwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gV2UgZGlzcGF0Y2ggdGhlIHJlc3VsdCBhY3Rpb24gX2FmdGVyXyB0aGUgY2F0Y2gsIHRvIGF2b2lkIGhhdmluZyBhbnkgZXJyb3JzXG4gICAgICAgICAgLy8gaGVyZSBnZXQgc3dhbGxvd2VkIGJ5IHRoZSB0cnkvY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gcGVyIGh0dHBzOi8vdHdpdHRlci5jb20vZGFuX2FicmFtb3Yvc3RhdHVzLzc3MDkxNDIyMTYzODk0MjcyMFxuICAgICAgICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZWR1eC10b29sa2l0L2Jsb2IvZTg1ZWIxN2IzOWEyMTE4ZDg1OWY3Yjc3NDZlMGYzZmVlNTIzZTA4OS9kb2NzL3R1dG9yaWFscy9hZHZhbmNlZC10dXRvcmlhbC5tZCNhc3luYy1lcnJvci1oYW5kbGluZy1sb2dpYy1pbi10aHVua3NcblxuXG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgKGZpbmFsQWN0aW9uIGFzIGFueSkubWV0YS5jb25kaXRpb247XG5cbiAgICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goKGZpbmFsQWN0aW9uIGFzIGFueSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaW5hbEFjdGlvbjtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKChwcm9taXNlIGFzIFNhZmVQcm9taXNlPGFueT4pLCB7XG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcblxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW48YW55Pih1bndyYXBSZXN1bHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKGFjdGlvbkNyZWF0b3IgYXMgQXN5bmNUaHVua0FjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4pLCB7XG4gICAgICBwZW5kaW5nLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBmdWxmaWxsZWQsXG4gICAgICBzZXR0bGVkOiBpc0FueU9mKHJlamVjdGVkLCBmdWxmaWxsZWQpLFxuICAgICAgdHlwZVByZWZpeFxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlQXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rO1xuXG4gIHJldHVybiAoY3JlYXRlQXN5bmNUaHVuayBhcyBDcmVhdGVBc3luY1RodW5rPEFzeW5jVGh1bmtDb25maWc+KTtcbn0pKCk7XG5pbnRlcmZhY2UgVW53cmFwcGFibGVBY3Rpb24ge1xuICBwYXlsb2FkOiBhbnk7XG4gIG1ldGE/OiBhbnk7XG4gIGVycm9yPzogYW55O1xufVxudHlwZSBVbndyYXBwZWRBY3Rpb25QYXlsb2FkPFQgZXh0ZW5kcyBVbndyYXBwYWJsZUFjdGlvbj4gPSBFeGNsdWRlPFQsIHtcbiAgZXJyb3I6IGFueTtcbn0+WydwYXlsb2FkJ107XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwUmVzdWx0PFIgZXh0ZW5kcyBVbndyYXBwYWJsZUFjdGlvbj4oYWN0aW9uOiBSKTogVW53cmFwcGVkQWN0aW9uUGF5bG9hZDxSPiB7XG4gIGlmIChhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZSkge1xuICAgIHRocm93IGFjdGlvbi5wYXlsb2FkO1xuICB9XG5cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuXG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbn1cbnR5cGUgV2l0aFN0cmljdE51bGxDaGVja3M8VHJ1ZSwgRmFsc2U+ID0gdW5kZWZpbmVkIGV4dGVuZHMgYm9vbGVhbiA/IEZhbHNlIDogVHJ1ZTtcblxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgUHJvbWlzZUxpa2U8YW55PiB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U4IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U3IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24sIFVua25vd25BY3Rpb24sIFJlZHVjZXIgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IFNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQsIFBheWxvYWRBY3Rpb24sIFBheWxvYWRBY3Rpb25DcmVhdG9yLCBQcmVwYXJlQWN0aW9uLCBfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQgfSBmcm9tICcuL2NyZWF0ZUFjdGlvbic7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24gfSBmcm9tICcuL2NyZWF0ZUFjdGlvbic7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb24sIENhc2VSZWR1Y2VyLCBSZWR1Y2VyV2l0aEluaXRpYWxTdGF0ZSB9IGZyb20gJy4vY3JlYXRlUmVkdWNlcic7XG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VyIH0gZnJvbSAnLi9jcmVhdGVSZWR1Y2VyJztcbmltcG9ydCB0eXBlIHsgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXIsIFR5cGVkQWN0aW9uQ3JlYXRvciB9IGZyb20gJy4vbWFwQnVpbGRlcnMnO1xuaW1wb3J0IHsgZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sgfSBmcm9tICcuL21hcEJ1aWxkZXJzJztcbmltcG9ydCB0eXBlIHsgSWQsIFRhaWwsIFR5cGVHdWFyZCB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgSW5qZWN0Q29uZmlnIH0gZnJvbSAnLi9jb21iaW5lU2xpY2VzJztcbmltcG9ydCB0eXBlIHsgQXN5bmNUaHVuaywgQXN5bmNUaHVua0NvbmZpZywgQXN5bmNUaHVua09wdGlvbnMsIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvciwgT3ZlcnJpZGVUaHVua0FwaUNvbmZpZ3MgfSBmcm9tICcuL2NyZWF0ZUFzeW5jVGh1bmsnO1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNUaHVuayBhcyBfY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJy4vY3JlYXRlQXN5bmNUaHVuayc7XG5pbXBvcnQgeyBlbXBsYWNlIH0gZnJvbSAnLi91dGlscyc7XG5jb25zdCBhc3luY1RodW5rU3ltYm9sID0gLyogQF9fUFVSRV9fICovU3ltYm9sLmZvcigncnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmsnKTsgLy8gdHlwZSBpcyBhbm5vdGF0ZWQgYmVjYXVzZSBpdCdzIHRvbyBsb25nIHRvIGluZmVyXG5cbmV4cG9ydCBjb25zdCBhc3luY1RodW5rQ3JlYXRvcjoge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IHR5cGVvZiBfY3JlYXRlQXN5bmNUaHVuaztcbn0gPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogX2NyZWF0ZUFzeW5jVGh1bmtcbn07XG5pbnRlcmZhY2UgSW5qZWN0SW50b0NvbmZpZzxOZXdSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBJbmplY3RDb25maWcge1xuICByZWR1Y2VyUGF0aD86IE5ld1JlZHVjZXJQYXRoO1xufVxuLyoqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIGBjcmVhdGVTbGljZWBcbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBTbGljZTxTdGF0ZSA9IGFueSwgQ2FzZVJlZHVjZXJzIGV4dGVuZHMgU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+ID0gU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+LCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IE5hbWUsIFNlbGVjdG9ycyBleHRlbmRzIFNsaWNlU2VsZWN0b3JzPFN0YXRlPiA9IFNsaWNlU2VsZWN0b3JzPFN0YXRlPj4ge1xuICAvKipcbiAgICogVGhlIHNsaWNlIG5hbWUuXG4gICAqL1xuICBuYW1lOiBOYW1lO1xuICAvKipcbiAgICogIFRoZSBzbGljZSByZWR1Y2VyIHBhdGguXG4gICAqL1xuXG4gIHJlZHVjZXJQYXRoOiBSZWR1Y2VyUGF0aDtcbiAgLyoqXG4gICAqIFRoZSBzbGljZSdzIHJlZHVjZXIuXG4gICAqL1xuXG4gIHJlZHVjZXI6IFJlZHVjZXI8U3RhdGU+O1xuICAvKipcbiAgICogQWN0aW9uIGNyZWF0b3JzIGZvciB0aGUgdHlwZXMgb2YgYWN0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IHRoZSBzbGljZVxuICAgKiByZWR1Y2VyLlxuICAgKi9cblxuICBhY3Rpb25zOiBDYXNlUmVkdWNlckFjdGlvbnM8Q2FzZVJlZHVjZXJzLCBOYW1lPjtcbiAgLyoqXG4gICAqIFRoZSBpbmRpdmlkdWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbnMgdGhhdCB3ZXJlIHBhc3NlZCBpbiB0aGUgYHJlZHVjZXJzYCBwYXJhbWV0ZXIuXG4gICAqIFRoaXMgZW5hYmxlcyByZXVzZSBhbmQgdGVzdGluZyBpZiB0aGV5IHdlcmUgZGVmaW5lZCBpbmxpbmUgd2hlbiBjYWxsaW5nIGBjcmVhdGVTbGljZWAuXG4gICAqL1xuXG4gIGNhc2VSZWR1Y2VyczogU2xpY2VEZWZpbmVkQ2FzZVJlZHVjZXJzPENhc2VSZWR1Y2Vycz47XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGluaXRpYWwgc3RhdGUgdmFsdWUgZ2l2ZW4gdG8gdGhlIHNsaWNlLlxuICAgKiBJZiBhIGxhenkgc3RhdGUgaW5pdGlhbGl6ZXIgd2FzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIGNhbGxlZCBhbmQgYSBmcmVzaCB2YWx1ZSByZXR1cm5lZC5cbiAgICovXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAoKSA9PiBTdGF0ZTtcbiAgLyoqXG4gICAqIEdldCBsb2NhbGlzZWQgc2xpY2Ugc2VsZWN0b3JzIChleHBlY3RzIHRvIGJlIGNhbGxlZCB3aXRoICpqdXN0KiB0aGUgc2xpY2UncyBzdGF0ZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuICAgKi9cblxuICBnZXRTZWxlY3RvcnMoKTogSWQ8U2xpY2VEZWZpbmVkU2VsZWN0b3JzPFN0YXRlLCBTZWxlY3RvcnMsIFN0YXRlPj47XG4gIC8qKlxuICAgKiBHZXQgZ2xvYmFsaXNlZCBzbGljZSBzZWxlY3RvcnMgKGBzZWxlY3RTdGF0ZWAgY2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBmaXJzdCBwYXJhbWV0ZXIgYW5kIHJldHVybiBzbGljZSBzdGF0ZSlcbiAgICovXG5cbiAgZ2V0U2VsZWN0b3JzPFJvb3RTdGF0ZT4oc2VsZWN0U3RhdGU6IChyb290U3RhdGU6IFJvb3RTdGF0ZSkgPT4gU3RhdGUpOiBJZDxTbGljZURlZmluZWRTZWxlY3RvcnM8U3RhdGUsIFNlbGVjdG9ycywgUm9vdFN0YXRlPj47XG4gIC8qKlxuICAgKiBTZWxlY3RvcnMgdGhhdCBhc3N1bWUgdGhlIHNsaWNlJ3Mgc3RhdGUgaXMgYHJvb3RTdGF0ZVtzbGljZS5yZWR1Y2VyUGF0aF1gICh3aGljaCBpcyB1c3VhbGx5IHRoZSBjYXNlKVxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzbGljZS5nZXRTZWxlY3RvcnMoKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlW3NsaWNlLnJlZHVjZXJQYXRoXSlgLlxuICAgKi9cblxuICBnZXQgc2VsZWN0b3JzKCk6IElkPFNsaWNlRGVmaW5lZFNlbGVjdG9yczxTdGF0ZSwgU2VsZWN0b3JzLCB7IFtLIGluIFJlZHVjZXJQYXRoXTogU3RhdGUgfT4+O1xuICAvKipcbiAgICogSW5qZWN0IHNsaWNlIGludG8gcHJvdmlkZWQgcmVkdWNlciAocmV0dXJuIHZhbHVlIGZyb20gYGNvbWJpbmVTbGljZXNgKSwgYW5kIHJldHVybiBpbmplY3RlZCBzbGljZS5cbiAgICovXG5cbiAgaW5qZWN0SW50bzxOZXdSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IFJlZHVjZXJQYXRoPih0aGlzOiB0aGlzLCBpbmplY3RhYmxlOiB7XG4gICAgaW5qZWN0OiAoc2xpY2U6IHtcbiAgICAgIHJlZHVjZXJQYXRoOiBzdHJpbmc7XG4gICAgICByZWR1Y2VyOiBSZWR1Y2VyO1xuICAgIH0sIGNvbmZpZz86IEluamVjdENvbmZpZykgPT4gdm9pZDtcbiAgfSwgY29uZmlnPzogSW5qZWN0SW50b0NvbmZpZzxOZXdSZWR1Y2VyUGF0aD4pOiBJbmplY3RlZFNsaWNlPFN0YXRlLCBDYXNlUmVkdWNlcnMsIE5hbWUsIE5ld1JlZHVjZXJQYXRoLCBTZWxlY3RvcnM+O1xuICAvKipcbiAgICogU2VsZWN0IHRoZSBzbGljZSBzdGF0ZSwgdXNpbmcgdGhlIHNsaWNlJ3MgY3VycmVudCByZWR1Y2VyUGF0aC5cbiAgICpcbiAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBzbGljZSBpcyBub3QgZm91bmQuXG4gICAqL1xuXG4gIHNlbGVjdFNsaWNlKHN0YXRlOiB7IFtLIGluIFJlZHVjZXJQYXRoXTogU3RhdGUgfSk6IFN0YXRlO1xufVxuLyoqXG4gKiBBIHNsaWNlIGFmdGVyIGJlaW5nIGNhbGxlZCB3aXRoIGBpbmplY3RJbnRvKHJlZHVjZXIpYC5cbiAqXG4gKiBTZWxlY3RvcnMgY2FuIG5vdyBiZSBjYWxsZWQgd2l0aCBhbiBgdW5kZWZpbmVkYCB2YWx1ZSwgaW4gd2hpY2ggY2FzZSB0aGV5IHVzZSB0aGUgc2xpY2UncyBpbml0aWFsIHN0YXRlLlxuICovXG5cbmludGVyZmFjZSBJbmplY3RlZFNsaWNlPFN0YXRlID0gYW55LCBDYXNlUmVkdWNlcnMgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4gPSBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gTmFtZSwgU2VsZWN0b3JzIGV4dGVuZHMgU2xpY2VTZWxlY3RvcnM8U3RhdGU+ID0gU2xpY2VTZWxlY3RvcnM8U3RhdGU+PiBleHRlbmRzIE9taXQ8U2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycywgTmFtZSwgUmVkdWNlclBhdGgsIFNlbGVjdG9ycz4sICdnZXRTZWxlY3RvcnMnIHwgJ3NlbGVjdG9ycyc+IHtcbiAgLyoqXG4gICAqIEdldCBsb2NhbGlzZWQgc2xpY2Ugc2VsZWN0b3JzIChleHBlY3RzIHRvIGJlIGNhbGxlZCB3aXRoICpqdXN0KiB0aGUgc2xpY2UncyBzdGF0ZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuICAgKi9cbiAgZ2V0U2VsZWN0b3JzKCk6IElkPFNsaWNlRGVmaW5lZFNlbGVjdG9yczxTdGF0ZSwgU2VsZWN0b3JzLCBTdGF0ZSB8IHVuZGVmaW5lZD4+O1xuICAvKipcbiAgICogR2V0IGdsb2JhbGlzZWQgc2xpY2Ugc2VsZWN0b3JzIChgc2VsZWN0U3RhdGVgIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIHJlY2VpdmUgZmlyc3QgcGFyYW1ldGVyIGFuZCByZXR1cm4gc2xpY2Ugc3RhdGUpXG4gICAqL1xuXG4gIGdldFNlbGVjdG9yczxSb290U3RhdGU+KHNlbGVjdFN0YXRlOiAocm9vdFN0YXRlOiBSb290U3RhdGUpID0+IFN0YXRlIHwgdW5kZWZpbmVkKTogSWQ8U2xpY2VEZWZpbmVkU2VsZWN0b3JzPFN0YXRlLCBTZWxlY3RvcnMsIFJvb3RTdGF0ZT4+O1xuICAvKipcbiAgICogU2VsZWN0b3JzIHRoYXQgYXNzdW1lIHRoZSBzbGljZSdzIHN0YXRlIGlzIGByb290U3RhdGVbc2xpY2UubmFtZV1gICh3aGljaCBpcyB1c3VhbGx5IHRoZSBjYXNlKVxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzbGljZS5nZXRTZWxlY3RvcnMoKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlW3NsaWNlLm5hbWVdKWAuXG4gICAqL1xuXG4gIGdldCBzZWxlY3RvcnMoKTogSWQ8U2xpY2VEZWZpbmVkU2VsZWN0b3JzPFN0YXRlLCBTZWxlY3RvcnMsIHsgW0sgaW4gUmVkdWNlclBhdGhdPzogU3RhdGUgfCB1bmRlZmluZWQgfT4+O1xuICAvKipcbiAgICogU2VsZWN0IHRoZSBzbGljZSBzdGF0ZSwgdXNpbmcgdGhlIHNsaWNlJ3MgY3VycmVudCByZWR1Y2VyUGF0aC5cbiAgICpcbiAgICogUmV0dXJucyBpbml0aWFsIHN0YXRlIGlmIHNsaWNlIGlzIG5vdCBmb3VuZC5cbiAgICovXG5cbiAgc2VsZWN0U2xpY2Uoc3RhdGU6IHsgW0sgaW4gUmVkdWNlclBhdGhdPzogU3RhdGUgfCB1bmRlZmluZWQgfSk6IFN0YXRlO1xufVxuLyoqXG4gKiBPcHRpb25zIGZvciBgY3JlYXRlU2xpY2UoKWAuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU2xpY2VPcHRpb25zPFN0YXRlID0gYW55LCBDUiBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiwgTmFtZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBOYW1lLCBTZWxlY3RvcnMgZXh0ZW5kcyBTbGljZVNlbGVjdG9yczxTdGF0ZT4gPSBTbGljZVNlbGVjdG9yczxTdGF0ZT4+IHtcbiAgLyoqXG4gICAqIFRoZSBzbGljZSdzIG5hbWUuIFVzZWQgdG8gbmFtZXNwYWNlIHRoZSBnZW5lcmF0ZWQgYWN0aW9uIHR5cGVzLlxuICAgKi9cbiAgbmFtZTogTmFtZTtcbiAgLyoqXG4gICAqIFRoZSBzbGljZSdzIHJlZHVjZXIgcGF0aC4gVXNlZCB3aGVuIGluamVjdGluZyBpbnRvIGEgY29tYmluZWQgc2xpY2UgcmVkdWNlci5cbiAgICovXG5cbiAgcmVkdWNlclBhdGg/OiBSZWR1Y2VyUGF0aDtcbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgcmVkdWNlciBpcyBjYWxsZWQgdGhlIGZpcnN0IHRpbWUuIFRoaXMgbWF5IGFsc28gYmUgYSBcImxhenkgaW5pdGlhbGl6ZXJcIiBmdW5jdGlvbiwgd2hpY2ggc2hvdWxkIHJldHVybiBhbiBpbml0aWFsIHN0YXRlIHZhbHVlIHdoZW4gY2FsbGVkLiBUaGlzIHdpbGwgYmUgdXNlZCB3aGVuZXZlciB0aGUgcmVkdWNlciBpcyBjYWxsZWQgd2l0aCBgdW5kZWZpbmVkYCBhcyBpdHMgc3RhdGUgdmFsdWUsIGFuZCBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBjYXNlcyBsaWtlIHJlYWRpbmcgaW5pdGlhbCBzdGF0ZSBmcm9tIGBsb2NhbFN0b3JhZ2VgLlxuICAgKi9cblxuICBpbml0aWFsU3RhdGU6IFN0YXRlIHwgKCgpID0+IFN0YXRlKTtcbiAgLyoqXG4gICAqIEEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBhY3Rpb24tdHlwZS1zcGVjaWZpYyAqY2FzZSByZWR1Y2VyKlxuICAgKiBmdW5jdGlvbnMuIEZvciBldmVyeSBhY3Rpb24gdHlwZSwgYSBtYXRjaGluZyBhY3Rpb24gY3JlYXRvciB3aWxsIGJlXG4gICAqIGdlbmVyYXRlZCB1c2luZyBgY3JlYXRlQWN0aW9uKClgLlxuICAgKi9cblxuICByZWR1Y2VyczogVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZSwgQ1I+IHwgKChjcmVhdG9yczogUmVkdWNlckNyZWF0b3JzPFN0YXRlPikgPT4gQ1IpO1xuICAvKipcbiAgICogQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIGEgKmJ1aWxkZXIqIG9iamVjdCB0byBkZWZpbmVcbiAgICogY2FzZSByZWR1Y2VycyB2aWEgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkQ2FzZShhY3Rpb25DcmVhdG9yT3JUeXBlLCByZWR1Y2VyKWAuXG4gICAqIFxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgYGBgdHNcbiAgaW1wb3J0IHsgY3JlYXRlQWN0aW9uLCBjcmVhdGVTbGljZSwgQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCdcbiAgY29uc3QgaW5jcmVtZW50QnkgPSBjcmVhdGVBY3Rpb248bnVtYmVyPignaW5jcmVtZW50QnknKVxuICBjb25zdCBkZWNyZW1lbnQgPSBjcmVhdGVBY3Rpb24oJ2RlY3JlbWVudCcpXG4gIGludGVyZmFjZSBSZWplY3RlZEFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGVycm9yOiBFcnJvclxuICB9XG4gIGZ1bmN0aW9uIGlzUmVqZWN0ZWRBY3Rpb24oYWN0aW9uOiBBY3Rpb24pOiBhY3Rpb24gaXMgUmVqZWN0ZWRBY3Rpb24ge1xuICByZXR1cm4gYWN0aW9uLnR5cGUuZW5kc1dpdGgoJ3JlamVjdGVkJylcbiAgfVxuICBjcmVhdGVTbGljZSh7XG4gIG5hbWU6ICdjb3VudGVyJyxcbiAgaW5pdGlhbFN0YXRlOiAwLFxuICByZWR1Y2Vyczoge30sXG4gIGV4dHJhUmVkdWNlcnM6IGJ1aWxkZXIgPT4ge1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDYXNlKGluY3JlbWVudEJ5LCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBhY3Rpb24gaXMgaW5mZXJyZWQgY29ycmVjdGx5IGhlcmUgaWYgdXNpbmcgVFNcbiAgICAgIH0pXG4gICAgICAvLyBZb3UgY2FuIGNoYWluIGNhbGxzLCBvciBoYXZlIHNlcGFyYXRlIGBidWlsZGVyLmFkZENhc2UoKWAgbGluZXMgZWFjaCB0aW1lXG4gICAgICAuYWRkQ2FzZShkZWNyZW1lbnQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7fSlcbiAgICAgIC8vIFlvdSBjYW4gbWF0Y2ggYSByYW5nZSBvZiBhY3Rpb24gdHlwZXNcbiAgICAgIC5hZGRNYXRjaGVyKFxuICAgICAgICBpc1JlamVjdGVkQWN0aW9uLFxuICAgICAgICAvLyBgYWN0aW9uYCB3aWxsIGJlIGluZmVycmVkIGFzIGEgUmVqZWN0ZWRBY3Rpb24gZHVlIHRvIGlzUmVqZWN0ZWRBY3Rpb24gYmVpbmcgZGVmaW5lZCBhcyBhIHR5cGUgZ3VhcmRcbiAgICAgICAgKHN0YXRlLCBhY3Rpb24pID0+IHt9XG4gICAgICApXG4gICAgICAvLyBhbmQgcHJvdmlkZSBhIGRlZmF1bHQgY2FzZSBpZiBubyBvdGhlciBoYW5kbGVycyBtYXRjaGVkXG4gICAgICAuYWRkRGVmYXVsdENhc2UoKHN0YXRlLCBhY3Rpb24pID0+IHt9KVxuICAgIH1cbiAgfSlcbiAgYGBgXG4gICAqL1xuXG4gIGV4dHJhUmVkdWNlcnM/OiAoYnVpbGRlcjogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+KSA9PiB2b2lkO1xuICAvKipcbiAgICogQSBtYXAgb2Ygc2VsZWN0b3JzIHRoYXQgcmVjZWl2ZSB0aGUgc2xpY2UncyBzdGF0ZSBhbmQgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLCBhbmQgcmV0dXJuIGEgcmVzdWx0LlxuICAgKi9cblxuICBzZWxlY3RvcnM/OiBTZWxlY3RvcnM7XG59XG5leHBvcnQgZW51bSBSZWR1Y2VyVHlwZSB7XG4gIHJlZHVjZXIgPSAncmVkdWNlcicsXG4gIHJlZHVjZXJXaXRoUHJlcGFyZSA9ICdyZWR1Y2VyV2l0aFByZXBhcmUnLFxuICBhc3luY1RodW5rID0gJ2FzeW5jVGh1bmsnLFxufVxuaW50ZXJmYWNlIFJlZHVjZXJEZWZpbml0aW9uPFQgZXh0ZW5kcyBSZWR1Y2VyVHlwZSA9IFJlZHVjZXJUeXBlPiB7XG4gIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIENhc2VSZWR1Y2VyRGVmaW5pdGlvbjxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbj4gZXh0ZW5kcyBDYXNlUmVkdWNlcjxTLCBBPiwgUmVkdWNlckRlZmluaXRpb248UmVkdWNlclR5cGUucmVkdWNlcj4ge31cbi8qKlxuICogQSBDYXNlUmVkdWNlciB3aXRoIGEgYHByZXBhcmVgIG1ldGhvZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgQWN0aW9uIGV4dGVuZHMgUGF5bG9hZEFjdGlvbj4gPSB7XG4gIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBBY3Rpb24+O1xuICBwcmVwYXJlOiBQcmVwYXJlQWN0aW9uPEFjdGlvblsncGF5bG9hZCddPjtcbn07XG5leHBvcnQgaW50ZXJmYWNlIENhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uPFN0YXRlLCBBY3Rpb24gZXh0ZW5kcyBQYXlsb2FkQWN0aW9uPiBleHRlbmRzIENhc2VSZWR1Y2VyV2l0aFByZXBhcmU8U3RhdGUsIEFjdGlvbj4sIFJlZHVjZXJEZWZpbml0aW9uPFJlZHVjZXJUeXBlLnJlZHVjZXJXaXRoUHJlcGFyZT4ge31cbmV4cG9ydCBpbnRlcmZhY2UgQXN5bmNUaHVua1NsaWNlUmVkdWNlckNvbmZpZzxTdGF0ZSwgVGh1bmtBcmcgZXh0ZW5kcyBhbnksIFJldHVybmVkID0gdW5rbm93biwgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnID0ge30+IHtcbiAgcGVuZGluZz86IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5bJ3BlbmRpbmcnXT4+O1xuICByZWplY3RlZD86IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5bJ3JlamVjdGVkJ10+PjtcbiAgZnVsZmlsbGVkPzogQ2FzZVJlZHVjZXI8U3RhdGUsIFJldHVyblR5cGU8QXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPlsnZnVsZmlsbGVkJ10+PjtcbiAgc2V0dGxlZD86IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5bJ3JlamVjdGVkJyB8ICdmdWxmaWxsZWQnXT4+O1xuICBvcHRpb25zPzogQXN5bmNUaHVua09wdGlvbnM8VGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFRodW5rQXJnIGV4dGVuZHMgYW55LCBSZXR1cm5lZCA9IHVua25vd24sIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZyA9IHt9PiBleHRlbmRzIEFzeW5jVGh1bmtTbGljZVJlZHVjZXJDb25maWc8U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgVGh1bmtBcGlDb25maWc+LCBSZWR1Y2VyRGVmaW5pdGlvbjxSZWR1Y2VyVHlwZS5hc3luY1RodW5rPiB7XG4gIHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz47XG59XG4vKipcbiAqIFByb3ZpZGluZyB0aGVzZSBhcyBwYXJ0IG9mIHRoZSBjb25maWcgd291bGQgY2F1c2UgY2lyY3VsYXIgdHlwZXMsIHNvIHdlIGRpc2FsbG93IHBhc3NpbmcgdGhlbVxuICovXG5cbnR5cGUgUHJldmVudENpcmN1bGFyPFRodW5rQXBpQ29uZmlnPiA9IHsgW0sgaW4ga2V5b2YgVGh1bmtBcGlDb25maWddOiBLIGV4dGVuZHMgJ3N0YXRlJyB8ICdkaXNwYXRjaCcgPyBuZXZlciA6IFRodW5rQXBpQ29uZmlnW0tdIH07XG5pbnRlcmZhY2UgQXN5bmNUaHVua0NyZWF0b3I8U3RhdGUsIEN1cnJpZWRUaHVua0FwaUNvbmZpZyBleHRlbmRzIFByZXZlbnRDaXJjdWxhcjxBc3luY1RodW5rQ29uZmlnPiA9IFByZXZlbnRDaXJjdWxhcjxBc3luY1RodW5rQ29uZmlnPj4ge1xuICA8UmV0dXJuZWQsIFRodW5rQXJnID0gdm9pZD4ocGF5bG9hZENyZWF0b3I6IEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIEN1cnJpZWRUaHVua0FwaUNvbmZpZz4sIGNvbmZpZz86IEFzeW5jVGh1bmtTbGljZVJlZHVjZXJDb25maWc8U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgQ3VycmllZFRodW5rQXBpQ29uZmlnPik6IEFzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uPFN0YXRlLCBUaHVua0FyZywgUmV0dXJuZWQsIEN1cnJpZWRUaHVua0FwaUNvbmZpZz47XG4gIDxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgUHJldmVudENpcmN1bGFyPEFzeW5jVGh1bmtDb25maWc+ID0ge30+KHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4sIGNvbmZpZz86IEFzeW5jVGh1bmtTbGljZVJlZHVjZXJDb25maWc8U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgVGh1bmtBcGlDb25maWc+KTogQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgVGh1bmtBcGlDb25maWc+O1xuICB3aXRoVHlwZXM8VGh1bmtBcGlDb25maWcgZXh0ZW5kcyBQcmV2ZW50Q2lyY3VsYXI8QXN5bmNUaHVua0NvbmZpZz4+KCk6IEFzeW5jVGh1bmtDcmVhdG9yPFN0YXRlLCBPdmVycmlkZVRodW5rQXBpQ29uZmlnczxDdXJyaWVkVGh1bmtBcGlDb25maWcsIFRodW5rQXBpQ29uZmlnPj47XG59XG5leHBvcnQgaW50ZXJmYWNlIFJlZHVjZXJDcmVhdG9yczxTdGF0ZT4ge1xuICByZWR1Y2VyKGNhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUGF5bG9hZEFjdGlvbj4pOiBDYXNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFBheWxvYWRBY3Rpb24+O1xuICByZWR1Y2VyPFBheWxvYWQ+KGNhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxQYXlsb2FkPj4pOiBDYXNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFBheWxvYWRBY3Rpb248UGF5bG9hZD4+O1xuICBhc3luY1RodW5rOiBBc3luY1RodW5rQ3JlYXRvcjxTdGF0ZT47XG4gIHByZXBhcmVkUmVkdWNlcjxQcmVwYXJlIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+PihwcmVwYXJlOiBQcmVwYXJlLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8UHJlcGFyZT4+Pik6IHtcbiAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBSZWR1Y2VyVHlwZS5yZWR1Y2VyV2l0aFByZXBhcmU7XG4gICAgcHJlcGFyZTogUHJlcGFyZTtcbiAgICByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8UHJlcGFyZT4+PjtcbiAgfTtcbn1cbi8qKlxuICogVGhlIHR5cGUgZGVzY3JpYmluZyBhIHNsaWNlJ3MgYHJlZHVjZXJzYCBvcHRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCB0eXBlIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IFJlY29yZDxzdHJpbmcsIENhc2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxhbnk+PiB8IENhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uPFN0YXRlLCBQYXlsb2FkQWN0aW9uPGFueSwgc3RyaW5nLCBhbnksIGFueT4+IHwgQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIGFueSwgYW55LCBhbnk+PiB8IFJlY29yZDxzdHJpbmcsIENhc2VSZWR1Y2VyPFN0YXRlLCBQYXlsb2FkQWN0aW9uPGFueT4+IHwgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxhbnksIHN0cmluZywgYW55LCBhbnk+Pj47XG4vKipcbiAqIFRoZSB0eXBlIGRlc2NyaWJpbmcgYSBzbGljZSdzIGBzZWxlY3RvcnNgIG9wdGlvbi5cbiAqL1xuXG5leHBvcnQgdHlwZSBTbGljZVNlbGVjdG9yczxTdGF0ZT4gPSB7XG4gIFtLOiBzdHJpbmddOiAoc2xpY2VTdGF0ZTogU3RhdGUsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG59O1xudHlwZSBTbGljZUFjdGlvblR5cGU8U2xpY2VOYW1lIGV4dGVuZHMgc3RyaW5nLCBBY3Rpb25OYW1lIGV4dGVuZHMga2V5b2YgYW55PiA9IEFjdGlvbk5hbWUgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgPyBgJHtTbGljZU5hbWV9LyR7QWN0aW9uTmFtZX1gIDogc3RyaW5nO1xuLyoqXG4gKiBEZXJpdmVzIHRoZSBzbGljZSdzIGBhY3Rpb25zYCBwcm9wZXJ0eSBmcm9tIHRoZSBgcmVkdWNlcnNgIG9wdGlvbnNcbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXJBY3Rpb25zPENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPGFueT4sIFNsaWNlTmFtZSBleHRlbmRzIHN0cmluZz4gPSB7IFtUeXBlIGluIGtleW9mIENhc2VSZWR1Y2Vyc106IENhc2VSZWR1Y2Vyc1tUeXBlXSBleHRlbmRzIGluZmVyIERlZmluaXRpb24gPyBEZWZpbml0aW9uIGV4dGVuZHMge1xuICBwcmVwYXJlOiBhbnk7XG59ID8gQWN0aW9uQ3JlYXRvckZvckNhc2VSZWR1Y2VyV2l0aFByZXBhcmU8RGVmaW5pdGlvbiwgU2xpY2VBY3Rpb25UeXBlPFNsaWNlTmFtZSwgVHlwZT4+IDogRGVmaW5pdGlvbiBleHRlbmRzIEFzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uPGFueSwgaW5mZXIgVGh1bmtBcmcsIGluZmVyIFJldHVybmVkLCBpbmZlciBUaHVua0FwaUNvbmZpZz4gPyBBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IDogRGVmaW5pdGlvbiBleHRlbmRzIHtcbiAgcmVkdWNlcjogYW55O1xufSA/IEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxEZWZpbml0aW9uWydyZWR1Y2VyJ10sIFNsaWNlQWN0aW9uVHlwZTxTbGljZU5hbWUsIFR5cGU+PiA6IEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxEZWZpbml0aW9uLCBTbGljZUFjdGlvblR5cGU8U2xpY2VOYW1lLCBUeXBlPj4gOiBuZXZlciB9O1xuLyoqXG4gKiBHZXQgYSBgUGF5bG9hZEFjdGlvbkNyZWF0b3JgIHR5cGUgZm9yIGEgcGFzc2VkIGBDYXNlUmVkdWNlcldpdGhQcmVwYXJlYFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnR5cGUgQWN0aW9uQ3JlYXRvckZvckNhc2VSZWR1Y2VyV2l0aFByZXBhcmU8Q1IgZXh0ZW5kcyB7XG4gIHByZXBhcmU6IGFueTtcbn0sIFR5cGUgZXh0ZW5kcyBzdHJpbmc+ID0gX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPENSWydwcmVwYXJlJ10sIFR5cGU+O1xuLyoqXG4gKiBHZXQgYSBgUGF5bG9hZEFjdGlvbkNyZWF0b3JgIHR5cGUgZm9yIGEgcGFzc2VkIGBDYXNlUmVkdWNlcmBcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG50eXBlIEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxDUiwgVHlwZSBleHRlbmRzIHN0cmluZz4gPSBDUiBleHRlbmRzIChzdGF0ZTogYW55LCBhY3Rpb246IGluZmVyIEFjdGlvbikgPT4gYW55ID8gQWN0aW9uIGV4dGVuZHMge1xuICBwYXlsb2FkOiBpbmZlciBQO1xufSA/IFBheWxvYWRBY3Rpb25DcmVhdG9yPFAsIFR5cGU+IDogQWN0aW9uQ3JlYXRvcldpdGhvdXRQYXlsb2FkPFR5cGU+IDogQWN0aW9uQ3JlYXRvcldpdGhvdXRQYXlsb2FkPFR5cGU+O1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgQ2FzZVJlZHVjZXJzIG91dCBvZiBhIGByZWR1Y2Vyc2Agb2JqZWN0LCBldmVuIGlmIHRoZXkgYXJlXG4gKiB0ZXN0ZWQgaW50byBhIGBDYXNlUmVkdWNlcldpdGhQcmVwYXJlYC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG50eXBlIFNsaWNlRGVmaW5lZENhc2VSZWR1Y2VyczxDYXNlUmVkdWNlcnMgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2Vyczxhbnk+PiA9IHsgW1R5cGUgaW4ga2V5b2YgQ2FzZVJlZHVjZXJzXTogQ2FzZVJlZHVjZXJzW1R5cGVdIGV4dGVuZHMgaW5mZXIgRGVmaW5pdGlvbiA/IERlZmluaXRpb24gZXh0ZW5kcyBBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+ID8gSWQ8UGljazxSZXF1aXJlZDxEZWZpbml0aW9uPiwgJ2Z1bGZpbGxlZCcgfCAncmVqZWN0ZWQnIHwgJ3BlbmRpbmcnIHwgJ3NldHRsZWQnPj4gOiBEZWZpbml0aW9uIGV4dGVuZHMge1xuICByZWR1Y2VyOiBpbmZlciBSZWR1Y2VyO1xufSA/IFJlZHVjZXIgOiBEZWZpbml0aW9uIDogbmV2ZXIgfTtcbnR5cGUgUmVtYXBwZWRTZWxlY3RvcjxTIGV4dGVuZHMgU2VsZWN0b3IsIE5ld1N0YXRlPiA9IFMgZXh0ZW5kcyBTZWxlY3RvcjxhbnksIGluZmVyIFIsIGluZmVyIFA+ID8gU2VsZWN0b3I8TmV3U3RhdGUsIFIsIFA+ICYge1xuICB1bndyYXBwZWQ6IFM7XG59IDogbmV2ZXI7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBmaW5hbCBzZWxlY3RvciB0eXBlIGZyb20gdGhlIGBzZWxlY3RvcnNgIG9iamVjdC5cbiAqXG4gKiBSZW1vdmVzIHRoZSBgc3RyaW5nYCBpbmRleCBzaWduYXR1cmUgZnJvbSB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqL1xuXG50eXBlIFNsaWNlRGVmaW5lZFNlbGVjdG9yczxTdGF0ZSwgU2VsZWN0b3JzIGV4dGVuZHMgU2xpY2VTZWxlY3RvcnM8U3RhdGU+LCBSb290U3RhdGU+ID0geyBbSyBpbiBrZXlvZiBTZWxlY3RvcnMgYXMgc3RyaW5nIGV4dGVuZHMgSyA/IG5ldmVyIDogS106IFJlbWFwcGVkU2VsZWN0b3I8U2VsZWN0b3JzW0tdLCBSb290U3RhdGU+IH07XG4vKipcbiAqIFVzZWQgb24gYSBTbGljZUNhc2VSZWR1Y2VycyBvYmplY3QuXG4gKiBFbnN1cmVzIHRoYXQgaWYgYSBDYXNlUmVkdWNlciBpcyBhIGBDYXNlUmVkdWNlcldpdGhQcmVwYXJlYCwgdGhhdFxuICogdGhlIGByZWR1Y2VyYCBhbmQgdGhlIGBwcmVwYXJlYCBmdW5jdGlvbiB1c2UgdGhlIHNhbWUgdHlwZSBvZiBgcGF5bG9hZGAuXG4gKlxuICogTWlnaHQgZG8gYWRkaXRpb25hbCBzdWNoIGNoZWNrcyBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIFRoaXMgdHlwZSBpcyBvbmx5IGV2ZXIgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdyaXRlIHlvdXIgb3duIHdyYXBwZXIgYXJvdW5kXG4gKiBgY3JlYXRlU2xpY2VgLiBQbGVhc2UgZG9uJ3QgdXNlIGl0IG90aGVyd2lzZSFcbiAqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IHR5cGUgVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VyczxTLCBBQ1IgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2VyczxTPj4gPSBBQ1IgJiB7IFtUIGluIGtleW9mIEFDUl06IEFDUltUXSBleHRlbmRzIHtcbiAgcmVkdWNlcihzOiBTLCBhY3Rpb24/OiBpbmZlciBBKTogYW55O1xufSA/IHtcbiAgcHJlcGFyZSguLi5hOiBuZXZlcltdKTogT21pdDxBLCAndHlwZSc+O1xufSA6IHt9IH07XG5cbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2U6IHN0cmluZywgYWN0aW9uS2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5cbmludGVyZmFjZSBCdWlsZENyZWF0ZVNsaWNlQ29uZmlnIHtcbiAgY3JlYXRvcnM/OiB7XG4gICAgYXN5bmNUaHVuaz86IHR5cGVvZiBhc3luY1RodW5rQ3JlYXRvcjtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn06IEJ1aWxkQ3JlYXRlU2xpY2VDb25maWcgPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiwgTmFtZSBleHRlbmRzIHN0cmluZywgU2VsZWN0b3JzIGV4dGVuZHMgU2xpY2VTZWxlY3RvcnM8U3RhdGU+LCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IE5hbWU+KG9wdGlvbnM6IENyZWF0ZVNsaWNlT3B0aW9uczxTdGF0ZSwgQ2FzZVJlZHVjZXJzLCBOYW1lLCBSZWR1Y2VyUGF0aCwgU2VsZWN0b3JzPik6IFNsaWNlPFN0YXRlLCBDYXNlUmVkdWNlcnMsIE5hbWUsIFJlZHVjZXJQYXRoLCBTZWxlY3RvcnM+IHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSAoKG5hbWUgYXMgdW5rbm93bikgYXMgUmVkdWNlclBhdGgpXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiAnYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVkdWNlcnMgPSAodHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzPFN0YXRlPigpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0OiBSZWR1Y2VySGFuZGxpbmdDb250ZXh0PFN0YXRlPiA9IHtcbiAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lOiB7fSxcbiAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlOiB7fSxcbiAgICAgIGFjdGlvbkNyZWF0b3JzOiB7fSxcbiAgICAgIHNsaWNlTWF0Y2hlcnM6IFtdXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0TWV0aG9kczogUmVkdWNlckhhbmRsaW5nQ29udGV4dE1ldGhvZHM8U3RhdGU+ID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yOiBzdHJpbmcgfCBUeXBlZEFjdGlvbkNyZWF0b3I8YW55PiwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGU+KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gJ3N0cmluZycgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMTIpIDogJ2Bjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgaW4gY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMTMpIDogJ2Bjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcblxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG5cbiAgICAgIGV4cG9zZUFjdGlvbihuYW1lLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZV0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuXG4gICAgICBleHBvc2VDYXNlUmVkdWNlcihuYW1lLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZV0gPSByZWR1Y2VyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKHJlZHVjZXJOYW1lID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHM6IFJlZHVjZXJEZXRhaWxzID0ge1xuICAgICAgICByZWR1Y2VyTmFtZSxcbiAgICAgICAgdHlwZTogZ2V0VHlwZShuYW1lLCByZWR1Y2VyTmFtZSksXG4gICAgICAgIGNyZWF0ZU5vdGF0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgfTtcblxuICAgICAgaWYgKGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdW5kZWZpbmVkXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09ICdmdW5jdGlvbicgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHsgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCBidWlsZGVyID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGZpbmFsQ2FzZVJlZHVjZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGtleSwgKGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0gYXMgQ2FzZVJlZHVjZXI8YW55PikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgc00gb2YgY29udGV4dC5zbGljZU1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKHNNLm1hdGNoZXIsIHNNLnJlZHVjZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RTZWxmID0gKHN0YXRlOiBTdGF0ZSkgPT4gc3RhdGU7XG5cbiAgICBjb25zdCBpbmplY3RlZFNlbGVjdG9yQ2FjaGUgPSBuZXcgTWFwPGJvb2xlYW4sIFdlYWtNYXA8KHJvb3RTdGF0ZTogYW55KSA9PiBTdGF0ZSB8IHVuZGVmaW5lZCwgUmVjb3JkPHN0cmluZywgKHJvb3RTdGF0ZTogYW55KSA9PiBhbnk+Pj4oKTtcblxuICAgIGxldCBfcmVkdWNlcjogUmVkdWNlcldpdGhJbml0aWFsU3RhdGU8U3RhdGU+O1xuXG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZTogU3RhdGUgfCB1bmRlZmluZWQsIGFjdGlvbjogVW5rbm93bkFjdGlvbikge1xuICAgICAgaWYgKCFfcmVkdWNlcikgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VTZWxlY3RvclByb3BzPEN1cnJlbnRSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IFJlZHVjZXJQYXRoPihyZWR1Y2VyUGF0aDogQ3VycmVudFJlZHVjZXJQYXRoLCBpbmplY3RlZCA9IGZhbHNlKTogUGljazxTbGljZTxTdGF0ZSwgQ2FzZVJlZHVjZXJzLCBOYW1lLCBDdXJyZW50UmVkdWNlclBhdGgsIFNlbGVjdG9ycz4sICdnZXRTZWxlY3RvcnMnIHwgJ3NlbGVjdG9ycycgfCAnc2VsZWN0U2xpY2UnIHwgJ3JlZHVjZXJQYXRoJz4ge1xuICAgICAgZnVuY3Rpb24gc2VsZWN0U2xpY2Uoc3RhdGU6IHsgW0sgaW4gQ3VycmVudFJlZHVjZXJQYXRoXTogU3RhdGUgfSkge1xuICAgICAgICBsZXQgc2xpY2VTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXTtcblxuICAgICAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDE1KSA6ICdzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzbGljZVN0YXRlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGU6IChyb290U3RhdGU6IGFueSkgPT4gU3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBlbXBsYWNlKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgaW5qZWN0ZWQsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IG5ldyBXZWFrTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoZW1wbGFjZShzZWxlY3RvckNhY2hlLCBzZWxlY3RTdGF0ZSwge1xuICAgICAgICAgIGluc2VydDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBTZWxlY3RvcjxhbnksIGFueT4+ID0ge307XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNlbGVjdG9ycyA/PyB7fSkpIHtcbiAgICAgICAgICAgICAgbWFwW25hbWVdID0gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgfVxuICAgICAgICB9KSBhcyBhbnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWR1Y2VyUGF0aCxcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuXG4gICAgICAgIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNlbGVjdG9ycyhzZWxlY3RTbGljZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0U2xpY2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc2xpY2U6IFNsaWNlPFN0YXRlLCBDYXNlUmVkdWNlcnMsIE5hbWUsIFJlZHVjZXJQYXRoLCBTZWxlY3RvcnM+ID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiAoY29udGV4dC5hY3Rpb25DcmVhdG9ycyBhcyBhbnkpLFxuICAgICAgY2FzZVJlZHVjZXJzOiAoY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSBhcyBhbnkpLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlLFxuICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgpLFxuXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiAoeyAuLi5zbGljZSxcbiAgICAgICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhuZXdSZWR1Y2VyUGF0aCwgdHJ1ZSlcbiAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgfVxuXG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdyYXBTZWxlY3RvcjxTdGF0ZSwgTmV3U3RhdGUsIFMgZXh0ZW5kcyBTZWxlY3RvcjxTdGF0ZT4+KHNlbGVjdG9yOiBTLCBzZWxlY3RTdGF0ZTogU2VsZWN0b3I8TmV3U3RhdGUsIFN0YXRlPiwgZ2V0SW5pdGlhbFN0YXRlOiAoKSA9PiBTdGF0ZSwgaW5qZWN0ZWQ/OiBib29sZWFuKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlOiBOZXdTdGF0ZSwgLi4uYXJnczogYW55W10pIHtcbiAgICBsZXQgc2xpY2VTdGF0ZSA9IHNlbGVjdFN0YXRlKHJvb3RTdGF0ZSk7XG5cbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgc2xpY2VTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYoMTYpIDogJ3NlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdG9yKHNsaWNlU3RhdGUsIC4uLmFyZ3MpO1xuICB9XG5cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuICh3cmFwcGVyIGFzIFJlbWFwcGVkU2VsZWN0b3I8UywgTmV3U3RhdGU+KTtcbn1cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gaW5pdGlhbCBzdGF0ZSwgYW4gb2JqZWN0IGZ1bGwgb2YgcmVkdWNlclxuICogZnVuY3Rpb25zLCBhbmQgYSBcInNsaWNlIG5hbWVcIiwgYW5kIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzXG4gKiBhY3Rpb24gY3JlYXRvcnMgYW5kIGFjdGlvbiB0eXBlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gKiByZWR1Y2VycyBhbmQgc3RhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNsaWNlID0gLyogQF9fUFVSRV9fICovYnVpbGRDcmVhdGVTbGljZSgpO1xuaW50ZXJmYWNlIFJlZHVjZXJIYW5kbGluZ0NvbnRleHQ8U3RhdGU+IHtcbiAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IFJlY29yZDxzdHJpbmcsIENhc2VSZWR1Y2VyPFN0YXRlLCBhbnk+IHwgUGljazxBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgYW55LCBhbnksIGFueT4sICdmdWxmaWxsZWQnIHwgJ3JlamVjdGVkJyB8ICdwZW5kaW5nJyB8ICdzZXR0bGVkJz4+O1xuICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZTogUmVjb3JkPHN0cmluZywgQ2FzZVJlZHVjZXI8U3RhdGUsIGFueT4+O1xuICBzbGljZU1hdGNoZXJzOiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFN0YXRlPjtcbiAgYWN0aW9uQ3JlYXRvcnM6IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uPjtcbn1cbmludGVyZmFjZSBSZWR1Y2VySGFuZGxpbmdDb250ZXh0TWV0aG9kczxTdGF0ZT4ge1xuICAvKipcbiAgICogQWRkcyBhIGNhc2UgcmVkdWNlciB0byBoYW5kbGUgYSBzaW5nbGUgYWN0aW9uIHR5cGUuXG4gICAqIEBwYXJhbSBhY3Rpb25DcmVhdG9yIC0gRWl0aGVyIGEgcGxhaW4gYWN0aW9uIHR5cGUgc3RyaW5nLCBvciBhbiBhY3Rpb24gY3JlYXRvciBnZW5lcmF0ZWQgYnkgW2BjcmVhdGVBY3Rpb25gXSguL2NyZWF0ZUFjdGlvbikgdGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFjdGlvbiB0eXBlLlxuICAgKiBAcGFyYW0gcmVkdWNlciAtIFRoZSBhY3R1YWwgY2FzZSByZWR1Y2VyIGZ1bmN0aW9uLlxuICAgKi9cbiAgYWRkQ2FzZTxBY3Rpb25DcmVhdG9yIGV4dGVuZHMgVHlwZWRBY3Rpb25DcmVhdG9yPHN0cmluZz4+KGFjdGlvbkNyZWF0b3I6IEFjdGlvbkNyZWF0b3IsIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFjdGlvbkNyZWF0b3I+Pik6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPjtcbiAgLyoqXG4gICAqIEFkZHMgYSBjYXNlIHJlZHVjZXIgdG8gaGFuZGxlIGEgc2luZ2xlIGFjdGlvbiB0eXBlLlxuICAgKiBAcGFyYW0gYWN0aW9uQ3JlYXRvciAtIEVpdGhlciBhIHBsYWluIGFjdGlvbiB0eXBlIHN0cmluZywgb3IgYW4gYWN0aW9uIGNyZWF0b3IgZ2VuZXJhdGVkIGJ5IFtgY3JlYXRlQWN0aW9uYF0oLi9jcmVhdGVBY3Rpb24pIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhY3Rpb24gdHlwZS5cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICovXG5cbiAgYWRkQ2FzZTxUeXBlIGV4dGVuZHMgc3RyaW5nLCBBIGV4dGVuZHMgQWN0aW9uPFR5cGU+Pih0eXBlOiBUeXBlLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQT4pOiBSZWR1Y2VySGFuZGxpbmdDb250ZXh0TWV0aG9kczxTdGF0ZT47XG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIG1hdGNoIGluY29taW5nIGFjdGlvbnMgYWdhaW5zdCB5b3VyIG93biBmaWx0ZXIgZnVuY3Rpb24gaW5zdGVhZCBvZiBvbmx5IHRoZSBgYWN0aW9uLnR5cGVgIHByb3BlcnR5LlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBtdWx0aXBsZSBtYXRjaGVyIHJlZHVjZXJzIG1hdGNoLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlclxuICAgKiB0aGV5IHdlcmUgZGVmaW5lZCBpbiAtIGV2ZW4gaWYgYSBjYXNlIHJlZHVjZXIgYWxyZWFkeSBtYXRjaGVkLlxuICAgKiBBbGwgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgbXVzdCBjb21lIGFmdGVyIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlYCBhbmQgYmVmb3JlIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAuXG4gICAqIEBwYXJhbSBtYXRjaGVyIC0gQSBtYXRjaGVyIGZ1bmN0aW9uLiBJbiBUeXBlU2NyaXB0LCB0aGlzIHNob3VsZCBiZSBhIFt0eXBlIHByZWRpY2F0ZV0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svMi9uYXJyb3dpbmcuaHRtbCN1c2luZy10eXBlLXByZWRpY2F0ZXMpXG4gICAqICAgZnVuY3Rpb25cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICpcbiAgICovXG5cbiAgYWRkTWF0Y2hlcjxBPihtYXRjaGVyOiBUeXBlR3VhcmQ8QT4sIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBBIGV4dGVuZHMgQWN0aW9uID8gQSA6IEEgJiBBY3Rpb24+KTogUmVkdWNlckhhbmRsaW5nQ29udGV4dE1ldGhvZHM8U3RhdGU+O1xuICAvKipcbiAgICogQWRkIGFuIGFjdGlvbiB0byBiZSBleHBvc2VkIHVuZGVyIHRoZSBmaW5hbCBgc2xpY2UuYWN0aW9uc2Aga2V5LlxuICAgKiBAcGFyYW0gbmFtZSBUaGUga2V5IHRvIGJlIGV4cG9zZWQgYXMuXG4gICAqIEBwYXJhbSBhY3Rpb25DcmVhdG9yIFRoZSBhY3Rpb24gdG8gZXhwb3NlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb250ZXh0LmV4cG9zZUFjdGlvbihcImFkZFBvc3RcIiwgY3JlYXRlQWN0aW9uPFBvc3Q+KFwiYWRkUG9zdFwiKSk7XG4gICAqXG4gICAqIGV4cG9ydCBjb25zdCB7IGFkZFBvc3QgfSA9IHNsaWNlLmFjdGlvbnNcbiAgICpcbiAgICogZGlzcGF0Y2goYWRkUG9zdChwb3N0KSlcbiAgICovXG5cbiAgZXhwb3NlQWN0aW9uKG5hbWU6IHN0cmluZywgYWN0aW9uQ3JlYXRvcjogRnVuY3Rpb24pOiBSZWR1Y2VySGFuZGxpbmdDb250ZXh0TWV0aG9kczxTdGF0ZT47XG4gIC8qKlxuICAgKiBBZGQgYSBjYXNlIHJlZHVjZXIgdG8gYmUgZXhwb3NlZCB1bmRlciB0aGUgZmluYWwgYHNsaWNlLmNhc2VSZWR1Y2Vyc2Aga2V5LlxuICAgKiBAcGFyYW0gbmFtZSBUaGUga2V5IHRvIGJlIGV4cG9zZWQgYXMuXG4gICAqIEBwYXJhbSByZWR1Y2VyIFRoZSByZWR1Y2VyIHRvIGV4cG9zZS5cbiAgICogQGV4YW1wbGVcbiAgICogY29udGV4dC5leHBvc2VDYXNlUmVkdWNlcihcImFkZFBvc3RcIiwgKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248UG9zdD4pID0+IHtcbiAgICogICBzdGF0ZS5wdXNoKGFjdGlvbi5wYXlsb2FkKVxuICAgKiB9KVxuICAgKlxuICAgKiBzbGljZS5jYXNlUmVkdWNlcnMuYWRkUG9zdChbXSwgYWRkUG9zdChwb3N0KSlcbiAgICovXG5cbiAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTogc3RyaW5nLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgYW55PiB8IFBpY2s8QXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIGFueSwgYW55LCBhbnk+LCAnZnVsZmlsbGVkJyB8ICdyZWplY3RlZCcgfCAncGVuZGluZycgfCAnc2V0dGxlZCc+KTogUmVkdWNlckhhbmRsaW5nQ29udGV4dE1ldGhvZHM8U3RhdGU+O1xufVxuaW50ZXJmYWNlIFJlZHVjZXJEZXRhaWxzIHtcbiAgLyoqIFRoZSBrZXkgdGhlIHJlZHVjZXIgd2FzIGRlZmluZWQgdW5kZXIgKi9cbiAgcmVkdWNlck5hbWU6IHN0cmluZztcbiAgLyoqIFRoZSBwcmVkZWZpbmVkIGFjdGlvbiB0eXBlLCBpLmUuIGAke3NsaWNlLm5hbWV9LyR7cmVkdWNlck5hbWV9YCAqL1xuXG4gIHR5cGU6IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgY3JlYXRlLiBub3RhdGlvbiB3YXMgdXNlZCB3aGVuIGRlZmluaW5nIHJlZHVjZXJzICovXG5cbiAgY3JlYXRlTm90YXRpb246IGJvb2xlYW47XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVkdWNlckNyZWF0b3JzPFN0YXRlPigpOiBSZWR1Y2VyQ3JlYXRvcnM8U3RhdGU+IHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvcjogQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yPGFueSwgYW55PiwgY29uZmlnOiBBc3luY1RodW5rU2xpY2VSZWR1Y2VyQ29uZmlnPFN0YXRlLCBhbnk+KTogQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBSZWR1Y2VyVHlwZS5hc3luY1RodW5rLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG5cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuXG4gIHJldHVybiB7XG4gICAgcmVkdWNlcihjYXNlUmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIGFueT4pIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgY2FzZVJlZHVjZXI+KSB7XG4gICAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2VyKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sICh7XG4gICAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFJlZHVjZXJUeXBlLnJlZHVjZXJcbiAgICAgIH0gYXMgY29uc3QpKTtcbiAgICB9LFxuXG4gICAgcHJlcGFyZWRSZWR1Y2VyKHByZXBhcmUsIHJlZHVjZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFJlZHVjZXJUeXBlLnJlZHVjZXJXaXRoUHJlcGFyZSxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmNUaHVuazogKGFzeW5jVGh1bmsgYXMgYW55KVxuICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZT4oe1xuICB0eXBlLFxuICByZWR1Y2VyTmFtZSxcbiAgY3JlYXRlTm90YXRpb25cbn06IFJlZHVjZXJEZXRhaWxzLCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTogQ2FzZVJlZHVjZXI8U3RhdGUsIHtcbiAgcGF5bG9hZDogYW55O1xuICB0eXBlOiBzdHJpbmc7XG59PiB8IENhc2VSZWR1Y2VyV2l0aFByZXBhcmU8U3RhdGUsIFBheWxvYWRBY3Rpb248YW55LCBzdHJpbmcsIGFueSwgYW55Pj4sIGNvbnRleHQ6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPikge1xuICBsZXQgY2FzZVJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBhbnk+O1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrOiBQcmVwYXJlQWN0aW9uPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgaWYgKCdyZWR1Y2VyJyBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoMTcpIDogJ1BsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLicpO1xuICAgIH1cblxuICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucmVkdWNlcjtcbiAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xuICB9IGVsc2Uge1xuICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmU7XG4gIH1cblxuICBjb250ZXh0LmFkZENhc2UodHlwZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCBjYXNlUmVkdWNlcikuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKSk7XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZWZpbml0aW9uOiBhbnkpOiByZWR1Y2VyRGVmaW5pdGlvbiBpcyBBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgYW55LCBhbnksIGFueT4ge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gUmVkdWNlclR5cGUuYXN5bmNUaHVuaztcbn1cblxuZnVuY3Rpb24gaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbjxTdGF0ZT4ocmVkdWNlckRlZmluaXRpb246IGFueSk6IHJlZHVjZXJEZWZpbml0aW9uIGlzIENhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uPFN0YXRlLCBhbnk+IHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFJlZHVjZXJUeXBlLnJlZHVjZXJXaXRoUHJlcGFyZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn06IFJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbjogQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIGFueSwgYW55LCBhbnk+LCBjb250ZXh0OiBSZWR1Y2VySGFuZGxpbmdDb250ZXh0TWV0aG9kczxTdGF0ZT4sIGNBVDogdHlwZW9mIF9jcmVhdGVBc3luY1RodW5rIHwgdW5kZWZpbmVkKSB7XG4gIGlmICghY0FUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOCgxOCkgOiAnQ2Fubm90IHVzZSBgY3JlYXRlLmFzeW5jVGh1bmtgIGluIHRoZSBidWlsdC1pbiBgY3JlYXRlU2xpY2VgLiAnICsgJ1VzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLicpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHBheWxvYWRDcmVhdG9yLFxuICAgIGZ1bGZpbGxlZCxcbiAgICBwZW5kaW5nLFxuICAgIHJlamVjdGVkLFxuICAgIHNldHRsZWQsXG4gICAgb3B0aW9uc1xuICB9ID0gcmVkdWNlckRlZmluaXRpb247XG4gIGNvbnN0IHRodW5rID0gY0FUKHR5cGUsIHBheWxvYWRDcmVhdG9yLCAob3B0aW9ucyBhcyBhbnkpKTtcbiAgY29udGV4dC5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHRodW5rKTtcblxuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuXG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG5cbiAgaWYgKHJlamVjdGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnJlamVjdGVkLCByZWplY3RlZCk7XG4gIH1cblxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuXG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fSIsImltcG9ydCB0eXBlIHsgRW50aXR5SWQsIEVudGl0eVN0YXRlLCBFbnRpdHlTdGF0ZUFkYXB0ZXIsIEVudGl0eVN0YXRlRmFjdG9yeSB9IGZyb20gJy4vbW9kZWxzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGU8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4oKTogRW50aXR5U3RhdGU8VCwgSWQ+IHtcbiAgcmV0dXJuIHtcbiAgICBpZHM6IFtdLFxuICAgIGVudGl0aWVzOiAoe30gYXMgUmVjb3JkPElkLCBUPilcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5PFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KHN0YXRlQWRhcHRlcjogRW50aXR5U3RhdGVBZGFwdGVyPFQsIElkPik6IEVudGl0eVN0YXRlRmFjdG9yeTxULCBJZD4ge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoc3RhdGU/OiB1bmRlZmluZWQsIGVudGl0aWVzPzogcmVhZG9ubHkgVFtdIHwgUmVjb3JkPElkLCBUPik6IEVudGl0eVN0YXRlPFQsIElkPjtcbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlPFMgZXh0ZW5kcyBvYmplY3Q+KGFkZGl0aW9uYWxTdGF0ZTogUywgZW50aXRpZXM/OiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+KTogRW50aXR5U3RhdGU8VCwgSWQ+ICYgUztcblxuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlOiBhbnkgPSB7fSwgZW50aXRpZXM/OiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+KTogYW55IHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldEluaXRpYWxTdGF0ZVxuICB9O1xufSIsImltcG9ydCB0eXBlIHsgQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbiwgU2VsZWN0b3IsIGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgfSBmcm9tICcuLi9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvcic7XG5pbXBvcnQgdHlwZSB7IEVudGl0eVN0YXRlLCBFbnRpdHlTZWxlY3RvcnMsIEVudGl0eUlkIH0gZnJvbSAnLi9tb2RlbHMnO1xudHlwZSBBbnlGdW5jdGlvbiA9ICguLi5hcmdzOiBhbnkpID0+IGFueTtcbnR5cGUgQW55Q3JlYXRlU2VsZWN0b3JGdW5jdGlvbiA9IENyZWF0ZVNlbGVjdG9yRnVuY3Rpb248PEYgZXh0ZW5kcyBBbnlGdW5jdGlvbj4oZjogRikgPT4gRiwgPEYgZXh0ZW5kcyBBbnlGdW5jdGlvbj4oZjogRikgPT4gRj47XG5leHBvcnQgaW50ZXJmYWNlIEdldFNlbGVjdG9yc09wdGlvbnMge1xuICBjcmVhdGVTZWxlY3Rvcj86IEFueUNyZWF0ZVNlbGVjdG9yRnVuY3Rpb247XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeTxULCBJZCBleHRlbmRzIEVudGl0eUlkPigpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlPzogdW5kZWZpbmVkLCBvcHRpb25zPzogR2V0U2VsZWN0b3JzT3B0aW9ucyk6IEVudGl0eVNlbGVjdG9yczxULCBFbnRpdHlTdGF0ZTxULCBJZD4sIElkPjtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzPFY+KHNlbGVjdFN0YXRlOiAoc3RhdGU6IFYpID0+IEVudGl0eVN0YXRlPFQsIElkPiwgb3B0aW9ucz86IEdldFNlbGVjdG9yc09wdGlvbnMpOiBFbnRpdHlTZWxlY3RvcnM8VCwgViwgSWQ+O1xuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yczxWPihzZWxlY3RTdGF0ZT86IChzdGF0ZTogVikgPT4gRW50aXR5U3RhdGU8VCwgSWQ+LCBvcHRpb25zOiBHZXRTZWxlY3RvcnNPcHRpb25zID0ge30pOiBFbnRpdHlTZWxlY3RvcnM8VCwgYW55LCBJZD4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNyZWF0ZVNlbGVjdG9yID0gKGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yIGFzIEFueUNyZWF0ZVNlbGVjdG9yRnVuY3Rpb24pXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGU6IEVudGl0eVN0YXRlPFQsIElkPikgPT4gc3RhdGUuaWRzO1xuXG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGU6IEVudGl0eVN0YXRlPFQsIElkPikgPT4gc3RhdGUuZW50aXRpZXM7XG5cbiAgICBjb25zdCBzZWxlY3RBbGwgPSBjcmVhdGVTZWxlY3RvcihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcyk6IFRbXSA9PiBpZHMubWFwKGlkID0+IGVudGl0aWVzW2lkXSEpKTtcblxuICAgIGNvbnN0IHNlbGVjdElkID0gKF86IHVua25vd24sIGlkOiBJZCkgPT4gaWQ7XG5cbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzOiBSZWNvcmQ8SWQsIFQ+LCBpZDogSWQpID0+IGVudGl0aWVzW2lkXTtcblxuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0SWRzLCBpZHMgPT4gaWRzLmxlbmd0aCk7XG5cbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcihzZWxlY3RFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yKChzZWxlY3RTdGF0ZSBhcyBTZWxlY3RvcjxWLCBFbnRpdHlTdGF0ZTxULCBJZD4+KSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEFsbCksXG4gICAgICBzZWxlY3RUb3RhbDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0U2VsZWN0b3JzXG4gIH07XG59IiwiaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsIGlzRHJhZnQgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgdHlwZSB7IERyYWZ0IH0gZnJvbSAnaW1tZXInO1xuaW1wb3J0IHR5cGUgeyBFbnRpdHlJZCwgRHJhZnRhYmxlRW50aXR5U3RhdGUsIFByZXZlbnRBbnkgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgdHlwZSB7IFBheWxvYWRBY3Rpb24gfSBmcm9tICcuLi9jcmVhdGVBY3Rpb24nO1xuaW1wb3J0IHsgaXNGU0EgfSBmcm9tICcuLi9jcmVhdGVBY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzRHJhZnRUeXBlZCA9IChpc0RyYWZ0IGFzIDxUPih2YWx1ZTogVCB8IERyYWZ0PFQ+KSA9PiB2YWx1ZSBpcyBEcmFmdDxUPik7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yPFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KG11dGF0b3I6IChzdGF0ZTogRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+KSA9PiB2b2lkKSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcigoXzogdW5kZWZpbmVkLCBzdGF0ZTogRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+KSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb248UyBleHRlbmRzIERyYWZ0YWJsZUVudGl0eVN0YXRlPFQsIElkPj4oc3RhdGU6IFByZXZlbnRBbnk8UywgVCwgSWQ+KTogUyB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKChzdGF0ZSBhcyBTKSwgdW5kZWZpbmVkKTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yPFQsIElkIGV4dGVuZHMgRW50aXR5SWQsIFI+KG11dGF0b3I6IChhcmc6IFIsIHN0YXRlOiBEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD4pID0+IHZvaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbjxTIGV4dGVuZHMgRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+PihzdGF0ZTogUywgYXJnOiBSIHwgUGF5bG9hZEFjdGlvbjxSPik6IFMge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzogUiB8IFBheWxvYWRBY3Rpb248Uj4pOiBhcmcgaXMgUGF5bG9hZEFjdGlvbjxSPiB7XG4gICAgICByZXR1cm4gaXNGU0EoYXJnKTtcbiAgICB9XG5cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0OiBEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD4pID0+IHtcbiAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XG4gICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChpc0RyYWZ0VHlwZWQ8RHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+PihzdGF0ZSkpIHtcbiAgICAgIC8vIHdlIG11c3QgYWxyZWFkeSBiZSBpbnNpZGUgYSBgY3JlYXRlTmV4dFN0YXRlYCBjYWxsLCBsaWtlbHkgYmVjYXVzZVxuICAgICAgLy8gdGhpcyBpcyBiZWluZyB3cmFwcGVkIGluIGBjcmVhdGVSZWR1Y2VyYCBvciBgY3JlYXRlU2xpY2VgLlxuICAgICAgLy8gSXQncyBzYWZlIHRvIGp1c3QgcGFzcyB0aGUgZHJhZnQgdG8gdGhlIG11dGF0b3IuXG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTsgLy8gc2luY2UgaXQncyBhIGRyYWZ0LCB3ZSdsbCBqdXN0IHJldHVybiBpdFxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZShzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59IiwiaW1wb3J0IHR5cGUgeyBJZFNlbGVjdG9yLCBVcGRhdGUsIEVudGl0eUlkLCBEcmFmdGFibGVFbnRpdHlTdGF0ZSB9IGZyb20gJy4vbW9kZWxzJztcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RJZFZhbHVlPFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KGVudGl0eTogVCwgc2VsZWN0SWQ6IElkU2VsZWN0b3I8VCwgSWQ+KSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1RoZSBlbnRpdHkgcGFzc2VkIHRvIHRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uIHJldHVybmVkIHVuZGVmaW5lZC4nLCAnWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uJywgJ1RoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOicsIGVudGl0eSwgJ1RoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uOicsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5PFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KGVudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+KTogcmVhZG9ubHkgVFtdIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cblxuICByZXR1cm4gZW50aXRpZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllczxULCBJZCBleHRlbmRzIEVudGl0eUlkPihuZXdFbnRpdGllczogcmVhZG9ubHkgVFtdIHwgUmVjb3JkPElkLCBUPiwgc2VsZWN0SWQ6IElkU2VsZWN0b3I8VCwgSWQ+LCBzdGF0ZTogRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+KTogW1RbXSwgVXBkYXRlPFQsIElkPltdXSB7XG4gIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gIGNvbnN0IGFkZGVkOiBUW10gPSBbXTtcbiAgY29uc3QgdXBkYXRlZDogVXBkYXRlPFQsIElkPltdID0gW107XG5cbiAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICBjb25zdCBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG5cbiAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHVwZGF0ZWQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFuZ2VzOiBlbnRpdHlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XG59IiwiaW1wb3J0IHR5cGUgeyBEcmFmdCB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB0eXBlIHsgRW50aXR5U3RhdGVBZGFwdGVyLCBJZFNlbGVjdG9yLCBVcGRhdGUsIEVudGl0eUlkLCBEcmFmdGFibGVFbnRpdHlTdGF0ZSB9IGZyb20gJy4vbW9kZWxzJztcbmltcG9ydCB7IGNyZWF0ZVN0YXRlT3BlcmF0b3IsIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvciB9IGZyb20gJy4vc3RhdGVfYWRhcHRlcic7XG5pbXBvcnQgeyBzZWxlY3RJZFZhbHVlLCBlbnN1cmVFbnRpdGllc0FycmF5LCBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXI8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4oc2VsZWN0SWQ6IElkU2VsZWN0b3I8VCwgSWQ+KTogRW50aXR5U3RhdGVBZGFwdGVyPFQsIElkPiB7XG4gIHR5cGUgUiA9IERyYWZ0YWJsZUVudGl0eVN0YXRlPFQsIElkPjtcblxuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eTogVCwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuXG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLmlkcy5wdXNoKChrZXkgYXMgSWQgJiBEcmFmdDxJZD4pKTtcbiAgICAoc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPilba2V5XSA9IGVudGl0eTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eTogVCwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuXG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goKGtleSBhcyBJZCAmIERyYWZ0PElkPikpO1xuICAgIH1cblxuICAgIDtcbiAgICAoc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPilba2V5XSA9IGVudGl0eTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSAoe30gYXMgUmVjb3JkPElkLCBUPik7XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5OiBJZCwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXM6IHJlYWRvbmx5IElkW10sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgKHN0YXRlLmVudGl0aWVzIGFzIFJlY29yZDxJZCwgVD4pW2tleV07XG4gICAgICAgIGRpZE11dGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSAoKHN0YXRlLmlkcyBhcyBJZFtdKS5maWx0ZXIoaWQgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpIGFzIElkW10gfCBEcmFmdDxJZFtdPik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQWxsTXV0YWJseShzdGF0ZTogUik6IHZvaWQge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcbiAgICAgIGlkczogW10sXG4gICAgICBlbnRpdGllczoge31cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5czoge1xuICAgIFtpZDogc3RyaW5nXTogSWQ7XG4gIH0sIHVwZGF0ZTogVXBkYXRlPFQsIElkPiwgc3RhdGU6IFIpOiBib29sZWFuIHtcbiAgICBjb25zdCBvcmlnaW5hbDogVCB8IHVuZGVmaW5lZCA9IChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVt1cGRhdGUuaWRdO1xuXG4gICAgaWYgKG9yaWdpbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcblxuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSAoc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPilbdXBkYXRlLmlkXTtcbiAgICB9XG5cbiAgICA7XG4gICAgKHN0YXRlLmVudGl0aWVzIGFzIFJlY29yZDxJZCwgVD4pW25ld0tleV0gPSB1cGRhdGVkO1xuICAgIHJldHVybiBoYXNOZXdLZXk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZTogVXBkYXRlPFQsIElkPiwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXM6IFJlYWRvbmx5QXJyYXk8VXBkYXRlPFQsIElkPj4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgY29uc3QgbmV3S2V5czoge1xuICAgICAgW2lkOiBzdHJpbmddOiBJZDtcbiAgICB9ID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eToge1xuICAgICAgW2lkOiBzdHJpbmddOiBVcGRhdGU8VCwgSWQ+O1xuICAgIH0gPSB7fTtcbiAgICB1cGRhdGVzLmZvckVhY2godXBkYXRlID0+IHtcbiAgICAgIC8vIE9ubHkgYXBwbHkgdXBkYXRlcyB0byBlbnRpdGllcyB0aGF0IGN1cnJlbnRseSBleGlzdFxuICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdXBkYXRlcyB0byBvbmUgZW50aXR5LCBtZXJnZSB0aGVtIHRvZ2V0aGVyXG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiB7IC4uLih1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPyB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0uY2hhbmdlcyA6IG51bGwpLFxuICAgICAgICAgICAgLi4udXBkYXRlLmNoYW5nZXNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XG4gICAgY29uc3QgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKHVwZGF0ZSA9PiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpKS5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAoZGlkTXV0YXRlSWRzKSB7XG4gICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpLm1hcChlID0+IHNlbGVjdElkVmFsdWUoKGUgYXMgVCksIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHk6IFQsIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllczogcmVhZG9ubHkgVFtdIHwgUmVjb3JkPElkLCBUPiwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllczxULCBJZD4obmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSksXG4gICAgcmVtb3ZlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU9uZU11dGFibHkpLFxuICAgIHJlbW92ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlTWFueU11dGFibHkpXG4gIH07XG59IiwiaW1wb3J0IHR5cGUgeyBJZFNlbGVjdG9yLCBDb21wYXJlciwgRW50aXR5U3RhdGVBZGFwdGVyLCBVcGRhdGUsIEVudGl0eUlkLCBEcmFmdGFibGVFbnRpdHlTdGF0ZSB9IGZyb20gJy4vbW9kZWxzJztcbmltcG9ydCB7IGNyZWF0ZVN0YXRlT3BlcmF0b3IgfSBmcm9tICcuL3N0YXRlX2FkYXB0ZXInO1xuaW1wb3J0IHsgY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIgfSBmcm9tICcuL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXInO1xuaW1wb3J0IHsgc2VsZWN0SWRWYWx1ZSwgZW5zdXJlRW50aXRpZXNBcnJheSwgc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcjxULCBJZCBleHRlbmRzIEVudGl0eUlkPihzZWxlY3RJZDogSWRTZWxlY3RvcjxULCBJZD4sIHNvcnQ6IENvbXBhcmVyPFQ+KTogRW50aXR5U3RhdGVBZGFwdGVyPFQsIElkPiB7XG4gIHR5cGUgUiA9IERyYWZ0YWJsZUVudGl0eVN0YXRlPFQsIElkPjtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuXG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBjb25zdCBtb2RlbHMgPSBuZXdFbnRpdGllcy5maWx0ZXIobW9kZWwgPT4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpKTtcblxuICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eTogVCwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG5cbiAgICBpZiAobmV3RW50aXRpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9ICh7fSBhcyBSZWNvcmQ8SWQsIFQ+KTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGU6IFVwZGF0ZTxULCBJZD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzOiBSZWFkb25seUFycmF5PFVwZGF0ZTxULCBJZD4+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGVudGl0eTogVCB8IHVuZGVmaW5lZCA9IChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVt1cGRhdGUuaWRdO1xuXG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgIGNvbnN0IG5ld0lkID0gc2VsZWN0SWQoZW50aXR5KTtcblxuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgZGVsZXRlIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVt1cGRhdGUuaWRdO1xuICAgICAgICAoc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPilbbmV3SWRdID0gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXM8VCwgSWQ+KG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYTogcmVhZG9ubHkgdW5rbm93bltdLCBiOiByZWFkb25seSB1bmtub3duW10pIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlKG1vZGVsczogcmVhZG9ubHkgVFtdLCBzdGF0ZTogUik6IHZvaWQge1xuICAgIC8vIEluc2VydC9vdmVyd3JpdGUgYWxsIG5ldy91cGRhdGVkXG4gICAgbW9kZWxzLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgO1xuICAgICAgKHN0YXRlLmVudGl0aWVzIGFzIFJlY29yZDxJZCwgVD4pW3NlbGVjdElkKG1vZGVsKV0gPSBtb2RlbDtcbiAgICB9KTtcbiAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvcnRFbnRpdGllcyhzdGF0ZTogUikge1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gKE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpIGFzIFRbXSk7XG4gICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcbiAgICBjb25zdCBuZXdTb3J0ZWRJZHMgPSBhbGxFbnRpdGllcy5tYXAoc2VsZWN0SWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkc1xuICAgIH0gPSBzdGF0ZTtcblxuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVPbmUsXG4gICAgcmVtb3ZlTWFueSxcbiAgICByZW1vdmVBbGwsXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxuICB9O1xufSIsImltcG9ydCB0eXBlIHsgRW50aXR5QWRhcHRlciwgRW50aXR5SWQsIEVudGl0eUFkYXB0ZXJPcHRpb25zIH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHsgY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vZW50aXR5X3N0YXRlJztcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkgfSBmcm9tICcuL3N0YXRlX3NlbGVjdG9ycyc7XG5pbXBvcnQgeyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIgfSBmcm9tICcuL3NvcnRlZF9zdGF0ZV9hZGFwdGVyJztcbmltcG9ydCB7IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIH0gZnJvbSAnLi91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyJztcbmltcG9ydCB0eXBlIHsgV2l0aFJlcXVpcmVkUHJvcCB9IGZyb20gJy4uL3RzSGVscGVycyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcjxULCBJZCBleHRlbmRzIEVudGl0eUlkPihvcHRpb25zOiBXaXRoUmVxdWlyZWRQcm9wPEVudGl0eUFkYXB0ZXJPcHRpb25zPFQsIElkPiwgJ3NlbGVjdElkJz4pOiBFbnRpdHlBZGFwdGVyPFQsIElkPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyPFQgZXh0ZW5kcyB7XG4gIGlkOiBFbnRpdHlJZDtcbn0+KG9wdGlvbnM/OiBPbWl0PEVudGl0eUFkYXB0ZXJPcHRpb25zPFQsIFRbJ2lkJ10+LCAnc2VsZWN0SWQnPik6IEVudGl0eUFkYXB0ZXI8VCwgVFsnaWQnXT47XG4vKipcbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcjxUPihvcHRpb25zOiBFbnRpdHlBZGFwdGVyT3B0aW9uczxULCBFbnRpdHlJZD4gPSB7fSk6IEVudGl0eUFkYXB0ZXI8VCwgRW50aXR5SWQ+IHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9OiBSZXF1aXJlZDxFbnRpdHlBZGFwdGVyT3B0aW9uczxULCBFbnRpdHlJZD4+ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZTogYW55KSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeShzdGF0ZUFkYXB0ZXIpO1xuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeTxULCBFbnRpdHlJZD4oKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiwgRGlzcGF0Y2gsIE1pZGRsZXdhcmVBUEksIFVua25vd25BY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgVGh1bmtEaXNwYXRjaCB9IGZyb20gJ3JlZHV4LXRodW5rJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiB9IGZyb20gJy4uL2NyZWF0ZUFjdGlvbic7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICcuLi9uYW5vaWQnO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFRhc2tBYm9ydEVycm9yLCBsaXN0ZW5lckNhbmNlbGxlZCwgbGlzdGVuZXJDb21wbGV0ZWQsIHRhc2tDYW5jZWxsZWQsIHRhc2tDb21wbGV0ZWQgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHsgY3JlYXRlRGVsYXksIGNyZWF0ZVBhdXNlLCByYWNlV2l0aFNpZ25hbCwgcnVuVGFzaywgdmFsaWRhdGVBY3RpdmUgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHR5cGUgeyBBYm9ydFNpZ25hbFdpdGhSZWFzb24sIEFkZExpc3RlbmVyT3ZlcmxvYWRzLCBBbnlMaXN0ZW5lclByZWRpY2F0ZSwgQ3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlT3B0aW9ucywgRmFsbGJhY2tBZGRMaXN0ZW5lck9wdGlvbnMsIEZvcmtPcHRpb25zLCBGb3JrZWRUYXNrLCBGb3JrZWRUYXNrRXhlY3V0b3IsIExpc3RlbmVyRW50cnksIExpc3RlbmVyRXJyb3JIYW5kbGVyLCBMaXN0ZW5lckVycm9ySW5mbywgTGlzdGVuZXJNaWRkbGV3YXJlLCBMaXN0ZW5lck1pZGRsZXdhcmVJbnN0YW5jZSwgVGFrZVBhdHRlcm4sIFRhc2tSZXN1bHQsIFR5cGVkQWRkTGlzdGVuZXIsIFR5cGVkQ3JlYXRlTGlzdGVuZXJFbnRyeSwgVHlwZWRSZW1vdmVMaXN0ZW5lciwgVW5zdWJzY3JpYmVMaXN0ZW5lciwgVW5zdWJzY3JpYmVMaXN0ZW5lck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24sIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIsIGFzc2VydEZ1bmN0aW9uLCBjYXRjaFJlamVjdGlvbiwgbm9vcCB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHsgVGFza0Fib3J0RXJyb3IgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuZXhwb3J0IHR5cGUgeyBBc3luY1Rhc2tFeGVjdXRvciwgQ3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlT3B0aW9ucywgRm9ya2VkVGFzaywgRm9ya2VkVGFza0FQSSwgRm9ya2VkVGFza0V4ZWN1dG9yLCBMaXN0ZW5lckVmZmVjdCwgTGlzdGVuZXJFZmZlY3RBUEksIExpc3RlbmVyRXJyb3JIYW5kbGVyLCBMaXN0ZW5lck1pZGRsZXdhcmUsIExpc3RlbmVyTWlkZGxld2FyZUluc3RhbmNlLCBTeW5jVGFza0V4ZWN1dG9yLCBUYXNrQ2FuY2VsbGVkLCBUYXNrUmVqZWN0ZWQsIFRhc2tSZXNvbHZlZCwgVGFza1Jlc3VsdCwgVHlwZWRBZGRMaXN0ZW5lciwgVHlwZWRSZW1vdmVMaXN0ZW5lciwgVHlwZWRTdGFydExpc3RlbmluZywgVHlwZWRTdG9wTGlzdGVuaW5nLCBVbnN1YnNjcmliZUxpc3RlbmVyLCBVbnN1YnNjcmliZUxpc3RlbmVyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnOyAvL092ZXJseS1hZ2dyZXNzaXZlIGJ5dGUtc2hhdmluZ1xuXG5jb25zdCB7XG4gIGFzc2lnblxufSA9IE9iamVjdDtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuY29uc3QgSU5URVJOQUxfTklMX1RPS0VOID0gKHt9IGFzIGNvbnN0KTtcbmNvbnN0IGFsbSA9ICgnbGlzdGVuZXJNaWRkbGV3YXJlJyBhcyBjb25zdCk7XG5cbmNvbnN0IGNyZWF0ZUZvcmsgPSAocGFyZW50QWJvcnRTaWduYWw6IEFib3J0U2lnbmFsV2l0aFJlYXNvbjx1bmtub3duPiwgcGFyZW50QmxvY2tpbmdQcm9taXNlczogUHJvbWlzZTxhbnk+W10pID0+IHtcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcblxuICByZXR1cm4gPFQsPih0YXNrRXhlY3V0b3I6IEZvcmtlZFRhc2tFeGVjdXRvcjxUPiwgb3B0cz86IEZvcmtPcHRpb25zKTogRm9ya2VkVGFzazxUPiA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCAndGFza0V4ZWN1dG9yJyk7XG4gICAgY29uc3QgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrPFQ+KGFzeW5jICgpOiBQcm9taXNlPFQ+ID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgdGFza0V4ZWN1dG9yKHtcbiAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSkgYXMgVCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG5cbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlPFRhc2tSZXN1bHQ8VD4+KHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuXG4gICAgfTtcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVRha2VQYXR0ZXJuID0gPFMsPihzdGFydExpc3RlbmluZzogQWRkTGlzdGVuZXJPdmVybG9hZHM8VW5zdWJzY3JpYmVMaXN0ZW5lciwgUywgRGlzcGF0Y2g+LCBzaWduYWw6IEFib3J0U2lnbmFsKTogVGFrZVBhdHRlcm48Uz4gPT4ge1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgTGlzdGVuZXJQcmVkaWNhdGUgYW5kIGFuIG9wdGlvbmFsIHRpbWVvdXQsXG4gICAqIGFuZCByZXNvbHZlcyB3aGVuIGVpdGhlciB0aGUgcHJlZGljYXRlIHJldHVybnMgYHRydWVgIGJhc2VkIG9uIGFuIGFjdGlvblxuICAgKiBzdGF0ZSBjb21iaW5hdGlvbiBvciB3aGVuIHRoZSB0aW1lb3V0IGV4cGlyZXMuXG4gICAqIElmIHRoZSBwYXJlbnQgbGlzdGVuZXIgaXMgY2FuY2VsZWQgd2hpbGUgd2FpdGluZywgdGhpcyB3aWxsIHRocm93IGFcbiAgICogVGFza0Fib3J0RXJyb3IuXG4gICAqL1xuICBjb25zdCB0YWtlID0gYXN5bmMgPFAgZXh0ZW5kcyBBbnlMaXN0ZW5lclByZWRpY2F0ZTxTPiw+KHByZWRpY2F0ZTogUCwgdGltZW91dDogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTsgLy8gUGxhY2Vob2xkZXIgdW5zdWJzY3JpYmUgZnVuY3Rpb24gdW50aWwgdGhlIGxpc3RlbmVyIGlzIGFkZGVkXG5cbiAgICBsZXQgdW5zdWJzY3JpYmU6IFVuc3Vic2NyaWJlTGlzdGVuZXIgPSAoKSA9PiB7fTtcblxuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlPFtBY3Rpb24sIFMsIFNdPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBJbnNpZGUgdGhlIFByb21pc2UsIHdlIHN5bmNocm9ub3VzbHkgYWRkIHRoZSBsaXN0ZW5lci5cbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGU6IChwcmVkaWNhdGUgYXMgYW55KSxcbiAgICAgICAgZWZmZWN0OiAoYWN0aW9uLCBsaXN0ZW5lckFwaSk6IHZvaWQgPT4ge1xuICAgICAgICAgIC8vIE9uZS1zaG90IGxpc3RlbmVyIHRoYXQgY2xlYW5zIHVwIGFzIHNvb24gYXMgdGhlIHByZWRpY2F0ZSBwYXNzZXNcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpOyAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIHRoZSBwcmVkaWNhdGUgc2F3XG5cbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzOiAoUHJvbWlzZTxudWxsPiB8IFByb21pc2U8W0FjdGlvbiwgUywgU10+KVtdID0gW3R1cGxlUHJvbWlzZV07XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlPG51bGw+KHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEFsd2F5cyBjbGVhbiB1cCB0aGUgbGlzdGVuZXJcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoKChwcmVkaWNhdGU6IEFueUxpc3RlbmVyUHJlZGljYXRlPFM+LCB0aW1lb3V0OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSkpIGFzIFRha2VQYXR0ZXJuPFM+KTtcbn07XG5cbmNvbnN0IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9uczogRmFsbGJhY2tBZGRMaXN0ZW5lck9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvciEudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkgey8vIHBhc3NcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogJ0NyZWF0aW5nIG9yIHJlbW92aW5nIGEgbGlzdGVuZXIgcmVxdWlyZXMgb25lIG9mIHRoZSBrbm93biBmaWVsZHMgZm9yIG1hdGNoaW5nIGFuIGFjdGlvbicpO1xuICB9XG5cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCAnb3B0aW9ucy5saXN0ZW5lcicpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbi8qKiBBY2NlcHRzIHRoZSBwb3NzaWJsZSBvcHRpb25zIGZvciBjcmVhdGluZyBhIGxpc3RlbmVyLCBhbmQgcmV0dXJucyBhIGZvcm1hdHRlZCBsaXN0ZW5lciBlbnRyeSAqL1xuXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ZW5lckVudHJ5OiBUeXBlZENyZWF0ZUxpc3RlbmVyRW50cnk8dW5rbm93bj4gPSAoKE9iamVjdC5hc3NpZ24oKG9wdGlvbnM6IEZhbGxiYWNrQWRkTGlzdGVuZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gIGNvbnN0IGVudHJ5OiBMaXN0ZW5lckVudHJ5PHVua25vd24+ID0ge1xuICAgIGlkLFxuICAgIGVmZmVjdCxcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBwZW5kaW5nOiBuZXcgU2V0PEFib3J0Q29udHJvbGxlcj4oKSxcbiAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigyMikgOiAnVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZW50cnk7XG59LCB7XG4gIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlTGlzdGVuZXJFbnRyeVxufSkgYXMgdW5rbm93bikgYXMgVHlwZWRDcmVhdGVMaXN0ZW5lckVudHJ5PHVua25vd24+KTtcblxuY29uc3QgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gKGVudHJ5OiBMaXN0ZW5lckVudHJ5PHVua25vd24sIERpc3BhdGNoPFVua25vd25BY3Rpb24+PikgPT4ge1xuICBlbnRyeS5wZW5kaW5nLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcblxuY29uc3QgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSAobGlzdGVuZXJNYXA6IE1hcDxzdHJpbmcsIExpc3RlbmVyRW50cnk+KSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xuICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XG4gIH07XG59O1xuLyoqXG4gKiBTYWZlbHkgcmVwb3J0cyBlcnJvcnMgdG8gdGhlIGBlcnJvckhhbmRsZXJgIHByb3ZpZGVkLlxuICogRXJyb3JzIHRoYXQgb2NjdXIgaW5zaWRlIGBlcnJvckhhbmRsZXJgIGFyZSBub3RpZmllZCBpbiBhIG5ldyB0YXNrLlxuICogSW5zcGlyZWQgYnkgW3J4anMgcmVwb3J0VW5oYW5kbGVkRXJyb3JdKGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdGl2ZVgvcnhqcy9ibG9iLzZmYWZjZjUzZGM5ZTU1NzQzOWIyNWRlYmFlYWRmZDIyNGIyNDVhNjYvc3JjL2ludGVybmFsL3V0aWwvcmVwb3J0VW5oYW5kbGVkRXJyb3IudHMpXG4gKiBAcGFyYW0gZXJyb3JIYW5kbGVyXG4gKiBAcGFyYW0gZXJyb3JUb05vdGlmeVxuICovXG5cblxuY29uc3Qgc2FmZWx5Tm90aWZ5RXJyb3IgPSAoZXJyb3JIYW5kbGVyOiBMaXN0ZW5lckVycm9ySGFuZGxlciwgZXJyb3JUb05vdGlmeTogdW5rbm93biwgZXJyb3JJbmZvOiBMaXN0ZW5lckVycm9ySW5mbyk6IHZvaWQgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIC8vIFdlIGNhbm5vdCBsZXQgYW4gZXJyb3IgcmFpc2VkIGhlcmUgYmxvY2sgdGhlIGxpc3RlbmVyIHF1ZXVlLlxuICAgIC8vIFRoZSBlcnJvciByYWlzZWQgaGVyZSB3aWxsIGJlIHBpY2tlZCB1cCBieSBgd2luZG93Lm9uZXJyb3JgLCBgcHJvY2Vzcy5vbignZXJyb3InKWAgZXRjLi4uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcbiAgICB9LCAwKTtcbiAgfVxufTtcbi8qKlxuICogQHB1YmxpY1xuICovXG5cblxuZXhwb3J0IGNvbnN0IGFkZExpc3RlbmVyID0gKChPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pIGFzIHVua25vd24pIGFzIFR5cGVkQWRkTGlzdGVuZXI8dW5rbm93bj4pO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSAoKE9iamVjdC5hc3NpZ24oY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiByZW1vdmVMaXN0ZW5lclxufSkgYXMgdW5rbm93bikgYXMgVHlwZWRSZW1vdmVMaXN0ZW5lcjx1bmtub3duPik7XG5cbmNvbnN0IGRlZmF1bHRFcnJvckhhbmRsZXI6IExpc3RlbmVyRXJyb3JIYW5kbGVyID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUgPSA8U3RhdGVUeXBlID0gdW5rbm93biwgRGlzcGF0Y2hUeXBlIGV4dGVuZHMgRGlzcGF0Y2g8QWN0aW9uPiA9IFRodW5rRGlzcGF0Y2g8U3RhdGVUeXBlLCB1bmtub3duLCBVbmtub3duQWN0aW9uPiwgRXh0cmFBcmd1bWVudCA9IHVua25vd24+KG1pZGRsZXdhcmVPcHRpb25zOiBDcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmVPcHRpb25zPEV4dHJhQXJndW1lbnQ+ID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSBuZXcgTWFwPHN0cmluZywgTGlzdGVuZXJFbnRyeT4oKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgJ29uRXJyb3InKTtcblxuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeTogTGlzdGVuZXJFbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5IS5pZCk7XG5cbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnM/OiBVbnN1YnNjcmliZUxpc3RlbmVyT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcblxuICAgICAgaWYgKGNhbmNlbE9wdGlvbnM/LmNhbmNlbEFjdGl2ZSkge1xuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAoKChvcHRpb25zOiBGYWxsYmFja0FkZExpc3RlbmVyT3B0aW9ucykgPT4ge1xuICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSksIGV4aXN0aW5nRW50cnkgPT4gZXhpc3RpbmdFbnRyeS5lZmZlY3QgPT09IG9wdGlvbnMuZWZmZWN0KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeSgob3B0aW9ucyBhcyBhbnkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9KSBhcyBBZGRMaXN0ZW5lck92ZXJsb2Fkczxhbnk+KTtcbiAgT2JqZWN0LmFzc2lnbihzdGFydExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RhcnRMaXN0ZW5pbmdcbiAgfSk7XG5cbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zOiBGYWxsYmFja0FkZExpc3RlbmVyT3B0aW9ucyAmIFVuc3Vic2NyaWJlTGlzdGVuZXJPcHRpb25zKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgZW50cnkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBlbnRyeS50eXBlID09PSB0eXBlIDogZW50cnkucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgICByZXR1cm4gbWF0Y2hQcmVkaWNhdGVPclR5cGUgJiYgZW50cnkuZWZmZWN0ID09PSBlZmZlY3Q7XG4gICAgfSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcblxuICBjb25zdCBub3RpZnlMaXN0ZW5lciA9IGFzeW5jIChlbnRyeTogTGlzdGVuZXJFbnRyeTx1bmtub3duLCBEaXNwYXRjaDxVbmtub3duQWN0aW9uPj4sIGFjdGlvbjogdW5rbm93biwgYXBpOiBNaWRkbGV3YXJlQVBJLCBnZXRPcmlnaW5hbFN0YXRlOiAoKSA9PiBTdGF0ZVR5cGUpID0+IHtcbiAgICBjb25zdCBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybigoc3RhcnRMaXN0ZW5pbmcgYXMgQWRkTGlzdGVuZXJPdmVybG9hZHM8YW55PiksIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChhY3Rpb24sIC8vIFVzZSBhc3NpZ24oKSByYXRoZXIgdGhhbiAuLi4gdG8gYXZvaWQgZXh0cmEgaGVscGVyIGZ1bmN0aW9ucyBhZGRlZCB0byBidW5kbGVcbiAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgIGdldE9yaWdpbmFsU3RhdGUsXG4gICAgICAgIGNvbmRpdGlvbjogKHByZWRpY2F0ZTogQW55TGlzdGVuZXJQcmVkaWNhdGU8YW55PiwgdGltZW91dD86IG51bWJlcikgPT4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbiksXG4gICAgICAgIHRha2UsXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZTxhbnk+KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGZvcms6IGNyZWF0ZUZvcmsoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsIGF1dG9Kb2luUHJvbWlzZXMpLFxuICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXG4gICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIsIF8sIHNldCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IGludGVybmFsVGFza0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgdmFsaWRhdGVBY3RpdmUoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICB9KSkpO1xuICAgIH0gY2F0Y2ggKGxpc3RlbmVyRXJyb3IpIHtcbiAgICAgIGlmICghKGxpc3RlbmVyRXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcbiAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvciwge1xuICAgICAgICAgIHJhaXNlZEJ5OiAnZWZmZWN0J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXV0b0pvaW5Qcm9taXNlcyk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ29tcGxldGVkKTsgLy8gTm90aWZ5IHRoYXQgdGhlIHRhc2sgaGFzIGNvbXBsZXRlZFxuXG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XG5cbiAgY29uc3QgbWlkZGxld2FyZTogTGlzdGVuZXJNaWRkbGV3YXJlPFN0YXRlVHlwZSwgRGlzcGF0Y2hUeXBlLCBFeHRyYUFyZ3VtZW50PiA9IGFwaSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XG4gICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbm90aWZ5IGxpc3RlbmVycyBmb3IgYWN0aW9uIG9iamVjdHNcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFkZExpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGFydExpc3RlbmluZygoYWN0aW9uLnBheWxvYWQgYXMgYW55KSk7XG4gICAgfVxuXG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9IC8vIE5lZWQgdG8gZ2V0IHRoaXMgc3RhdGUgX2JlZm9yZV8gdGhlIHJlZHVjZXIgcHJvY2Vzc2VzIHRoZSBhY3Rpb25cblxuXG4gICAgbGV0IG9yaWdpbmFsU3RhdGU6IFN0YXRlVHlwZSB8IHR5cGVvZiBJTlRFUk5BTF9OSUxfVE9LRU4gPSBhcGkuZ2V0U3RhdGUoKTsgLy8gYGdldE9yaWdpbmFsU3RhdGVgIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgtdG9vbGtpdC9kaXNjdXNzaW9ucy8xNjQ4I2Rpc2N1c3Npb25jb21tZW50LTE5MzI4MjBcblxuICAgIGNvbnN0IGdldE9yaWdpbmFsU3RhdGUgPSAoKTogU3RhdGVUeXBlID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAob3JpZ2luYWxTdGF0ZSBhcyBTdGF0ZVR5cGUpO1xuICAgIH07XG5cbiAgICBsZXQgcmVzdWx0OiB1bmtub3duO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFjdHVhbGx5IGZvcndhcmQgdGhlIGFjdGlvbiB0byB0aGUgcmVkdWNlciBiZWZvcmUgd2UgaGFuZGxlIGxpc3RlbmVyc1xuICAgICAgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuXG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7IC8vIFdvcmsgYXJvdW5kIEVTQnVpbGQrVFMgdHJhbnNwaWxhdGlvbiBpc3N1ZVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdGVuZXJFbnRyaWVzKSB7XG4gICAgICAgICAgbGV0IHJ1bkxpc3RlbmVyID0gZmFsc2U7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6ICdwcmVkaWNhdGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJlbW92ZSBgb3JpZ2luYWxTdGF0ZWAgc3RvcmUgZnJvbSB0aGlzIHNjb3BlLlxuICAgICAgb3JpZ2luYWxTdGF0ZSA9IElOVEVSTkFMX05JTF9UT0tFTjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiAoe1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfSBhcyBMaXN0ZW5lck1pZGRsZXdhcmVJbnN0YW5jZTxTdGF0ZVR5cGUsIERpc3BhdGNoVHlwZSwgRXh0cmFBcmd1bWVudD4pO1xufTsiLCJpbXBvcnQgdHlwZSB7IFNlcmlhbGl6ZWRFcnJvciB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuY29uc3QgdGFzayA9ICd0YXNrJztcbmNvbnN0IGxpc3RlbmVyID0gJ2xpc3RlbmVyJztcbmNvbnN0IGNvbXBsZXRlZCA9ICdjb21wbGV0ZWQnO1xuY29uc3QgY2FuY2VsbGVkID0gJ2NhbmNlbGxlZCc7XG4vKiBUYXNrQWJvcnRFcnJvciBlcnJvciBjb2RlcyAgKi9cblxuZXhwb3J0IGNvbnN0IHRhc2tDYW5jZWxsZWQgPSAoYHRhc2stJHtjYW5jZWxsZWR9YCBhcyBjb25zdCk7XG5leHBvcnQgY29uc3QgdGFza0NvbXBsZXRlZCA9IChgdGFzay0ke2NvbXBsZXRlZH1gIGFzIGNvbnN0KTtcbmV4cG9ydCBjb25zdCBsaXN0ZW5lckNhbmNlbGxlZCA9IChgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YCBhcyBjb25zdCk7XG5leHBvcnQgY29uc3QgbGlzdGVuZXJDb21wbGV0ZWQgPSAoYCR7bGlzdGVuZXJ9LSR7Y29tcGxldGVkfWAgYXMgY29uc3QpO1xuZXhwb3J0IGNsYXNzIFRhc2tBYm9ydEVycm9yIGltcGxlbWVudHMgU2VyaWFsaXplZEVycm9yIHtcbiAgbmFtZSA9ICdUYXNrQWJvcnRFcnJvcic7XG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuXG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IEFib3J0U2lnbmFsV2l0aFJlYXNvbiB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IGNvbnN0IGFzc2VydEZ1bmN0aW9uOiAoZnVuYzogdW5rbm93biwgZXhwZWN0ZWQ6IHN0cmluZykgPT4gYXNzZXJ0cyBmdW5jIGlzICguLi5hcmdzOiB1bmtub3duW10pID0+IHVua25vd24gPSAoZnVuYzogdW5rbm93biwgZXhwZWN0ZWQ6IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuZXhwb3J0IGNvbnN0IGNhdGNoUmVqZWN0aW9uID0gPFQsPihwcm9taXNlOiBQcm9taXNlPFQ+LCBvbkVycm9yID0gbm9vcCk6IFByb21pc2U8VD4gPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG5leHBvcnQgY29uc3QgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbDogQWJvcnRTaWduYWwsIGNhbGxiYWNrOiAoZXZ0OiBFdmVudCkgPT4gdm9pZCkgPT4ge1xuICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQ2FsbHMgYGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pYCBhbmQgcGF0Y2hlcyBgc2lnbmFsLnJlYXNvbmAuXG4gKiBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgYHNpZ25hbC5yZWFzb25gIGlzIGF2YWlsYWJsZSBpbiBGRiBjaHJvbWUsIGVkZ2Ugbm9kZSAxNyBhbmQgZGVuby5cbiAqIEBwYXJhbSBhYm9ydENvbnRyb2xsZXJcbiAqIEBwYXJhbSByZWFzb25cbiAqIEByZXR1cm5zXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbC9yZWFzb25cbiAqL1xuXG5leHBvcnQgY29uc3QgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiA9IDxULD4oYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsIHJlYXNvbjogVCk6IHZvaWQgPT4ge1xuICB0eXBlIENvbnN1bWVyPFQ+ID0gKHZhbDogVCkgPT4gdm9pZDtcbiAgY29uc3Qgc2lnbmFsID0gKGFib3J0Q29udHJvbGxlci5zaWduYWwgYXMgQWJvcnRTaWduYWxXaXRoUmVhc29uPFQ+KTtcblxuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gUGF0Y2ggYHJlYXNvbmAgaWYgbmVjZXNzYXJ5LlxuICAvLyAtIFdlIHVzZSBkZWZpbmVQcm9wZXJ0eSBoZXJlIGJlY2F1c2UgcmVhc29uIGlzIGEgZ2V0dGVyIG9mIGBBYm9ydFNpZ25hbC5fX3Byb3RvX19gLlxuICAvLyAtIFdlIG5lZWQgdG8gcGF0Y2ggJ3JlYXNvbicgYmVmb3JlIGNhbGxpbmcgYC5hYm9ydCgpYCBiZWNhdXNlIGxpc3RlbmVycyB0byB0aGUgJ2Fib3J0J1xuICAvLyBldmVudCBhcmUgYXJlIG5vdGlmaWVkIGltbWVkaWF0ZWx5LlxuXG5cbiAgaWYgKCEoJ3JlYXNvbicgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsICdyZWFzb24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICA7XG4gIChhYm9ydENvbnRyb2xsZXIuYWJvcnQgYXMgQ29uc3VtZXI8dHlwZW9mIHJlYXNvbj4pKHJlYXNvbik7XG59OyIsImltcG9ydCB7IFRhc2tBYm9ydEVycm9yIH0gZnJvbSAnLi9leGNlcHRpb25zJztcbmltcG9ydCB0eXBlIHsgQWJvcnRTaWduYWxXaXRoUmVhc29uLCBUYXNrUmVzdWx0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBhZGRBYm9ydFNpZ25hbExpc3RlbmVyLCBjYXRjaFJlamVjdGlvbiwgbm9vcCB9IGZyb20gJy4vdXRpbHMnO1xuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHJhaXNlcyB7QGxpbmsgVGFza0Fib3J0RXJyb3J9IGlmIHRoZSB0YXNrIHRpZWQgdG8gdGhlIGlucHV0IGBzaWduYWxgIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAqIEBwYXJhbSBzaWduYWxcbiAqIEBwYXJhbSByZWFzb25cbiAqIEBzZWUge1Rhc2tBYm9ydEVycm9yfVxuICovXG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUFjdGl2ZSA9IChzaWduYWw6IEFib3J0U2lnbmFsKTogdm9pZCA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSAoc2lnbmFsIGFzIEFib3J0U2lnbmFsV2l0aFJlYXNvbjxzdHJpbmc+KTtcbiAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3IocmVhc29uKTtcbiAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgcmFjZSBiZXR3ZWVuIHRoZSBwcm9taXNlKHMpIGFuZCB0aGUgQWJvcnRTaWduYWxcbiAqIFRoaXMgYXZvaWRzIGBQcm9taXNlLnJhY2UoKWAtcmVsYXRlZCBtZW1vcnkgbGVha3M6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzE3NDY5I2lzc3VlY29tbWVudC0zNDk3OTQ5MDlcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFjZVdpdGhTaWduYWw8VD4oc2lnbmFsOiBBYm9ydFNpZ25hbFdpdGhSZWFzb248c3RyaW5nPiwgcHJvbWlzZTogUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICBsZXQgY2xlYW51cCA9IG5vb3A7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgbm90aWZ5UmVqZWN0aW9uID0gKCkgPT4gcmVqZWN0KG5ldyBUYXNrQWJvcnRFcnJvcihzaWduYWwucmVhc29uKSk7XG5cbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFudXAgPSBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHNpZ25hbCwgbm90aWZ5UmVqZWN0aW9uKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4gY2xlYW51cCgpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIC8vIGFmdGVyIHRoaXMgcG9pbnQsIHJlcGxhY2UgYGNsZWFudXBgIHdpdGggYSBub29wLCBzbyB0aGVyZSBpcyBubyByZWZlcmVuY2UgdG8gYHNpZ25hbGAgYW55IG1vcmVcbiAgICBjbGVhbnVwID0gbm9vcDtcbiAgfSk7XG59XG4vKipcbiAqIFJ1bnMgYSB0YXNrIGFuZCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB7QGxpbmsgVGFza1Jlc3VsdH0uXG4gKiBTZWNvbmQgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgYGNsZWFuVXBgIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJ1bnMgYWZ0ZXIgdGFzay5cbiAqXG4gKiAqKk5vdGU6KiogYHJ1blRhc2tgIHJ1bnMgdGhlIGV4ZWN1dG9yIGluIHRoZSBuZXh0IG1pY3JvdGFzay5cbiAqIEByZXR1cm5zXG4gKi9cblxuZXhwb3J0IGNvbnN0IHJ1blRhc2sgPSBhc3luYyA8VCw+KHRhc2s6ICgpID0+IFByb21pc2U8VD4sIGNsZWFuVXA/OiAoKSA9PiB2b2lkKTogUHJvbWlzZTxUYXNrUmVzdWx0PFQ+PiA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0YXNrKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ29rJyxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyAnY2FuY2VsbGVkJyA6ICdyZWplY3RlZCcsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYW5VcD8uKCk7XG4gIH1cbn07XG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IGBBYm9ydFNpZ25hbGAgYW5kIGEgcHJvbWlzZSByZXR1cm5zIGFub3RoZXIgcHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiBhcyBzb29uIHRoZSBpbnB1dCBwcm9taXNlIGlzIHByb3ZpZGVkIG9yIHJlamVjdHMgYXMgc29vbiBhc1xuICogYEFib3J0U2lnbmFsLmFib3J0YCBpcyBgdHJ1ZWAuXG4gKiBAcGFyYW0gc2lnbmFsXG4gKiBAcmV0dXJuc1xuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYXVzZSA9IDxULD4oc2lnbmFsOiBBYm9ydFNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2U6IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+ID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKG91dHB1dCA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gIH07XG59O1xuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCBgQWJvcnRTaWduYWxgIGFuZCBgdGltZW91dE1zYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiBhZnRlciBgdGltZW91dE1zYCBvciByZWplY3RzIGFzIHNvb24gYXMgYEFib3J0U2lnbmFsLmFib3J0YCBpcyBgdHJ1ZWAuXG4gKiBAcGFyYW0gc2lnbmFsXG4gKiBAcmV0dXJuc1xuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWxheSA9IChzaWduYWw6IEFib3J0U2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2U8dm9pZD4oc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHJldHVybiBwYXVzZShuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTsiLCJpbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmUsIERpc3BhdGNoIGFzIFJlZHV4RGlzcGF0Y2gsIFVua25vd25BY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIH0gZnJvbSAnLi4vY3JlYXRlQWN0aW9uJztcbmltcG9ydCB7IGlzQWxsT2YgfSBmcm9tICcuLi9tYXRjaGVycyc7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICcuLi9uYW5vaWQnO1xuaW1wb3J0IHsgZW1wbGFjZSwgZmluZCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgV2l0aE1pZGRsZXdhcmUsIEFkZE1pZGRsZXdhcmUsIE1pZGRsZXdhcmVFbnRyeSwgRHluYW1pY01pZGRsZXdhcmUsIER5bmFtaWNNaWRkbGV3YXJlSW5zdGFuY2UgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gPFN0YXRlID0gYW55LCBEaXNwYXRjaCBleHRlbmRzIFJlZHV4RGlzcGF0Y2g8VW5rbm93bkFjdGlvbj4gPSBSZWR1eERpc3BhdGNoPFVua25vd25BY3Rpb24+PihtaWRkbGV3YXJlOiBNaWRkbGV3YXJlPGFueSwgU3RhdGUsIERpc3BhdGNoPik6IE1pZGRsZXdhcmVFbnRyeTxTdGF0ZSwgRGlzcGF0Y2g+ID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogbmV3IE1hcCgpXG59KTtcblxuY29uc3QgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkOiBzdHJpbmcpID0+IChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyB7XG4gIG1ldGE6IHtcbiAgICBpbnN0YW5jZUlkOiBzdHJpbmc7XG4gIH07XG59ID0+IGFjdGlvbj8ubWV0YT8uaW5zdGFuY2VJZCA9PT0gaW5zdGFuY2VJZDtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlID0gPFN0YXRlID0gYW55LCBEaXNwYXRjaCBleHRlbmRzIFJlZHV4RGlzcGF0Y2g8VW5rbm93bkFjdGlvbj4gPSBSZWR1eERpc3BhdGNoPFVua25vd25BY3Rpb24+PigpOiBEeW5hbWljTWlkZGxld2FyZUluc3RhbmNlPFN0YXRlLCBEaXNwYXRjaD4gPT4ge1xuICBjb25zdCBpbnN0YW5jZUlkID0gbmFub2lkKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVNYXAgPSBuZXcgTWFwPHN0cmluZywgTWlkZGxld2FyZUVudHJ5PFN0YXRlLCBEaXNwYXRjaD4+KCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gKE9iamVjdC5hc3NpZ24oY3JlYXRlQWN0aW9uKCdkeW5hbWljTWlkZGxld2FyZS9hZGQnLCAoLi4ubWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8YW55LCBTdGF0ZSwgRGlzcGF0Y2g+W10pID0+ICh7XG4gICAgcGF5bG9hZDogbWlkZGxld2FyZXMsXG4gICAgbWV0YToge1xuICAgICAgaW5zdGFuY2VJZFxuICAgIH1cbiAgfSkpLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB3aXRoTWlkZGxld2FyZVxuICB9KSBhcyBXaXRoTWlkZGxld2FyZTxTdGF0ZSwgRGlzcGF0Y2g+KTtcbiAgY29uc3QgYWRkTWlkZGxld2FyZSA9IChPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8YW55LCBTdGF0ZSwgRGlzcGF0Y2g+W10pIHtcbiAgICBtaWRkbGV3YXJlcy5mb3JFYWNoKG1pZGRsZXdhcmUgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLCBlbnRyeSA9PiBlbnRyeS5taWRkbGV3YXJlID09PSBtaWRkbGV3YXJlKTtcblxuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICBlbnRyeSA9IGNyZWF0ZU1pZGRsZXdhcmVFbnRyeShtaWRkbGV3YXJlKTtcbiAgICAgIH1cblxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KSBhcyBBZGRNaWRkbGV3YXJlPFN0YXRlLCBEaXNwYXRjaD4pO1xuXG4gIGNvbnN0IGdldEZpbmFsTWlkZGxld2FyZTogTWlkZGxld2FyZTx7fSwgU3RhdGUsIERpc3BhdGNoPiA9IGFwaSA9PiB7XG4gICAgY29uc3QgYXBwbGllZE1pZGRsZXdhcmUgPSBBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLm1hcChlbnRyeSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UoLi4uYXBwbGllZE1pZGRsZXdhcmUpO1xuICB9O1xuXG4gIGNvbnN0IGlzV2l0aE1pZGRsZXdhcmUgPSBpc0FsbE9mKHdpdGhNaWRkbGV3YXJlLCBtYXRjaEluc3RhbmNlKGluc3RhbmNlSWQpKTtcblxuICBjb25zdCBtaWRkbGV3YXJlOiBEeW5hbWljTWlkZGxld2FyZTxTdGF0ZSwgRGlzcGF0Y2g+ID0gYXBpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldEZpbmFsTWlkZGxld2FyZShhcGkpKG5leHQpKGFjdGlvbik7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIGFkZE1pZGRsZXdhcmUsXG4gICAgd2l0aE1pZGRsZXdhcmUsXG4gICAgaW5zdGFuY2VJZFxuICB9O1xufTsiLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHsgVW5rbm93bkFjdGlvbiwgUmVkdWNlciwgU3RhdGVGcm9tUmVkdWNlcnNNYXBPYmplY3QgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICcuL25hbm9pZCc7XG5pbXBvcnQgdHlwZSB7IElkLCBOb25VbmRlZmluZWQsIFRhaWwsIFVuaW9uVG9JbnRlcnNlY3Rpb24sIFdpdGhPcHRpb25hbFByb3AgfSBmcm9tICcuL3RzSGVscGVycyc7XG5pbXBvcnQgeyBlbXBsYWNlIH0gZnJvbSAnLi91dGlscyc7XG50eXBlIFNsaWNlTGlrZTxSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZywgU3RhdGU+ID0ge1xuICByZWR1Y2VyUGF0aDogUmVkdWNlclBhdGg7XG4gIHJlZHVjZXI6IFJlZHVjZXI8U3RhdGU+O1xufTtcbnR5cGUgQW55U2xpY2VMaWtlID0gU2xpY2VMaWtlPHN0cmluZywgYW55PjtcbnR5cGUgU2xpY2VMaWtlUmVkdWNlclBhdGg8QSBleHRlbmRzIEFueVNsaWNlTGlrZT4gPSBBIGV4dGVuZHMgU2xpY2VMaWtlPGluZmVyIFJlZHVjZXJQYXRoLCBhbnk+ID8gUmVkdWNlclBhdGggOiBuZXZlcjtcbnR5cGUgU2xpY2VMaWtlU3RhdGU8QSBleHRlbmRzIEFueVNsaWNlTGlrZT4gPSBBIGV4dGVuZHMgU2xpY2VMaWtlPGFueSwgaW5mZXIgU3RhdGU+ID8gU3RhdGUgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFdpdGhTbGljZTxBIGV4dGVuZHMgQW55U2xpY2VMaWtlPiA9IHsgW1BhdGggaW4gU2xpY2VMaWtlUmVkdWNlclBhdGg8QT5dOiBTbGljZUxpa2VTdGF0ZTxBPiB9O1xudHlwZSBSZWR1Y2VyTWFwID0gUmVjb3JkPHN0cmluZywgUmVkdWNlcj47XG50eXBlIEV4aXN0aW5nU2xpY2VMaWtlPERlY2xhcmVkU3RhdGU+ID0geyBbUmVkdWNlclBhdGggaW4ga2V5b2YgRGVjbGFyZWRTdGF0ZV06IFNsaWNlTGlrZTxSZWR1Y2VyUGF0aCAmIHN0cmluZywgTm9uVW5kZWZpbmVkPERlY2xhcmVkU3RhdGVbUmVkdWNlclBhdGhdPj4gfVtrZXlvZiBEZWNsYXJlZFN0YXRlXTtcbmV4cG9ydCB0eXBlIEluamVjdENvbmZpZyA9IHtcbiAgLyoqXG4gICAqIEFsbG93IHJlcGxhY2luZyByZWR1Y2VyIHdpdGggYSBkaWZmZXJlbnQgcmVmZXJlbmNlLiBOb3JtYWxseSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgYSBkaWZmZXJlbnQgcmVkdWNlciBpbnN0YW5jZSB0byB0aGUgb25lIGFscmVhZHkgaW5qZWN0ZWQgaXMgdXNlZC5cbiAgICovXG4gIG92ZXJyaWRlRXhpc3Rpbmc/OiBib29sZWFuO1xufTtcbi8qKlxuICogQSByZWR1Y2VyIHRoYXQgYWxsb3dzIGZvciBzbGljZXMvcmVkdWNlcnMgdG8gYmUgaW5qZWN0ZWQgYWZ0ZXIgaW5pdGlhbGlzYXRpb24uXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBDb21iaW5lZFNsaWNlUmVkdWNlcjxJbml0aWFsU3RhdGUsIERlY2xhcmVkU3RhdGUgPSBJbml0aWFsU3RhdGU+IGV4dGVuZHMgUmVkdWNlcjxEZWNsYXJlZFN0YXRlLCBVbmtub3duQWN0aW9uLCBQYXJ0aWFsPERlY2xhcmVkU3RhdGU+PiB7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgdHlwZSBmb3Igc2xpY2VzIHRoYXQgd2lsbCBiZSBpbmplY3RlZCBsYXppbHkuXG4gICAqXG4gICAqIE9uZSB3YXkgdG8gZG8gdGhpcyB3b3VsZCBiZSB3aXRoIGludGVyZmFjZSBtZXJnaW5nOlxuICAgKiBgYGB0c1xuICAgKlxuICAgKiBleHBvcnQgaW50ZXJmYWNlIExhenlMb2FkZWRTbGljZXMge31cbiAgICpcbiAgICogZXhwb3J0IGNvbnN0IHJvb3RSZWR1Y2VyID0gY29tYmluZVNsaWNlcyhzdHJpbmdTbGljZSkud2l0aExhenlMb2FkZWRTbGljZXM8TGF6eUxvYWRlZFNsaWNlcz4oKTtcbiAgICpcbiAgICogLy8gZWxzZXdoZXJlXG4gICAqXG4gICAqIGRlY2xhcmUgbW9kdWxlICcuL3JlZHVjZXInIHtcbiAgICogICBleHBvcnQgaW50ZXJmYWNlIExhenlMb2FkZWRTbGljZXMgZXh0ZW5kcyBXaXRoU2xpY2U8dHlwZW9mIGJvb2xlYW5TbGljZT4ge31cbiAgICogfVxuICAgKlxuICAgKiBjb25zdCB3aXRoQm9vbGVhbiA9IHJvb3RSZWR1Y2VyLmluamVjdChib29sZWFuU2xpY2UpO1xuICAgKlxuICAgKiAvLyBlbHNld2hlcmUgYWdhaW5cbiAgICpcbiAgICogZGVjbGFyZSBtb2R1bGUgJy4vcmVkdWNlcicge1xuICAgKiAgIGV4cG9ydCBpbnRlcmZhY2UgTGF6eUxvYWRlZFNsaWNlcyB7XG4gICAqICAgICBjdXN0b21OYW1lOiBDdXN0b21TdGF0ZVxuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiBjb25zdCB3aXRoQ3VzdG9tID0gcm9vdFJlZHVjZXIuaW5qZWN0KHsgcmVkdWNlclBhdGg6IFwiY3VzdG9tTmFtZVwiLCByZWR1Y2VyOiBjdXN0b21TbGljZS5yZWR1Y2VyIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgd2l0aExhenlMb2FkZWRTbGljZXM8TGF6eSA9IHt9PigpOiBDb21iaW5lZFNsaWNlUmVkdWNlcjxJbml0aWFsU3RhdGUsIElkPERlY2xhcmVkU3RhdGUgJiBQYXJ0aWFsPExhenk+Pj47XG4gIC8qKlxuICAgKiBJbmplY3QgYSBzbGljZS5cbiAgICpcbiAgICogQWNjZXB0cyBhbiBpbmRpdmlkdWFsIHNsaWNlLCBSVEtRIEFQSSBpbnN0YW5jZSwgb3IgYSBcInNsaWNlLWxpa2VcIiB7IHJlZHVjZXJQYXRoLCByZWR1Y2VyIH0gb2JqZWN0LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKVxuICAgKiByb290UmVkdWNlci5pbmplY3QoYmFzZUFwaSlcbiAgICogcm9vdFJlZHVjZXIuaW5qZWN0KHsgcmVkdWNlclBhdGg6ICdib29sZWFuJyBhcyBjb25zdCwgcmVkdWNlcjogbmV3UmVkdWNlciB9LCB7IG92ZXJyaWRlRXhpc3Rpbmc6IHRydWUgfSlcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG4gIGluamVjdDxTbCBleHRlbmRzIElkPEV4aXN0aW5nU2xpY2VMaWtlPERlY2xhcmVkU3RhdGU+Pj4oc2xpY2U6IFNsLCBjb25maWc/OiBJbmplY3RDb25maWcpOiBDb21iaW5lZFNsaWNlUmVkdWNlcjxJbml0aWFsU3RhdGUsIElkPERlY2xhcmVkU3RhdGUgJiBXaXRoU2xpY2U8U2w+Pj47XG4gIC8qKlxuICAgKiBJbmplY3QgYSBzbGljZS5cbiAgICpcbiAgICogQWNjZXB0cyBhbiBpbmRpdmlkdWFsIHNsaWNlLCBSVEtRIEFQSSBpbnN0YW5jZSwgb3IgYSBcInNsaWNlLWxpa2VcIiB7IHJlZHVjZXJQYXRoLCByZWR1Y2VyIH0gb2JqZWN0LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKVxuICAgKiByb290UmVkdWNlci5pbmplY3QoYmFzZUFwaSlcbiAgICogcm9vdFJlZHVjZXIuaW5qZWN0KHsgcmVkdWNlclBhdGg6ICdib29sZWFuJyBhcyBjb25zdCwgcmVkdWNlcjogbmV3UmVkdWNlciB9LCB7IG92ZXJyaWRlRXhpc3Rpbmc6IHRydWUgfSlcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG4gIGluamVjdDxSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZywgU3RhdGU+KHNsaWNlOiBTbGljZUxpa2U8UmVkdWNlclBhdGgsIFN0YXRlICYgKFJlZHVjZXJQYXRoIGV4dGVuZHMga2V5b2YgRGVjbGFyZWRTdGF0ZSA/IG5ldmVyIDogU3RhdGUpPiwgY29uZmlnPzogSW5qZWN0Q29uZmlnKTogQ29tYmluZWRTbGljZVJlZHVjZXI8SW5pdGlhbFN0YXRlLCBJZDxEZWNsYXJlZFN0YXRlICYgV2l0aFNsaWNlPFNsaWNlTGlrZTxSZWR1Y2VyUGF0aCwgU3RhdGU+Pj4+O1xuICAvKipcbiAgICogQ3JlYXRlIGEgc2VsZWN0b3IgdGhhdCBndWFyYW50ZWVzIHRoYXQgdGhlIHNsaWNlcyBpbmplY3RlZCB3aWxsIGhhdmUgYSBkZWZpbmVkIHZhbHVlIHdoZW4gc2VsZWN0b3IgaXMgcnVuLlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzZWxlY3RCb29sZWFuV2l0aG91dEluamVjdGlvbiA9IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5ib29sZWFuO1xuICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBePyBib29sZWFuIHwgdW5kZWZpbmVkXG4gICAqXG4gICAqIGNvbnN0IHNlbGVjdEJvb2xlYW4gPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKS5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICogICAvLyBpZiBhY3Rpb24gaGFzbid0IGJlZW4gZGlzcGF0Y2hlZCBzaW5jZSBzbGljZSB3YXMgaW5qZWN0ZWQsIHRoaXMgd291bGQgdXN1YWxseSBiZSB1bmRlZmluZWRcbiAgICogICAvLyBob3dldmVyIHNlbGVjdG9yKCkgdXNlcyBhIFByb3h5IGFyb3VuZCB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGVuc3VyZSB0aGF0IGl0IGV2YWx1YXRlcyB0byB0aGUgaW5pdGlhbCBzdGF0ZSBpbnN0ZWFkLCBpZiB1bmRlZmluZWRcbiAgICogICByZXR1cm4gc3RhdGUuYm9vbGVhbjtcbiAgICogICAvLyAgICAgICAgICAgXj8gYm9vbGVhblxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogSWYgdGhlIHJlZHVjZXIgaXMgbmVzdGVkIGluc2lkZSB0aGUgcm9vdCBzdGF0ZSwgYSBzZWxlY3RTdGF0ZSBjYWxsYmFjayBjYW4gYmUgcGFzc2VkIHRvIHJldHJpZXZlIHRoZSByZWR1Y2VyJ3Mgc3RhdGUuXG4gICAqXG4gICAqIGBgYHRzXG4gICAqXG4gICAqIGV4cG9ydCBpbnRlcmZhY2UgTGF6eUxvYWRlZFNsaWNlcyB7fTtcbiAgICpcbiAgICogZXhwb3J0IGNvbnN0IGlubmVyUmVkdWNlciA9IGNvbWJpbmVTbGljZXMoc3RyaW5nU2xpY2UpLndpdGhMYXp5TG9hZGVkU2xpY2VzPExhenlMb2FkZWRTbGljZXM+KCk7XG4gICAqXG4gICAqIGV4cG9ydCBjb25zdCByb290UmVkdWNlciA9IGNvbWJpbmVTbGljZXMoeyBpbm5lcjogaW5uZXJSZWR1Y2VyIH0pO1xuICAgKlxuICAgKiBleHBvcnQgdHlwZSBSb290U3RhdGUgPSBSZXR1cm5UeXBlPHR5cGVvZiByb290UmVkdWNlcj47XG4gICAqXG4gICAqIC8vIGVsc2V3aGVyZVxuICAgKlxuICAgKiBkZWNsYXJlIG1vZHVsZSBcIi4vcmVkdWNlci50c1wiIHtcbiAgICogIGV4cG9ydCBpbnRlcmZhY2UgTGF6eUxvYWRlZFNsaWNlcyBleHRlbmRzIFdpdGhTbGljZTx0eXBlb2YgYm9vbGVhblNsaWNlPiB7fVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHdpdGhCb29sID0gaW5uZXJSZWR1Y2VyLmluamVjdChib29sZWFuU2xpY2UpO1xuICAgKlxuICAgKiBjb25zdCBzZWxlY3RCb29sZWFuID0gd2l0aEJvb2wuc2VsZWN0b3IoXG4gICAqICAgKHN0YXRlKSA9PiBzdGF0ZS5ib29sZWFuLFxuICAgKiAgIChyb290U3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuaW5uZXJcbiAgICogKTtcbiAgICogLy8gICAgbm93IGV4cGVjdHMgdG8gYmUgcGFzc2VkIFJvb3RTdGF0ZSBpbnN0ZWFkIG9mIGlubmVyUmVkdWNlciBzdGF0ZVxuICAgKlxuICAgKiBgYGBcbiAgICpcbiAgICogVmFsdWUgcGFzc2VkIHRvIHNlbGVjdG9yRm4gd2lsbCBiZSBhIFByb3h5IC0gdXNlIHNlbGVjdG9yLm9yaWdpbmFsKHByb3h5KSB0byBnZXQgb3JpZ2luYWwgc3RhdGUgdmFsdWUgKHVzZWZ1bCBmb3IgZGVidWdnaW5nKVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBpbmplY3RlZFJlZHVjZXIgPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKTtcbiAgICogY29uc3Qgc2VsZWN0Qm9vbGVhbiA9IGluamVjdGVkUmVkdWNlci5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhpbmplY3RlZFJlZHVjZXIuc2VsZWN0b3Iub3JpZ2luYWwoc3RhdGUpLmJvb2xlYW4pIC8vIHBvc3NpYmx5IHVuZGVmaW5lZFxuICAgKiAgIHJldHVybiBzdGF0ZS5ib29sZWFuXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cblxuICBzZWxlY3Rvcjoge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNlbGVjdG9yIHRoYXQgZ3VhcmFudGVlcyB0aGF0IHRoZSBzbGljZXMgaW5qZWN0ZWQgd2lsbCBoYXZlIGEgZGVmaW5lZCB2YWx1ZSB3aGVuIHNlbGVjdG9yIGlzIHJ1bi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3Qgc2VsZWN0Qm9vbGVhbldpdGhvdXRJbmplY3Rpb24gPSAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuYm9vbGVhbjtcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBePyBib29sZWFuIHwgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RCb29sZWFuID0gcm9vdFJlZHVjZXIuaW5qZWN0KGJvb2xlYW5TbGljZSkuc2VsZWN0b3IoKHN0YXRlKSA9PiB7XG4gICAgICogICAvLyBpZiBhY3Rpb24gaGFzbid0IGJlZW4gZGlzcGF0Y2hlZCBzaW5jZSBzbGljZSB3YXMgaW5qZWN0ZWQsIHRoaXMgd291bGQgdXN1YWxseSBiZSB1bmRlZmluZWRcbiAgICAgKiAgIC8vIGhvd2V2ZXIgc2VsZWN0b3IoKSB1c2VzIGEgUHJveHkgYXJvdW5kIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gZW5zdXJlIHRoYXQgaXQgZXZhbHVhdGVzIHRvIHRoZSBpbml0aWFsIHN0YXRlIGluc3RlYWQsIGlmIHVuZGVmaW5lZFxuICAgICAqICAgcmV0dXJuIHN0YXRlLmJvb2xlYW47XG4gICAgICogICAvLyAgICAgICAgICAgXj8gYm9vbGVhblxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBWYWx1ZSBwYXNzZWQgdG8gc2VsZWN0b3JGbiB3aWxsIGJlIGEgUHJveHkgLSB1c2Ugc2VsZWN0b3Iub3JpZ2luYWwocHJveHkpIHRvIGdldCBvcmlnaW5hbCBzdGF0ZSB2YWx1ZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGluamVjdGVkUmVkdWNlciA9IHJvb3RSZWR1Y2VyLmluamVjdChib29sZWFuU2xpY2UpO1xuICAgICAqIGNvbnN0IHNlbGVjdEJvb2xlYW4gPSBpbmplY3RlZFJlZHVjZXIuc2VsZWN0b3IoKHN0YXRlKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhpbmplY3RlZFJlZHVjZXIuc2VsZWN0b3Iub3JpZ2luYWwoc3RhdGUpLmJvb2xlYW4pIC8vIHVuZGVmaW5lZFxuICAgICAqICAgcmV0dXJuIHN0YXRlLmJvb2xlYW5cbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIDxTZWxlY3RvciBleHRlbmRzIChzdGF0ZTogRGVjbGFyZWRTdGF0ZSwgLi4uYXJnczogYW55W10pID0+IHVua25vd24+KHNlbGVjdG9yRm46IFNlbGVjdG9yKTogKHN0YXRlOiBXaXRoT3B0aW9uYWxQcm9wPFBhcmFtZXRlcnM8U2VsZWN0b3I+WzBdLCBFeGNsdWRlPGtleW9mIERlY2xhcmVkU3RhdGUsIGtleW9mIEluaXRpYWxTdGF0ZT4+LCAuLi5hcmdzOiBUYWlsPFBhcmFtZXRlcnM8U2VsZWN0b3I+PikgPT4gUmV0dXJuVHlwZTxTZWxlY3Rvcj47XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2VsZWN0b3IgdGhhdCBndWFyYW50ZWVzIHRoYXQgdGhlIHNsaWNlcyBpbmplY3RlZCB3aWxsIGhhdmUgYSBkZWZpbmVkIHZhbHVlIHdoZW4gc2VsZWN0b3IgaXMgcnVuLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBzZWxlY3RCb29sZWFuV2l0aG91dEluamVjdGlvbiA9IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5ib29sZWFuO1xuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4/IGJvb2xlYW4gfCB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIGNvbnN0IHNlbGVjdEJvb2xlYW4gPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKS5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICAgKiAgIC8vIGlmIGFjdGlvbiBoYXNuJ3QgYmVlbiBkaXNwYXRjaGVkIHNpbmNlIHNsaWNlIHdhcyBpbmplY3RlZCwgdGhpcyB3b3VsZCB1c3VhbGx5IGJlIHVuZGVmaW5lZFxuICAgICAqICAgLy8gaG93ZXZlciBzZWxlY3RvcigpIHVzZXMgYSBQcm94eSBhcm91bmQgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBlbnN1cmUgdGhhdCBpdCBldmFsdWF0ZXMgdG8gdGhlIGluaXRpYWwgc3RhdGUgaW5zdGVhZCwgaWYgdW5kZWZpbmVkXG4gICAgICogICByZXR1cm4gc3RhdGUuYm9vbGVhbjtcbiAgICAgKiAgIC8vICAgICAgICAgICBePyBib29sZWFuXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIHRoZSByZWR1Y2VyIGlzIG5lc3RlZCBpbnNpZGUgdGhlIHJvb3Qgc3RhdGUsIGEgc2VsZWN0U3RhdGUgY2FsbGJhY2sgY2FuIGJlIHBhc3NlZCB0byByZXRyaWV2ZSB0aGUgcmVkdWNlcidzIHN0YXRlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGludGVyZmFjZSBMYXp5TG9hZGVkU2xpY2VzIHt9O1xuICAgICAqXG4gICAgICogY29uc3QgaW5uZXJSZWR1Y2VyID0gY29tYmluZVNsaWNlcyhzdHJpbmdTbGljZSkud2l0aExhenlMb2FkZWRTbGljZXM8TGF6eUxvYWRlZFNsaWNlcz4oKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHJvb3RSZWR1Y2VyID0gY29tYmluZVNsaWNlcyh7IGlubmVyOiBpbm5lclJlZHVjZXIgfSk7XG4gICAgICpcbiAgICAgKiB0eXBlIFJvb3RTdGF0ZSA9IFJldHVyblR5cGU8dHlwZW9mIHJvb3RSZWR1Y2VyPjtcbiAgICAgKlxuICAgICAqIC8vIGVsc2V3aGVyZVxuICAgICAqXG4gICAgICogZGVjbGFyZSBtb2R1bGUgXCIuL3JlZHVjZXIudHNcIiB7XG4gICAgICogIGludGVyZmFjZSBMYXp5TG9hZGVkU2xpY2VzIGV4dGVuZHMgV2l0aFNsaWNlPHR5cGVvZiBib29sZWFuU2xpY2U+IHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3Qgd2l0aEJvb2wgPSBpbm5lclJlZHVjZXIuaW5qZWN0KGJvb2xlYW5TbGljZSk7XG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RCb29sZWFuID0gd2l0aEJvb2wuc2VsZWN0b3IoXG4gICAgICogICAoc3RhdGUpID0+IHN0YXRlLmJvb2xlYW4sXG4gICAgICogICAocm9vdFN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmlubmVyXG4gICAgICogKTtcbiAgICAgKiAvLyAgICBub3cgZXhwZWN0cyB0byBiZSBwYXNzZWQgUm9vdFN0YXRlIGluc3RlYWQgb2YgaW5uZXJSZWR1Y2VyIHN0YXRlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFZhbHVlIHBhc3NlZCB0byBzZWxlY3RvckZuIHdpbGwgYmUgYSBQcm94eSAtIHVzZSBzZWxlY3Rvci5vcmlnaW5hbChwcm94eSkgdG8gZ2V0IG9yaWdpbmFsIHN0YXRlIHZhbHVlICh1c2VmdWwgZm9yIGRlYnVnZ2luZylcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgaW5qZWN0ZWRSZWR1Y2VyID0gcm9vdFJlZHVjZXIuaW5qZWN0KGJvb2xlYW5TbGljZSk7XG4gICAgICogY29uc3Qgc2VsZWN0Qm9vbGVhbiA9IGluamVjdGVkUmVkdWNlci5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGluamVjdGVkUmVkdWNlci5zZWxlY3Rvci5vcmlnaW5hbChzdGF0ZSkuYm9vbGVhbikgLy8gcG9zc2libHkgdW5kZWZpbmVkXG4gICAgICogICByZXR1cm4gc3RhdGUuYm9vbGVhblxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG5cbiAgICA8U2VsZWN0b3IgZXh0ZW5kcyAoc3RhdGU6IERlY2xhcmVkU3RhdGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB1bmtub3duLCBSb290U3RhdGU+KHNlbGVjdG9yRm46IFNlbGVjdG9yLCBzZWxlY3RTdGF0ZTogKHJvb3RTdGF0ZTogUm9vdFN0YXRlLCAuLi5hcmdzOiBUYWlsPFBhcmFtZXRlcnM8U2VsZWN0b3I+PikgPT4gV2l0aE9wdGlvbmFsUHJvcDxQYXJhbWV0ZXJzPFNlbGVjdG9yPlswXSwgRXhjbHVkZTxrZXlvZiBEZWNsYXJlZFN0YXRlLCBrZXlvZiBJbml0aWFsU3RhdGU+Pik6IChzdGF0ZTogUm9vdFN0YXRlLCAuLi5hcmdzOiBUYWlsPFBhcmFtZXRlcnM8U2VsZWN0b3I+PikgPT4gUmV0dXJuVHlwZTxTZWxlY3Rvcj47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5wcm94aWVkIHN0YXRlLiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKiBAcGFyYW0gc3RhdGUgc3RhdGUgUHJveHksIHRoYXQgZW5zdXJlcyBpbmplY3RlZCByZWR1Y2VycyBoYXZlIHZhbHVlXG4gICAgICogQHJldHVybnMgb3JpZ2luYWwsIHVucHJveGllZCBzdGF0ZVxuICAgICAqIEB0aHJvd3MgaWYgdmFsdWUgcGFzc2VkIGlzIG5vdCBhIHN0YXRlIFByb3h5XG4gICAgICovXG5cbiAgICBvcmlnaW5hbDogKHN0YXRlOiBEZWNsYXJlZFN0YXRlKSA9PiBJbml0aWFsU3RhdGUgJiBQYXJ0aWFsPERlY2xhcmVkU3RhdGU+O1xuICB9O1xufVxudHlwZSBJbml0aWFsU3RhdGU8U2xpY2VzIGV4dGVuZHMgQXJyYXk8QW55U2xpY2VMaWtlIHwgUmVkdWNlck1hcD4+ID0gVW5pb25Ub0ludGVyc2VjdGlvbjxTbGljZXNbbnVtYmVyXSBleHRlbmRzIGluZmVyIFNsaWNlID8gU2xpY2UgZXh0ZW5kcyBBbnlTbGljZUxpa2UgPyBXaXRoU2xpY2U8U2xpY2U+IDogU3RhdGVGcm9tUmVkdWNlcnNNYXBPYmplY3Q8U2xpY2U+IDogbmV2ZXI+O1xuXG5jb25zdCBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZTogQW55U2xpY2VMaWtlIHwgUmVkdWNlck1hcCk6IG1heWJlU2xpY2VMaWtlIGlzIEFueVNsaWNlTGlrZSA9PiAncmVkdWNlclBhdGgnIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gJ3N0cmluZyc7XG5cbmNvbnN0IGdldFJlZHVjZXJzID0gKHNsaWNlczogQXJyYXk8QW55U2xpY2VMaWtlIHwgUmVkdWNlck1hcD4pID0+IHNsaWNlcy5mbGF0TWFwKHNsaWNlT3JNYXAgPT4gaXNTbGljZUxpa2Uoc2xpY2VPck1hcCkgPyBbKFtzbGljZU9yTWFwLnJlZHVjZXJQYXRoLCBzbGljZU9yTWFwLnJlZHVjZXJdIGFzIGNvbnN0KV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG5cbmNvbnN0IE9SSUdJTkFMX1NUQVRFID0gU3ltYm9sLmZvcigncnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsJyk7XG5cbmNvbnN0IGlzU3RhdGVQcm94eSA9ICh2YWx1ZTogYW55KSA9PiAhIXZhbHVlICYmICEhdmFsdWVbT1JJR0lOQUxfU1RBVEVdO1xuXG5jb25zdCBzdGF0ZVByb3h5TWFwID0gbmV3IFdlYWtNYXA8b2JqZWN0LCBvYmplY3Q+KCk7XG5cbmNvbnN0IGNyZWF0ZVN0YXRlUHJveHkgPSA8U3RhdGUgZXh0ZW5kcyBvYmplY3QsPihzdGF0ZTogU3RhdGUsIHJlZHVjZXJNYXA6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgUmVkdWNlcj4+KSA9PiAoZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSkgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcblxuICAgICAgICBpZiAocmVkdWNlcikge1xuICAgICAgICAgIC8vIGVuc3VyZSBhY3Rpb24gdHlwZSBpcyByYW5kb20sIHRvIHByZXZlbnQgcmVkdWNlciB0cmVhdGluZyBpdCBkaWZmZXJlbnRseVxuICAgICAgICAgIGNvbnN0IHJlZHVjZXJSZXN1bHQgPSByZWR1Y2VyKHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgdHlwZTogbmFub2lkKClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcmVkdWNlclJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gYCArIGBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgYCArIGBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IGAgKyBgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgYCArIGB5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZWR1Y2VyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSkgYXMgU3RhdGUpO1xuXG5jb25zdCBvcmlnaW5hbCA9IChzdGF0ZTogYW55KSA9PiB7XG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMjUpIDogJ29yaWdpbmFsIG11c3QgYmUgdXNlZCBvbiBzdGF0ZSBQcm94eScpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG5cbmNvbnN0IG5vb3BSZWR1Y2VyOiBSZWR1Y2VyPFJlY29yZDxzdHJpbmcsIGFueT4+ID0gKHN0YXRlID0ge30pID0+IHN0YXRlO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVNsaWNlczxTbGljZXMgZXh0ZW5kcyBBcnJheTxBbnlTbGljZUxpa2UgfCBSZWR1Y2VyTWFwPj4oLi4uc2xpY2VzOiBTbGljZXMpOiBDb21iaW5lZFNsaWNlUmVkdWNlcjxJZDxJbml0aWFsU3RhdGU8U2xpY2VzPj4+IHtcbiAgY29uc3QgcmVkdWNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllczxSZWR1Y2VyPihnZXRSZWR1Y2VycyhzbGljZXMpKTtcblxuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJNYXApIDogbm9vcFJlZHVjZXI7XG5cbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG5cbiAgZnVuY3Rpb24gY29tYmluZWRSZWR1Y2VyKHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgYWN0aW9uOiBVbmtub3duQWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cblxuICBjb21iaW5lZFJlZHVjZXIud2l0aExhenlMb2FkZWRTbGljZXMgPSAoKSA9PiBjb21iaW5lZFJlZHVjZXI7XG5cbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlOiBBbnlTbGljZUxpa2UsIGNvbmZpZzogSW5qZWN0Q29uZmlnID0ge30pOiB0eXBlb2YgY29tYmluZWRSZWR1Y2VyID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuXG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyByZWR1Y2VyICR7cmVkdWNlclBhdGh9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gICAgfVxuXG4gICAgcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF0gPSByZWR1Y2VyVG9JbmplY3Q7XG4gICAgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICB9O1xuXG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3I8U3RhdGUgZXh0ZW5kcyBvYmplY3QsIFJvb3RTdGF0ZSwgQXJncyBleHRlbmRzIGFueVtdPihzZWxlY3RvckZuOiAoc3RhdGU6IFN0YXRlLCAuLi5hcmdzOiBBcmdzKSA9PiBhbnksIHNlbGVjdFN0YXRlPzogKHJvb3RTdGF0ZTogUm9vdFN0YXRlLCAuLi5hcmdzOiBBcmdzKSA9PiBTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcihzdGF0ZTogU3RhdGUsIC4uLmFyZ3M6IEFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZSgoc3RhdGUgYXMgYW55KSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCksIC4uLmFyZ3MpO1xuICAgIH07XG4gIH0sIHtcbiAgICBvcmlnaW5hbFxuICB9KTtcbiAgcmV0dXJuIChPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KSBhcyBhbnkpO1xufSIsIi8qKlxuICogQWRhcHRlZCBmcm9tIFJlYWN0OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UuanNcbiAqXG4gKiBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCB0aHJvdyBlcnJvciBjYWxscy4gVGhlc2UgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4gKiBkdXJpbmcgYnVpbGQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBUb29sa2l0IGVycm9yICMke2NvZGV9OyB2aXNpdCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgYCArICd1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiAnO1xufSIsInZhciBxPU9iamVjdC5jcmVhdGU7dmFyIHA9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBBPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIEk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIFE9T2JqZWN0LmdldFByb3RvdHlwZU9mLFM9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgTj0oZSx0KT0+KCk9Pih0fHxlKCh0PXtleHBvcnRzOnt9fSkuZXhwb3J0cyx0KSx0LmV4cG9ydHMpLE89KGUsdCk9Pntmb3IodmFyIG4gaW4gdClwKGUsbix7Z2V0OnRbbl0sZW51bWVyYWJsZTohMH0pfSxtPShlLHQsbix3KT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgZiBvZiBJKHQpKSFTLmNhbGwoZSxmKSYmZiE9PW4mJnAoZSxmLHtnZXQ6KCk9PnRbZl0sZW51bWVyYWJsZTohKHc9QSh0LGYpKXx8dy5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9LGg9KGUsdCxuKT0+KG0oZSx0LFwiZGVmYXVsdFwiKSxuJiZtKG4sdCxcImRlZmF1bHRcIikpLHk9KGUsdCxuKT0+KG49ZSE9bnVsbD9xKFEoZSkpOnt9LG0odHx8IWV8fCFlLl9fZXNNb2R1bGU/cChuLFwiZGVmYXVsdFwiLHt2YWx1ZTplLGVudW1lcmFibGU6ITB9KTpuLGUpKSxVPWU9Pm0ocCh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgdj1OKChGLEUpPT57dmFyIHI9RS5leHBvcnRzPXt9LGksdTtmdW5jdGlvbiBUKCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBnKCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09XCJmdW5jdGlvblwiP2k9c2V0VGltZW91dDppPVR9Y2F0Y2goZSl7aT1UfXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT1cImZ1bmN0aW9uXCI/dT1jbGVhclRpbWVvdXQ6dT1nfWNhdGNoKGUpe3U9Z319KSgpO2Z1bmN0aW9uIGIoZSl7aWYoaT09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQoZSwwKTtpZigoaT09PVR8fCFpKSYmc2V0VGltZW91dClyZXR1cm4gaT1zZXRUaW1lb3V0LHNldFRpbWVvdXQoZSwwKTt0cnl7cmV0dXJuIGkoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIGkuY2FsbChudWxsLGUsMCl9Y2F0Y2gobil7cmV0dXJuIGkuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBqKGUpe2lmKHU9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChlKTtpZigodT09PWd8fCF1KSYmY2xlYXJUaW1lb3V0KXJldHVybiB1PWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQoZSk7dHJ5e3JldHVybiB1KGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gdS5jYWxsKG51bGwsZSl9Y2F0Y2gobil7cmV0dXJuIHUuY2FsbCh0aGlzLGUpfX19dmFyIG89W10scz0hMSxhLGQ9LTE7ZnVuY3Rpb24geigpeyFzfHwhYXx8KHM9ITEsYS5sZW5ndGg/bz1hLmNvbmNhdChvKTpkPS0xLG8ubGVuZ3RoJiZ4KCkpfWZ1bmN0aW9uIHgoKXtpZighcyl7dmFyIGU9Yih6KTtzPSEwO2Zvcih2YXIgdD1vLmxlbmd0aDt0Oyl7Zm9yKGE9byxvPVtdOysrZDx0OylhJiZhW2RdLnJ1bigpO2Q9LTEsdD1vLmxlbmd0aH1hPW51bGwscz0hMSxqKGUpfX1yLm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSlmb3IodmFyIG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbi0xXT1hcmd1bWVudHNbbl07by5wdXNoKG5ldyBMKGUsdCkpLG8ubGVuZ3RoPT09MSYmIXMmJmIoeCl9O2Z1bmN0aW9uIEwoZSx0KXt0aGlzLmZ1bj1lLHRoaXMuYXJyYXk9dH1MLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTtyLnRpdGxlPVwiYnJvd3NlclwiO3IuYnJvd3Nlcj0hMDtyLmVudj17fTtyLmFyZ3Y9W107ci52ZXJzaW9uPVwiXCI7ci52ZXJzaW9ucz17fTtmdW5jdGlvbiBjKCl7fXIub249YztyLmFkZExpc3RlbmVyPWM7ci5vbmNlPWM7ci5vZmY9YztyLnJlbW92ZUxpc3RlbmVyPWM7ci5yZW1vdmVBbGxMaXN0ZW5lcnM9YztyLmVtaXQ9YztyLnByZXBlbmRMaXN0ZW5lcj1jO3IucHJlcGVuZE9uY2VMaXN0ZW5lcj1jO3IubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTtyLmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3IuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3IuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTtyLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSk7dmFyIGw9e307TyhsLHtkZWZhdWx0OigpPT5CfSk7bW9kdWxlLmV4cG9ydHM9VShsKTt2YXIgQz15KHYoKSk7aChsLHkodigpKSxtb2R1bGUuZXhwb3J0cyk7dmFyIEI9Qy5kZWZhdWx0O1xuIiwiLy8gc3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IGVycm9yICMke2NvZGV9OyB2aXNpdCBodHRwczovL3JlZHV4LmpzLm9yZy9FcnJvcnM/Y29kZT0ke2NvZGV9IGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIGA7XG59XG5cbi8vIHNyYy91dGlscy9zeW1ib2wtb2JzZXJ2YWJsZS50c1xudmFyICQkb2JzZXJ2YWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8IFwiQEBvYnNlcnZhYmxlXCIpKCk7XG52YXIgc3ltYm9sX29ic2VydmFibGVfZGVmYXVsdCA9ICQkb2JzZXJ2YWJsZTtcblxuLy8gc3JjL3V0aWxzL2FjdGlvblR5cGVzLnRzXG52YXIgcmFuZG9tU3RyaW5nID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KFwiXCIpLmpvaW4oXCIuXCIpO1xudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBgQEByZWR1eC9JTklUJHsvKiBAX19QVVJFX18gKi8gcmFuZG9tU3RyaW5nKCl9YCxcbiAgUkVQTEFDRTogYEBAcmVkdXgvUkVQTEFDRSR7LyogQF9fUFVSRV9fICovIHJhbmRvbVN0cmluZygpfWAsXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiAoKSA9PiBgQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTiR7cmFuZG9tU3RyaW5nKCl9YFxufTtcbnZhciBhY3Rpb25UeXBlc19kZWZhdWx0ID0gQWN0aW9uVHlwZXM7XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgcHJvdG8gPSBvYmo7XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG8gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG51bGw7XG59XG5cbi8vIHNyYy91dGlscy9raW5kT2YudHNcbmZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMClcbiAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKHZhbCA9PT0gbnVsbClcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgIGNhc2UgXCJmdW5jdGlvblwiOiB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICBpZiAoaXNEYXRlKHZhbCkpXG4gICAgcmV0dXJuIFwiZGF0ZVwiO1xuICBpZiAoaXNFcnJvcih2YWwpKVxuICAgIHJldHVybiBcImVycm9yXCI7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGN0b3JOYW1lKHZhbCk7XG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSBcIlN5bWJvbFwiOlxuICAgIGNhc2UgXCJQcm9taXNlXCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgXCJcIik7XG59XG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHZhbC5jb25zdHJ1Y3Rvci5uYW1lIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdmFsLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbC5zZXREYXRlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIGxldCB0eXBlT2ZWYWwgPSB0eXBlb2YgdmFsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdHlwZU9mVmFsID0gbWluaUtpbmRPZih2YWwpO1xuICB9XG4gIHJldHVybiB0eXBlT2ZWYWw7XG59XG5cbi8vIHNyYy9jcmVhdGVTdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBgRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKHJlZHVjZXIpfSdgKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGVuaGFuY2VyID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGVuaGFuY2VyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcIkl0IGxvb2tzIGxpa2UgeW91IGFyZSBwYXNzaW5nIHNldmVyYWwgc3RvcmUgZW5oYW5jZXJzIHRvIGNyZWF0ZVN0b3JlKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCwgY29tcG9zZSB0aGVtIHRvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBgRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YoZW5oYW5jZXIpfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cbiAgbGV0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgbGV0IGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICBsZXQgY3VycmVudExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgbGV0IGxpc3RlbmVySWRDb3VudGVyID0gMDtcbiAgbGV0IGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBrZXkpID0+IHtcbiAgICAgICAgbmV4dExpc3RlbmVycy5zZXQoa2V5LCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBUaGUgcmVkdWNlciBoYXMgYWxyZWFkeSByZWNlaXZlZCB0aGUgc3RhdGUgYXMgYW4gYXJndW1lbnQuIFBhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBgRXhwZWN0ZWQgdGhlIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YobGlzdGVuZXIpfSdgKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogXCJZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLnN1YnNjcmliZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gYmUgbm90aWZpZWQgYWZ0ZXIgdGhlIHN0b3JlIGhhcyBiZWVuIHVwZGF0ZWQsIHN1YnNjcmliZSBmcm9tIGEgY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy5cIik7XG4gICAgfVxuICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBsaXN0ZW5lcklkID0gbGlzdGVuZXJJZENvdW50ZXIrKztcbiAgICBuZXh0TGlzdGVuZXJzLnNldChsaXN0ZW5lcklkLCBsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcIllvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy5cIik7XG4gICAgICB9XG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVySWQpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiBgQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICcke2tpbmRPZihhY3Rpb24pfScuIFlvdSBtYXkgbmVlZCB0byBhZGQgbWlkZGxld2FyZSB0byB5b3VyIHN0b3JlIHNldHVwIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBvdGhlciB2YWx1ZXMsIHN1Y2ggYXMgJ3JlZHV4LXRodW5rJyB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgZnVuY3Rpb25zLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjbWlkZGxld2FyZSBhbmQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTYtYXN5bmMtbG9naWMjdXNpbmctdGhlLXJlZHV4LXRodW5rLW1pZGRsZXdhcmUgZm9yIGV4YW1wbGVzLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6ICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTcpIDogYEFjdGlvbiBcInR5cGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnJHtraW5kT2YoYWN0aW9uLnR5cGUpfScuIFZhbHVlIHdhczogJyR7YWN0aW9uLnR5cGV9JyAoc3RyaW5naWZpZWQpYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6IFwiUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiBgRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YobmV4dFJlZHVjZXIpfWApO1xuICAgIH1cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IGFjdGlvblR5cGVzX2RlZmF1bHQuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgY29uc3Qgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gXCJvYmplY3RcIiB8fCBvYnNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDExKSA6IGBFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKG9ic2VydmVyKX0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGNvbnN0IG9ic2VydmVyQXNPYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICAgIGlmIChvYnNlcnZlckFzT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJBc09ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbc3ltYm9sX29ic2VydmFibGVfZGVmYXVsdF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IGFjdGlvblR5cGVzX2RlZmF1bHQuSU5JVFxuICB9KTtcbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyLFxuICAgIFtzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0XTogb2JzZXJ2YWJsZVxuICB9O1xuICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBsZWdhY3lfY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8vIHNyYy9jb21iaW5lUmVkdWNlcnMudHNcbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKSB7XG4gIGNvbnN0IHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICBjb25zdCBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IGFjdGlvblR5cGVzX2RlZmF1bHQuSU5JVCA/IFwicHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlXCIgOiBcInByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyXCI7XG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gXCJTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLlwiO1xuICB9XG4gIGlmICghaXNQbGFpbk9iamVjdChpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiBgVGhlICR7YXJndW1lbnROYW1lfSBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJHtraW5kT2YoaW5wdXRTdGF0ZSl9XCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czogXCIke3JlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpfVwiYDtcbiAgfVxuICBjb25zdCB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcigoa2V5KSA9PiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV0pO1xuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBhY3Rpb25UeXBlc19kZWZhdWx0LlJFUExBQ0UpXG4gICAgcmV0dXJuO1xuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBgVW5leHBlY3RlZCAke3VuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyBcImtleXNcIiA6IFwia2V5XCJ9IFwiJHt1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKX1cIiBmb3VuZCBpbiAke2FyZ3VtZW50TmFtZX0uIEV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogXCIke3JlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpfVwiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLmA7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTaGFwZShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgIHR5cGU6IGFjdGlvblR5cGVzX2RlZmF1bHQuSU5JVFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIElmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIHlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgIHR5cGU6IGFjdGlvblR5cGVzX2RlZmF1bHQuUFJPQkVfVU5LTk9XTl9BQ1RJT04oKVxuICAgIH0pID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuIERvbid0IHRyeSB0byBoYW5kbGUgJyR7YWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUfScgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiBuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuYCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICBjb25zdCByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgY29uc3QgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gcmVkdWNlcktleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHdhcm5pbmcoYE5vIHJlZHVjZXIgcHJvdmlkZWQgZm9yIGtleSBcIiR7a2V5fVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICBjb25zdCBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG4gIGxldCB1bmV4cGVjdGVkS2V5Q2FjaGU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuICBsZXQgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIGNvbnN0IG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IGBXaGVuIGNhbGxlZCB3aXRoIGFuIGFjdGlvbiBvZiB0eXBlICR7YWN0aW9uVHlwZSA/IGBcIiR7U3RyaW5nKGFjdGlvblR5cGUpfVwiYCA6IFwiKHVua25vd24gdHlwZSlcIn0sIHRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke2tleX1cIiByZXR1cm5lZCB1bmRlZmluZWQuIFRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGg7XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuLy8gc3JjL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh0aGlzLCBhcmdzKSk7XG4gIH07XG59XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09IFwib2JqZWN0XCIgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBgYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBidXQgaW5zdGVhZCByZWNlaXZlZDogJyR7a2luZE9mKGFjdGlvbkNyZWF0b3JzKX0nLiBEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiP2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICBjb25zdCBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLy8gc3JjL2NvbXBvc2UudHNcbmZ1bmN0aW9uIGNvbXBvc2UoLi4uZnVuY3MpIHtcbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYXJnKSA9PiBhcmc7XG4gIH1cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuICByZXR1cm4gZnVuY3MucmVkdWNlKChhLCBiKSA9PiAoLi4uYXJncykgPT4gYShiKC4uLmFyZ3MpKSk7XG59XG5cbi8vIHNyYy9hcHBseU1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSguLi5taWRkbGV3YXJlcykge1xuICByZXR1cm4gKGNyZWF0ZVN0b3JlMikgPT4gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZTIocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICAgIGxldCBkaXNwYXRjaCA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1KSA6IFwiRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gT3RoZXIgbWlkZGxld2FyZSB3b3VsZCBub3QgYmUgYXBwbGllZCB0byB0aGlzIGRpc3BhdGNoLlwiKTtcbiAgICB9O1xuICAgIGNvbnN0IG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICBkaXNwYXRjaDogKGFjdGlvbiwgLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uLCAuLi5hcmdzKVxuICAgIH07XG4gICAgY29uc3QgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoKG1pZGRsZXdhcmUpID0+IG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSkpO1xuICAgIGRpc3BhdGNoID0gY29tcG9zZSguLi5jaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdG9yZSxcbiAgICAgIGRpc3BhdGNoXG4gICAgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2lzQWN0aW9uLnRzXG5mdW5jdGlvbiBpc0FjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJiBcInR5cGVcIiBpbiBhY3Rpb24gJiYgdHlwZW9mIGFjdGlvbi50eXBlID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0IHtcbiAgYWN0aW9uVHlwZXNfZGVmYXVsdCBhcyBfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzLFxuICBhcHBseU1pZGRsZXdhcmUsXG4gIGJpbmRBY3Rpb25DcmVhdG9ycyxcbiAgY29tYmluZVJlZHVjZXJzLFxuICBjb21wb3NlLFxuICBjcmVhdGVTdG9yZSxcbiAgaXNBY3Rpb24sXG4gIGlzUGxhaW5PYmplY3QsXG4gIGxlZ2FjeV9jcmVhdGVTdG9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4Lm1qcy5tYXAiLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBSZWFjdDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLmpzXG4gKlxuICogRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgdGhyb3cgZXJyb3IgY2FsbHMuIFRoZXNlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuICogZHVyaW5nIGJ1aWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZTogbnVtYmVyKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgYCArICd1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiAnO1xufSIsImRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFN5bWJvbENvbnN0cnVjdG9yIHtcbiAgICByZWFkb25seSBvYnNlcnZhYmxlOiBzeW1ib2w7XG4gIH1cbn1cbmNvbnN0ICQkb2JzZXJ2YWJsZSA9IC8qICNfX1BVUkVfXyAqLygoKSA9PiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnKSgpO1xuZXhwb3J0IGRlZmF1bHQgJCRvYnNlcnZhYmxlOyIsIi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG5cbmNvbnN0IHJhbmRvbVN0cmluZyA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuY29uc3QgQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6IGBAQHJlZHV4L0lOSVQkey8qICNfX1BVUkVfXyAqL3JhbmRvbVN0cmluZygpfWAsXG4gIFJFUExBQ0U6IGBAQHJlZHV4L1JFUExBQ0Ukey8qICNfX1BVUkVfXyAqL3JhbmRvbVN0cmluZygpfWAsXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiAoKSA9PiBgQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTiR7cmFuZG9tU3RyaW5nKCl9YFxufTtcbmV4cG9ydCBkZWZhdWx0IEFjdGlvblR5cGVzOyIsIi8qKlxuICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iajogYW55KTogb2JqIGlzIG9iamVjdCB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgbGV0IHByb3RvID0gb2JqO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IHByb3RvIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBudWxsO1xufSIsIi8vIElubGluZWQgLyBzaG9ydGVuZWQgdmVyc2lvbiBvZiBga2luZE9mYCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2tpbmQtb2ZcbmV4cG9ydCBmdW5jdGlvbiBtaW5pS2luZE9mKHZhbDogYW55KTogc3RyaW5nIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnTWFwJzpcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfVxuXG4gIC8vIG90aGVyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufVxuZnVuY3Rpb24gY3Rvck5hbWUodmFsOiBhbnkpOiBzdHJpbmcgfCBudWxsIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0Vycm9yKHZhbDogYW55KSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcic7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsOiBhbnkpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBraW5kT2YodmFsOiBhbnkpIHtcbiAgbGV0IHR5cGVPZlZhbDogc3RyaW5nID0gdHlwZW9mIHZhbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVPZlZhbDtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTMgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMiB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTExIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTAgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U5IH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOCB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2IH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICcuL3V0aWxzL3N5bWJvbC1vYnNlcnZhYmxlJztcbmltcG9ydCB7IFN0b3JlLCBTdG9yZUVuaGFuY2VyLCBEaXNwYXRjaCwgT2JzZXJ2ZXIsIExpc3RlbmVyQ2FsbGJhY2ssIFVua25vd25JZk5vblNwZWNpZmljIH0gZnJvbSAnLi90eXBlcy9zdG9yZSc7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL3R5cGVzL2FjdGlvbnMnO1xuaW1wb3J0IHsgUmVkdWNlciB9IGZyb20gJy4vdHlwZXMvcmVkdWNlcnMnO1xuaW1wb3J0IEFjdGlvblR5cGVzIGZyb20gJy4vdXRpbHMvYWN0aW9uVHlwZXMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi91dGlscy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB7IGtpbmRPZiB9IGZyb20gJy4vdXRpbHMva2luZE9mJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqICoqV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgY29uZmlndXJlU3RvcmVgIG1ldGhvZFxuICogb2YgdGhlIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlKiosIHdoaWNoIHJlcGxhY2VzIGBjcmVhdGVTdG9yZWAuXG4gKlxuICogUmVkdXggVG9vbGtpdCBpcyBvdXIgcmVjb21tZW5kZWQgYXBwcm9hY2ggZm9yIHdyaXRpbmcgUmVkdXggbG9naWMgdG9kYXksXG4gKiBpbmNsdWRpbmcgc3RvcmUgc2V0dXAsIHJlZHVjZXJzLCBkYXRhIGZldGNoaW5nLCBhbmQgbW9yZS5cbiAqXG4gKiAqKkZvciBtb3JlIGRldGFpbHMsIHBsZWFzZSByZWFkIHRoaXMgUmVkdXggZG9jcyBwYWdlOioqXG4gKiAqKmh0dHBzOi8vcmVkdXguanMub3JnL2ludHJvZHVjdGlvbi93aHktcnRrLWlzLXJlZHV4LXRvZGF5KipcbiAqXG4gKiBgY29uZmlndXJlU3RvcmVgIGZyb20gUmVkdXggVG9vbGtpdCBpcyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTdG9yZWAgdGhhdFxuICogc2ltcGxpZmllcyBzZXR1cCBhbmQgaGVscHMgYXZvaWQgY29tbW9uIGJ1Z3MuXG4gKlxuICogWW91IHNob3VsZCBub3QgYmUgdXNpbmcgdGhlIGByZWR1eGAgY29yZSBwYWNrYWdlIGJ5IGl0c2VsZiB0b2RheSwgZXhjZXB0IGZvciBsZWFybmluZyBwdXJwb3Nlcy5cbiAqIFRoZSBgY3JlYXRlU3RvcmVgIG1ldGhvZCBmcm9tIHRoZSBjb3JlIGByZWR1eGAgcGFja2FnZSB3aWxsIG5vdCBiZSByZW1vdmVkLCBidXQgd2UgZW5jb3VyYWdlXG4gKiBhbGwgdXNlcnMgdG8gbWlncmF0ZSB0byB1c2luZyBSZWR1eCBUb29sa2l0IGZvciBhbGwgUmVkdXggY29kZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2UgYGNyZWF0ZVN0b3JlYCB3aXRob3V0IHRoaXMgdmlzdWFsIGRlcHJlY2F0aW9uIHdhcm5pbmcsIHVzZVxuICogdGhlIGBsZWdhY3lfY3JlYXRlU3RvcmVgIGltcG9ydCBpbnN0ZWFkOlxuICpcbiAqIGBpbXBvcnQgeyBsZWdhY3lfY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmV9IGZyb20gJ3JlZHV4J2BcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZTxTLCBBIGV4dGVuZHMgQWN0aW9uLCBFeHQgZXh0ZW5kcyB7fSA9IHt9LCBTdGF0ZUV4dCBleHRlbmRzIHt9ID0ge30+KHJlZHVjZXI6IFJlZHVjZXI8UywgQT4sIGVuaGFuY2VyPzogU3RvcmVFbmhhbmNlcjxFeHQsIFN0YXRlRXh0Pik6IFN0b3JlPFMsIEEsIFVua25vd25JZk5vblNwZWNpZmljPFN0YXRlRXh0Pj4gJiBFeHQ7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fSwgUHJlbG9hZGVkU3RhdGUgPSBTPihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEEsIFByZWxvYWRlZFN0YXRlPiwgcHJlbG9hZGVkU3RhdGU/OiBQcmVsb2FkZWRTdGF0ZSB8IHVuZGVmaW5lZCwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZTxTLCBBIGV4dGVuZHMgQWN0aW9uLCBFeHQgZXh0ZW5kcyB7fSA9IHt9LCBTdGF0ZUV4dCBleHRlbmRzIHt9ID0ge30sIFByZWxvYWRlZFN0YXRlID0gUz4ocmVkdWNlcjogUmVkdWNlcjxTLCBBLCBQcmVsb2FkZWRTdGF0ZT4sIHByZWxvYWRlZFN0YXRlPzogUHJlbG9hZGVkU3RhdGUgfCBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+IHwgdW5kZWZpbmVkLCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0IHtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogYEV4cGVjdGVkIHRoZSByb290IHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihyZWR1Y2VyKX0nYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDApIDogJ0l0IGxvb2tzIGxpa2UgeW91IGFyZSBwYXNzaW5nIHNldmVyYWwgc3RvcmUgZW5oYW5jZXJzIHRvICcgKyAnY3JlYXRlU3RvcmUoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJbnN0ZWFkLCBjb21wb3NlIHRoZW0gJyArICd0b2dldGhlciB0byBhIHNpbmdsZSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI2NyZWF0aW5nLWEtc3RvcmUtd2l0aC1lbmhhbmNlcnMgZm9yIGFuIGV4YW1wbGUuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSAocHJlbG9hZGVkU3RhdGUgYXMgU3RvcmVFbmhhbmNlcjxFeHQsIFN0YXRlRXh0Pik7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDEpIDogYEV4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGVuaGFuY2VyKX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgKHByZWxvYWRlZFN0YXRlIGFzIFByZWxvYWRlZFN0YXRlIHwgdW5kZWZpbmVkKSk7XG4gIH1cbiAgbGV0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgbGV0IGN1cnJlbnRTdGF0ZTogUyB8IFByZWxvYWRlZFN0YXRlIHwgdW5kZWZpbmVkID0gKHByZWxvYWRlZFN0YXRlIGFzIFByZWxvYWRlZFN0YXRlIHwgdW5kZWZpbmVkKTtcbiAgbGV0IGN1cnJlbnRMaXN0ZW5lcnM6IE1hcDxudW1iZXIsIExpc3RlbmVyQ2FsbGJhY2s+IHwgbnVsbCA9IG5ldyBNYXAoKTtcbiAgbGV0IG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICBsZXQgbGlzdGVuZXJJZENvdW50ZXIgPSAwO1xuICBsZXQgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnRMaXN0ZW5lcnMgc28gd2UgY2FuIHVzZVxuICAgKiBuZXh0TGlzdGVuZXJzIGFzIGEgdGVtcG9yYXJ5IGxpc3Qgd2hpbGUgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJldmVudHMgYW55IGJ1Z3MgYXJvdW5kIGNvbnN1bWVycyBjYWxsaW5nXG4gICAqIHN1YnNjcmliZS91bnN1YnNjcmliZSBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guXG4gICAqL1xuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgY3VycmVudExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lciwga2V5KSA9PiB7XG4gICAgICAgIG5leHRMaXN0ZW5lcnMuc2V0KGtleSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpOiBTIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgzKSA6ICdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRTdGF0ZSBhcyBTKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSg0KSA6IGBFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihsaXN0ZW5lcil9J2ApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNig1KSA6ICdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLnN1YnNjcmliZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSAnICsgJ2NvbXBvbmVudCBhbmQgaW52b2tlIHN0b3JlLmdldFN0YXRlKCkgaW4gdGhlIGNhbGxiYWNrIHRvIGFjY2VzcyB0aGUgbGF0ZXN0IHN0YXRlLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICB9XG4gICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIGNvbnN0IGxpc3RlbmVySWQgPSBsaXN0ZW5lcklkQ291bnRlcisrO1xuICAgIG5leHRMaXN0ZW5lcnMuc2V0KGxpc3RlbmVySWQsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U3KDYpIDogJ1lvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgICAgfVxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICBuZXh0TGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcklkKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uOiBBKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTgoNykgOiBgQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICcke2tpbmRPZihhY3Rpb24pfScuIFlvdSBtYXkgbmVlZCB0byBhZGQgbWlkZGxld2FyZSB0byB5b3VyIHN0b3JlIHNldHVwIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBvdGhlciB2YWx1ZXMsIHN1Y2ggYXMgJ3JlZHV4LXRodW5rJyB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgZnVuY3Rpb25zLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjbWlkZGxld2FyZSBhbmQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTYtYXN5bmMtbG9naWMjdXNpbmctdGhlLXJlZHV4LXRodW5rLW1pZGRsZXdhcmUgZm9yIGV4YW1wbGVzLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOSg4KSA6ICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTEwKDE3KSA6IGBBY3Rpb24gXCJ0eXBlXCIgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbi50eXBlKX0nLiBWYWx1ZSB3YXM6ICcke2FjdGlvbi50eXBlfScgKHN0cmluZ2lmaWVkKWApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTEoOSkgOiAnUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+KTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTIoMTApIDogYEV4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKG5leHRSZWR1Y2VyKX1gKTtcbiAgICB9XG4gICAgY3VycmVudFJlZHVjZXIgPSAoKG5leHRSZWR1Y2VyIGFzIHVua25vd24pIGFzIFJlZHVjZXI8UywgQSwgUHJlbG9hZGVkU3RhdGU+KTtcblxuICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIHNpbWlsYXIgZWZmZWN0IHRvIEFjdGlvblR5cGVzLklOSVQuXG4gICAgLy8gQW55IHJlZHVjZXJzIHRoYXQgZXhpc3RlZCBpbiBib3RoIHRoZSBuZXcgYW5kIG9sZCByb290UmVkdWNlclxuICAgIC8vIHdpbGwgcmVjZWl2ZSB0aGUgcHJldmlvdXMgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gICAgLy8gdGhlIG5ldyBzdGF0ZSB0cmVlIHdpdGggYW55IHJlbGV2YW50IGRhdGEgZnJvbSB0aGUgb2xkIG9uZS5cbiAgICBkaXNwYXRjaCgoe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0gYXMgQSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIGNvbnN0IG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlKG9ic2VydmVyOiB1bmtub3duKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTMoMTEpIDogYEV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2Yob2JzZXJ2ZXIpfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgY29uc3Qgb2JzZXJ2ZXJBc09ic2VydmVyID0gKG9ic2VydmVyIGFzIE9ic2VydmVyPFM+KTtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXJBc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyQXNPYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgWyQkb2JzZXJ2YWJsZV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goKHtcbiAgICB0eXBlOiBBY3Rpb25UeXBlcy5JTklUXG4gIH0gYXMgQSkpO1xuICBjb25zdCBzdG9yZSA9ICgoe1xuICAgIGRpc3BhdGNoOiAoZGlzcGF0Y2ggYXMgRGlzcGF0Y2g8QT4pLFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcixcbiAgICBbJCRvYnNlcnZhYmxlXTogb2JzZXJ2YWJsZVxuICB9IGFzIHVua25vd24pIGFzIFN0b3JlPFMsIEEsIFN0YXRlRXh0PiAmIEV4dCk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyBgY29uZmlndXJlU3RvcmVgIGZyb20gdGhlXG4gKiBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgOlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X2NyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fT4ocmVkdWNlcjogUmVkdWNlcjxTLCBBPiwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dDtcbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIHRoZVxuICogYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYDpcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9jcmVhdGVTdG9yZTxTLCBBIGV4dGVuZHMgQWN0aW9uLCBFeHQgZXh0ZW5kcyB7fSA9IHt9LCBTdGF0ZUV4dCBleHRlbmRzIHt9ID0ge30sIFByZWxvYWRlZFN0YXRlID0gUz4ocmVkdWNlcjogUmVkdWNlcjxTLCBBLCBQcmVsb2FkZWRTdGF0ZT4sIHByZWxvYWRlZFN0YXRlPzogUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQsIGVuaGFuY2VyPzogU3RvcmVFbmhhbmNlcjxFeHQsIFN0YXRlRXh0Pik6IFN0b3JlPFMsIEEsIFVua25vd25JZk5vblNwZWNpZmljPFN0YXRlRXh0Pj4gJiBFeHQ7XG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X2NyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fSwgUHJlbG9hZGVkU3RhdGUgPSBTPihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+LCBwcmVsb2FkZWRTdGF0ZT86IFByZWxvYWRlZFN0YXRlIHwgU3RvcmVFbmhhbmNlcjxFeHQsIFN0YXRlRXh0PiB8IHVuZGVmaW5lZCwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dCB7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyZWR1Y2VyLCAocHJlbG9hZGVkU3RhdGUgYXMgYW55KSwgZW5oYW5jZXIpO1xufSIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi90eXBlcy9hY3Rpb25zJztcbmltcG9ydCB7IEFjdGlvbkZyb21SZWR1Y2Vyc01hcE9iamVjdCwgUHJlbG9hZGVkU3RhdGVTaGFwZUZyb21SZWR1Y2Vyc01hcE9iamVjdCwgUmVkdWNlciwgU3RhdGVGcm9tUmVkdWNlcnNNYXBPYmplY3QgfSBmcm9tICcuL3R5cGVzL3JlZHVjZXJzJztcbmltcG9ydCBBY3Rpb25UeXBlcyBmcm9tICcuL3V0aWxzL2FjdGlvblR5cGVzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vdXRpbHMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3V0aWxzL3dhcm5pbmcnO1xuaW1wb3J0IHsga2luZE9mIH0gZnJvbSAnLi91dGlscy9raW5kT2YnO1xuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlOiBvYmplY3QsIHJlZHVjZXJzOiB7XG4gIFtrZXk6IHN0cmluZ106IFJlZHVjZXI8YW55LCBhbnksIGFueT47XG59LCBhY3Rpb246IEFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlOiB7XG4gIFtrZXk6IHN0cmluZ106IHRydWU7XG59KSB7XG4gIGNvbnN0IHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICBjb25zdCBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG4gIGlmICghaXNQbGFpbk9iamVjdChpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiBgVGhlICR7YXJndW1lbnROYW1lfSBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJHtraW5kT2YoaW5wdXRTdGF0ZSl9XCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgYCArIGBrZXlzOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCJgO1xuICB9XG4gIGNvbnN0IHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGtleSA9PiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV0pO1xuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuUkVQTEFDRSkgcmV0dXJuO1xuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBgVW5leHBlY3RlZCAke3VuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5J30gYCArIGBcIiR7dW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJyl9XCIgZm91bmQgaW4gJHthcmd1bWVudE5hbWV9LiBgICsgYEV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogYCArIGBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuYDtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzOiB7XG4gIFtrZXk6IHN0cmluZ106IFJlZHVjZXI8YW55LCBhbnksIGFueT47XG59KSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIGAgKyBgSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGAgKyBgZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBgICsgYG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIGAgKyBgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUFJPQkVfVU5LTk9XTl9BQ1RJT04oKVxuICAgIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigxMykgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuIGAgKyBgRG9uJ3QgdHJ5IHRvIGhhbmRsZSAnJHtBY3Rpb25UeXBlcy5JTklUfScgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiBgICsgYG5hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGAgKyBgY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgYCArIGBpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgYCArIGBhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC5gKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAdGVtcGxhdGUgUyBDb21iaW5lZCBzdGF0ZSBvYmplY3QgdHlwZS5cbiAqXG4gKiBAcGFyYW0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudCByZWR1Y2VyXG4gKiAgIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0XG4gKiAgIGlzIHRvIHVzZSBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlclxuICogICByZXR1cm4gdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXJcbiAqICAgaW5pdGlhbCBzdGF0ZSBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50XG4gKiAgIHN0YXRlIGZvciBhbnkgdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZSBwYXNzZWRcbiAqICAgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VyczxNPihyZWR1Y2VyczogTSk6IE1ba2V5b2YgTV0gZXh0ZW5kcyBSZWR1Y2VyPGFueSwgYW55LCBhbnk+IHwgdW5kZWZpbmVkID8gUmVkdWNlcjxTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdDxNPiwgQWN0aW9uRnJvbVJlZHVjZXJzTWFwT2JqZWN0PE0+LCBQYXJ0aWFsPFByZWxvYWRlZFN0YXRlU2hhcGVGcm9tUmVkdWNlcnNNYXBPYmplY3Q8TT4+PiA6IG5ldmVyO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzOiB7XG4gIFtrZXk6IHN0cmluZ106IFJlZHVjZXI8YW55LCBhbnksIGFueT47XG59KSB7XG4gIGNvbnN0IHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICBjb25zdCBmaW5hbFJlZHVjZXJzOiB7XG4gICAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55PjtcbiAgfSA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gcmVkdWNlcktleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyhgTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJHtrZXl9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICBjb25zdCBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB3YXJuIGFib3V0IHRoZSBzYW1lXG4gIC8vIGtleXMgbXVsdGlwbGUgdGltZXMuXG4gIGxldCB1bmV4cGVjdGVkS2V5Q2FjaGU6IHtcbiAgICBba2V5OiBzdHJpbmddOiB0cnVlO1xuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG4gIGxldCBzaGFwZUFzc2VydGlvbkVycm9yOiB1bmtub3duO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZTogU3RhdGVGcm9tUmVkdWNlcnNNYXBPYmplY3Q8dHlwZW9mIHJlZHVjZXJzPiA9IHt9LCBhY3Rpb246IEFjdGlvbikge1xuICAgIGlmIChzaGFwZUFzc2VydGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBzaGFwZUFzc2VydGlvbkVycm9yO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgbmV4dFN0YXRlOiBTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdDx0eXBlb2YgcmVkdWNlcnM+ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgY29uc3QgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgY29uc3QgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMTQpIDogYFdoZW4gY2FsbGVkIHdpdGggYW4gYWN0aW9uIG9mIHR5cGUgJHthY3Rpb25UeXBlID8gYFwiJHtTdHJpbmcoYWN0aW9uVHlwZSl9XCJgIDogJyh1bmtub3duIHR5cGUpJ30sIHRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke2tleX1cIiByZXR1cm5lZCB1bmRlZmluZWQuIGAgKyBgVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLiBgICsgYElmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgRGlzcGF0Y2ggfSBmcm9tICcuL3R5cGVzL3N0b3JlJztcbmltcG9ydCB7IEFjdGlvbkNyZWF0b3IsIEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0LCBBY3Rpb24gfSBmcm9tICcuL3R5cGVzL2FjdGlvbnMnO1xuaW1wb3J0IHsga2luZE9mIH0gZnJvbSAnLi91dGlscy9raW5kT2YnO1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3I8QSBleHRlbmRzIEFjdGlvbj4oYWN0aW9uQ3JlYXRvcjogQWN0aW9uQ3JlYXRvcjxBPiwgZGlzcGF0Y2g6IERpc3BhdGNoPEE+KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhbiBhY3Rpb24gY3JlYXRvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZGlzcGF0Y2ggd3JhcHBlZCBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMgVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzPEEsIEMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPEE+PihhY3Rpb25DcmVhdG9yOiBDLCBkaXNwYXRjaDogRGlzcGF0Y2gpOiBDO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzPEEgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPGFueT4sIEIgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPGFueT4+KGFjdGlvbkNyZWF0b3I6IEEsIGRpc3BhdGNoOiBEaXNwYXRjaCk6IEI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnM8QSwgTSBleHRlbmRzIEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0PEE+PihhY3Rpb25DcmVhdG9yczogTSwgZGlzcGF0Y2g6IERpc3BhdGNoKTogTTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yczxNIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIE4gZXh0ZW5kcyBBY3Rpb25DcmVhdG9yc01hcE9iamVjdD4oYWN0aW9uQ3JlYXRvcnM6IE0sIGRpc3BhdGNoOiBEaXNwYXRjaCk6IE47XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnM6IEFjdGlvbkNyZWF0b3I8YW55PiB8IEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0LCBkaXNwYXRjaDogRGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IGBiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGJ1dCBpbnN0ZWFkIHJlY2VpdmVkOiAnJHtraW5kT2YoYWN0aW9uQ3JlYXRvcnMpfScuIGAgKyBgRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj9gKTtcbiAgfVxuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzOiBBY3Rpb25DcmVhdG9yc01hcE9iamVjdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn0iLCJ0eXBlIEZ1bmM8VCBleHRlbmRzIGFueVtdLCBSPiA9ICguLi5hOiBUKSA9PiBSO1xuXG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3IgdGhlXG4gKiByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHRcbiAqICAgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGBjb21wb3NlKGYsIGcsIGgpYCBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICAgYCguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpYC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZSgpOiA8Uj4oYTogUikgPT4gUjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2U8RiBleHRlbmRzIEZ1bmN0aW9uPihmOiBGKTogRjtcblxuLyogdHdvIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxBLCBUIGV4dGVuZHMgYW55W10sIFI+KGYxOiAoYTogQSkgPT4gUiwgZjI6IEZ1bmM8VCwgQT4pOiBGdW5jPFQsIFI+O1xuXG4vKiB0aHJlZSBmdW5jdGlvbnMgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2U8QSwgQiwgVCBleHRlbmRzIGFueVtdLCBSPihmMTogKGI6IEIpID0+IFIsIGYyOiAoYTogQSkgPT4gQiwgZjM6IEZ1bmM8VCwgQT4pOiBGdW5jPFQsIFI+O1xuXG4vKiBmb3VyIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxBLCBCLCBDLCBUIGV4dGVuZHMgYW55W10sIFI+KGYxOiAoYzogQykgPT4gUiwgZjI6IChiOiBCKSA9PiBDLCBmMzogKGE6IEEpID0+IEIsIGY0OiBGdW5jPFQsIEE+KTogRnVuYzxULCBSPjtcblxuLyogcmVzdCAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxSPihmMTogKGE6IGFueSkgPT4gUiwgLi4uZnVuY3M6IEZ1bmN0aW9uW10pOiAoLi4uYXJnczogYW55W10pID0+IFI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPFI+KC4uLmZ1bmNzOiBGdW5jdGlvbltdKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBSO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZSguLi5mdW5jczogRnVuY3Rpb25bXSkge1xuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gaW5mZXIgdGhlIGFyZ3VtZW50IHR5cGUgc28gaXQgaXMgdXNhYmxlIGluIGluZmVyZW5jZSBkb3duIHRoZSBsaW5lXG4gICAgcmV0dXJuIDxULD4oYXJnOiBUKSA9PiBhcmc7XG4gIH1cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuICByZXR1cm4gZnVuY3MucmVkdWNlKChhLCBiKSA9PiAoLi4uYXJnczogYW55KSA9PiBhKGIoLi4uYXJncykpKTtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IHsgTWlkZGxld2FyZSwgTWlkZGxld2FyZUFQSSB9IGZyb20gJy4vdHlwZXMvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBTdG9yZUVuaGFuY2VyLCBEaXNwYXRjaCB9IGZyb20gJy4vdHlwZXMvc3RvcmUnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICpcbiAqIEB0ZW1wbGF0ZSBFeHQgRGlzcGF0Y2ggc2lnbmF0dXJlIGFkZGVkIGJ5IGEgbWlkZGxld2FyZS5cbiAqIEB0ZW1wbGF0ZSBTIFRoZSB0eXBlIG9mIHRoZSBzdGF0ZSBzdXBwb3J0ZWQgYnkgYSBtaWRkbGV3YXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKTogU3RvcmVFbmhhbmNlcjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxO1xufT47XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmU8RXh0MSwgRXh0MiwgUz4obWlkZGxld2FyZTE6IE1pZGRsZXdhcmU8RXh0MSwgUywgYW55PiwgbWlkZGxld2FyZTI6IE1pZGRsZXdhcmU8RXh0MiwgUywgYW55Pik6IFN0b3JlRW5oYW5jZXI8e1xuICBkaXNwYXRjaDogRXh0MSAmIEV4dDI7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBFeHQyLCBFeHQzLCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+LCBtaWRkbGV3YXJlMjogTWlkZGxld2FyZTxFeHQyLCBTLCBhbnk+LCBtaWRkbGV3YXJlMzogTWlkZGxld2FyZTxFeHQzLCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxICYgRXh0MiAmIEV4dDM7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBFeHQyLCBFeHQzLCBFeHQ0LCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+LCBtaWRkbGV3YXJlMjogTWlkZGxld2FyZTxFeHQyLCBTLCBhbnk+LCBtaWRkbGV3YXJlMzogTWlkZGxld2FyZTxFeHQzLCBTLCBhbnk+LCBtaWRkbGV3YXJlNDogTWlkZGxld2FyZTxFeHQ0LCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxICYgRXh0MiAmIEV4dDMgJiBFeHQ0O1xufT47XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmU8RXh0MSwgRXh0MiwgRXh0MywgRXh0NCwgRXh0NSwgUz4obWlkZGxld2FyZTE6IE1pZGRsZXdhcmU8RXh0MSwgUywgYW55PiwgbWlkZGxld2FyZTI6IE1pZGRsZXdhcmU8RXh0MiwgUywgYW55PiwgbWlkZGxld2FyZTM6IE1pZGRsZXdhcmU8RXh0MywgUywgYW55PiwgbWlkZGxld2FyZTQ6IE1pZGRsZXdhcmU8RXh0NCwgUywgYW55PiwgbWlkZGxld2FyZTU6IE1pZGRsZXdhcmU8RXh0NSwgUywgYW55Pik6IFN0b3JlRW5oYW5jZXI8e1xuICBkaXNwYXRjaDogRXh0MSAmIEV4dDIgJiBFeHQzICYgRXh0NCAmIEV4dDU7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQsIFMgPSBhbnk+KC4uLm1pZGRsZXdhcmVzOiBNaWRkbGV3YXJlPGFueSwgUywgYW55PltdKTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQ7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSguLi5taWRkbGV3YXJlczogTWlkZGxld2FyZVtdKTogU3RvcmVFbmhhbmNlcjxhbnk+IHtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlID0+IChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICAgIGxldCBkaXNwYXRjaDogRGlzcGF0Y2ggPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogJ0Rpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVjdGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuICcgKyAnT3RoZXIgbWlkZGxld2FyZSB3b3VsZCBub3QgYmUgYXBwbGllZCB0byB0aGlzIGRpc3BhdGNoLicpO1xuICAgIH07XG4gICAgY29uc3QgbWlkZGxld2FyZUFQSTogTWlkZGxld2FyZUFQSSA9IHtcbiAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoOiAoYWN0aW9uLCAuLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb24sIC4uLmFyZ3MpXG4gICAgfTtcbiAgICBjb25zdCBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChtaWRkbGV3YXJlID0+IG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSkpO1xuICAgIGRpc3BhdGNoID0gY29tcG9zZTx0eXBlb2YgZGlzcGF0Y2g+KC4uLmNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0b3JlLFxuICAgICAgZGlzcGF0Y2hcbiAgICB9O1xuICB9O1xufSIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL3R5cGVzL2FjdGlvbnMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWN0aW9uKGFjdGlvbjogdW5rbm93bik6IGFjdGlvbiBpcyBBY3Rpb248c3RyaW5nPiB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGFjdGlvbikgJiYgJ3R5cGUnIGluIGFjdGlvbiAmJiB0eXBlb2YgKGFjdGlvbiBhcyBSZWNvcmQ8J3R5cGUnLCB1bmtub3duPikudHlwZSA9PT0gJ3N0cmluZyc7XG59IiwidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vLyBzcmMvdXRpbHMvZW52LnRzXG52YXIgTk9USElORyA9IFN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpO1xudmFyIERSQUZUQUJMRSA9IFN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik7XG52YXIgRFJBRlRfU1RBVEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIik7XG5cbi8vIHNyYy91dGlscy9lcnJvcnMudHNcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBbXG4gIC8vIEFsbCBlcnJvciBjb2Rlcywgc3RhcnRpbmcgYnkgMDpcbiAgZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgcmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gO1xuICB9LFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0aGluZ30nYDtcbiAgfSxcbiAgXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuICBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArIGRhdGE7XG4gIH0sXG4gIFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcbiAgXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcbiAgXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG4gIFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XG4gIH0sXG4gIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfVxuICAvLyBOb3RlOiBpZiBtb3JlIGVycm9ycyBhcmUgYWRkZWQsIHRoZSBlcnJvck9mZnNldCBpbiBQYXRjaGVzLnRzIHNob3VsZCBiZSBpbmNyZWFzZWRcbiAgLy8gU2VlIFBhdGNoZXMudHMgZm9yIGFkZGl0aW9uYWwgZXJyb3JzXG5dIDogW107XG5mdW5jdGlvbiBkaWUoZXJyb3IsIC4uLmFyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGUgPSBlcnJvcnNbZXJyb3JdO1xuICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KG51bGwsIGFyZ3MpIDogZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtJbW1lcl0gJHttc2d9YCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfS4gRnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbW1vbi50c1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIHZhciBfYTtcbiAgaWYgKCF2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISEoKF9hID0gdmFsdWUuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYVtEUkFGVEFCTEVdKSB8fCBpc01hcCh2YWx1ZSkgfHwgaXNTZXQodmFsdWUpO1xufVxudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgaWYgKEN0b3IgPT09IE9iamVjdClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSlcbiAgICBkaWUoMTUsIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlXztcbn1cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyKSB7XG4gIGlmIChnZXRBcmNodHlwZShvYmopID09PSAwIC8qIE9iamVjdCAqLykge1xuICAgIFJlZmxlY3Qub3duS2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaXRlcihrZXksIG9ialtrZXldLCBvYmopO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iai5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmcpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV07XG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLnR5cGVfIDogQXJyYXkuaXNBcnJheSh0aGluZykgPyAxIC8qIEFycmF5ICovIDogaXNNYXAodGhpbmcpID8gMiAvKiBNYXAgKi8gOiBpc1NldCh0aGluZykgPyAzIC8qIFNldCAqLyA6IDAgLyogT2JqZWN0ICovO1xufVxuZnVuY3Rpb24gaGFzKHRoaW5nLCBwcm9wKSB7XG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDIgLyogTWFwICovID8gdGhpbmcuaGFzKHByb3ApIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKTtcbn1cbmZ1bmN0aW9uIGdldCh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyIC8qIE1hcCAqLyA/IHRoaW5nLmdldChwcm9wKSA6IHRoaW5nW3Byb3BdO1xufVxuZnVuY3Rpb24gc2V0KHRoaW5nLCBwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpIHtcbiAgY29uc3QgdCA9IGdldEFyY2h0eXBlKHRoaW5nKTtcbiAgaWYgKHQgPT09IDIgLyogTWFwICovKVxuICAgIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO1xuICBlbHNlIGlmICh0ID09PSAzIC8qIFNldCAqLykge1xuICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gIH0gZWxzZVxuICAgIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBpc01hcCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIE1hcDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuZnVuY3Rpb24gbGF0ZXN0KHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlXztcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGJhc2UsIHN0cmljdCkge1xuICBpZiAoaXNNYXAoYmFzZSkpIHtcbiAgICByZXR1cm4gbmV3IE1hcChiYXNlKTtcbiAgfVxuICBpZiAoaXNTZXQoYmFzZSkpIHtcbiAgICByZXR1cm4gbmV3IFNldChiYXNlKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlKSlcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSk7XG4gIGlmICghc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoYmFzZSkpIHtcbiAgICBpZiAoIWdldFByb3RvdHlwZU9mKGJhc2UpKSB7XG4gICAgICBjb25zdCBvYmogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZSk7XG4gIH1cbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcbiAgZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcbiAgbGV0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoZGVzY3JpcHRvcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuICAgIGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcbiAgICAgIGRlc2NyaXB0b3JzW2tleV0gPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIHZhbHVlOiBiYXNlW2tleV1cbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoaXNGcm96ZW4ob2JqKSB8fCBpc0RyYWZ0KG9iaikgfHwgIWlzRHJhZnRhYmxlKG9iaikpXG4gICAgcmV0dXJuIG9iajtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPiAxKSB7XG4gICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xuICB9XG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSkpO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuICBkaWUoMik7XG59XG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbihvYmopO1xufVxuXG4vLyBzcmMvdXRpbHMvcGx1Z2lucy50c1xudmFyIHBsdWdpbnMgPSB7fTtcbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5LZXkpIHtcbiAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5LZXldO1xuICBpZiAoIXBsdWdpbikge1xuICAgIGRpZSgwLCBwbHVnaW5LZXkpO1xuICB9XG4gIHJldHVybiBwbHVnaW47XG59XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbi8vIHNyYy9jb3JlL3Njb3BlLnRzXG52YXIgY3VycmVudFNjb3BlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NvcGUocGFyZW50XywgaW1tZXJfKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZnRzXzogW10sXG4gICAgcGFyZW50XyxcbiAgICBpbW1lcl8sXG4gICAgLy8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuICAgIC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG4gICAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gICAgdW5maW5hbGl6ZWREcmFmdHNfOiAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7XG4gICAgc2NvcGUucGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XG4gIGxlYXZlU2NvcGUoc2NvcGUpO1xuICBzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpO1xuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcbiAgICBjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfO1xuICB9XG59XG5mdW5jdGlvbiBlbnRlclNjb3BlKGltbWVyMikge1xuICByZXR1cm4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcjIpO1xufVxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMCAvKiBPYmplY3QgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8pXG4gICAgc3RhdGUucmV2b2tlXygpO1xuICBlbHNlXG4gICAgc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG4vLyBzcmMvY29yZS9maW5hbGl6ZS50c1xuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKSB7XG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xuICBjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICBjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB2b2lkIDAgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XG4gIGlmIChpc1JlcGxhY2VkKSB7XG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG4gICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICBkaWUoNCk7XG4gICAgfVxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50XylcbiAgICAgICAgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG4gICAgICAgIGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc2NvcGUucGF0Y2hlc18sXG4gICAgICAgIHNjb3BlLmludmVyc2VQYXRjaGVzX1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG4gIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8oc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaChcbiAgICAgIHZhbHVlLFxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKVxuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICB9XG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcbiAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5jb3B5XztcbiAgICBsZXQgcmVzdWx0RWFjaCA9IHJlc3VsdDtcbiAgICBsZXQgaXNTZXQyID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlLnR5cGVfID09PSAzIC8qIFNldCAqLykge1xuICAgICAgcmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KTtcbiAgICAgIHJlc3VsdC5jbGVhcigpO1xuICAgICAgaXNTZXQyID0gdHJ1ZTtcbiAgICB9XG4gICAgZWFjaChcbiAgICAgIHJlc3VsdEVhY2gsXG4gICAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldDIpXG4gICAgKTtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpO1xuICAgIGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcm9vdFNjb3BlLnBhdGNoZXNfLFxuICAgICAgICByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgcGFyZW50U3RhdGUsIHRhcmdldE9iamVjdCwgcHJvcCwgY2hpbGRWYWx1ZSwgcm9vdFBhdGgsIHRhcmdldElzU2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KVxuICAgIGRpZSg1KTtcbiAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICBjb25zdCBwYXRoID0gcm9vdFBhdGggJiYgcGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUudHlwZV8gIT09IDMgLyogU2V0ICovICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgc2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKTtcbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XG4gICAgICByb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0YXJnZXRJc1NldCkge1xuICAgIHRhcmdldE9iamVjdC5hZGQoY2hpbGRWYWx1ZSk7XG4gIH1cbiAgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICAgIGlmICgoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgJiYgdHlwZW9mIHByb3AgIT09IFwic3ltYm9sXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldE9iamVjdCwgcHJvcCkpXG4gICAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZSwgdmFsdWUsIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoIXNjb3BlLnBhcmVudF8gJiYgc2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHNjb3BlLmNhbkF1dG9GcmVlemVfKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9wcm94eS50c1xuZnVuY3Rpb24gY3JlYXRlUHJveHlQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHR5cGVfOiBpc0FycmF5ID8gMSAvKiBBcnJheSAqLyA6IDAgLyogT2JqZWN0ICovLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgIC8vIFVzZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxuICAgIGFzc2lnbmVkXzoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgLy8gVGhlIGJhc2Ugc3RhdGUuXG4gICAgYmFzZV86IGJhc2UsXG4gICAgLy8gVGhlIGJhc2UgcHJveHkuXG4gICAgZHJhZnRfOiBudWxsLFxuICAgIC8vIHNldCBiZWxvd1xuICAgIC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXG4gICAgY29weV86IG51bGwsXG4gICAgLy8gQ2FsbGVkIGJ5IHRoZSBgcHJvZHVjZWAgZnVuY3Rpb24uXG4gICAgcmV2b2tlXzogbnVsbCxcbiAgICBpc01hbnVhbF86IGZhbHNlXG4gIH07XG4gIGxldCB0YXJnZXQgPSBzdGF0ZTtcbiAgbGV0IHRyYXBzID0gb2JqZWN0VHJhcHM7XG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH1cbiAgY29uc3QgeyByZXZva2UsIHByb3h5IH0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcyk7XG4gIHN0YXRlLmRyYWZ0XyA9IHByb3h5O1xuICBzdGF0ZS5yZXZva2VfID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG52YXIgb2JqZWN0VHJhcHMgPSB7XG4gIGdldChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSlcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGlmICghaGFzKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgIHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2VbcHJvcF07XG4gICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV9bcHJvcF0gPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGhhcyhzdGF0ZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XG4gIH0sXG4gIG93bktleXMoc3RhdGUpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xuICB9LFxuICBzZXQoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgaWYgKGRlc2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRlc2Muc2V0KSB7XG4gICAgICBkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICBjb25zdCBjdXJyZW50MiA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjdXJyZW50MiA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudDJbRFJBRlRfU1RBVEVdO1xuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG4gICAgICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpcyh2YWx1ZSwgY3VycmVudDIpICYmICh2YWx1ZSAhPT0gdm9pZCAwIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfW3Byb3BdID09PSB2YWx1ZSAmJiAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuICAgICh2YWx1ZSAhPT0gdm9pZCAwIHx8IHByb3AgaW4gc3RhdGUuY29weV8pIHx8IC8vIHNwZWNpYWwgY2FzZTogTmFOXG4gICAgTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV9bcHJvcF0pKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdm9pZCAwIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgc3RhdGUuYXNzaWduZWRfW3Byb3BdO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29weV8pIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG4gICAgY29uc3Qgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcCk7XG4gICAgaWYgKCFkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gMSAvKiBBcnJheSAqLyB8fCBwcm9wICE9PSBcImxlbmd0aFwiLFxuICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgdmFsdWU6IG93bmVyW3Byb3BdXG4gICAgfTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgZGllKDExKTtcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pO1xuICB9LFxuICBzZXRQcm90b3R5cGVPZigpIHtcbiAgICBkaWUoMTIpO1xuICB9XG59O1xudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIChrZXksIGZuKSA9PiB7XG4gIGFycmF5VHJhcHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuYXJyYXlUcmFwcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxuICAgIGRpZSgxMyk7XG4gIHJldHVybiBhcnJheVRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlLCBwcm9wLCB2b2lkIDApO1xufTtcbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvcCAhPT0gXCJsZW5ndGhcIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpXG4gICAgZGllKDE0KTtcbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xufTtcbmZ1bmN0aW9uIHBlZWsoZHJhZnQsIHByb3ApIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGNvbnN0IHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0O1xuICByZXR1cm4gc291cmNlW3Byb3BdO1xufVxuZnVuY3Rpb24gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gYHZhbHVlYCBpbiBkZXNjID8gZGVzYy52YWx1ZSA6IChcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG4gICAgLy8gcHJvdG90eXBlLCB3ZSBzaG91bGQgaW52b2tlIGl0IHdpdGggdGhlIGRyYWZ0IGFzIGNvbnRleHQhXG4gICAgKF9hID0gZGVzYy5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHN0YXRlLmRyYWZ0XylcbiAgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKSB7XG4gIGlmICghKHByb3AgaW4gc291cmNlKSlcbiAgICByZXR1cm4gdm9pZCAwO1xuICBsZXQgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihzb3VyY2UpO1xuICB3aGlsZSAocHJvdG8pIHtcbiAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG4gICAgaWYgKGRlc2MpXG4gICAgICByZXR1cm4gZGVzYztcbiAgICBwcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gbWFya0NoYW5nZWQoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBzdGF0ZS5tb2RpZmllZF8gPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5wYXJlbnRfKSB7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZS5wYXJlbnRfKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weV8pIHtcbiAgICBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KFxuICAgICAgc3RhdGUuYmFzZV8sXG4gICAgICBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5X1xuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvaW1tZXJDbGFzcy50c1xudmFyIEltbWVyMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuICAgICAqXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cbiAgICAgKlxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLnByb2R1Y2UgPSAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2UgPSByZWNpcGU7XG4gICAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoYmFzZTIgPSBkZWZhdWx0QmFzZSwgLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZTIsIChkcmFmdCkgPT4gcmVjaXBlLmNhbGwodGhpcywgZHJhZnQsIC4uLmFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGRpZSg2KTtcbiAgICAgIGlmIChwYXRjaExpc3RlbmVyICE9PSB2b2lkIDAgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZGllKDcpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdm9pZCAwKTtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZWNpcGUocHJveHkpO1xuICAgICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGhhc0Vycm9yKVxuICAgICAgICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJlc3VsdCA9IGJhc2U7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5PVEhJTkcpXG4gICAgICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAodGhpcy5hdXRvRnJlZXplXylcbiAgICAgICAgICBmcmVlemUocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgICAgY29uc3QgaXAgPSBbXTtcbiAgICAgICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKTtcbiAgICAgICAgICBwYXRjaExpc3RlbmVyKHAsIGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlXG4gICAgICAgIGRpZSgxLCBiYXNlKTtcbiAgICB9O1xuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gKGJhc2UsIHJlY2lwZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgLi4uYXJncykgPT4gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdCkgPT4gYmFzZShkcmFmdCwgLi4uYXJncykpO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgKHAsIGlwKSA9PiB7XG4gICAgICAgIHBhdGNoZXMgPSBwO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiAoY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuYXV0b0ZyZWV6ZSkgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcbiAgICBpZiAodHlwZW9mIChjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy51c2VTdHJpY3RTaGFsbG93Q29weSkgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RTaGFsbG93Q29weShjb25maWcudXNlU3RyaWN0U2hhbGxvd0NvcHkpO1xuICB9XG4gIGNyZWF0ZURyYWZ0KGJhc2UpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKVxuICAgICAgZGllKDgpO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKVxuICAgICAgYmFzZSA9IGN1cnJlbnQoYmFzZSk7XG4gICAgY29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpO1xuICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdm9pZCAwKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZTtcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgZmluaXNoRHJhZnQoZHJhZnQsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pXG4gICAgICBkaWUoOSk7XG4gICAgY29uc3QgeyBzY29wZV86IHNjb3BlIH0gPSBzdGF0ZTtcbiAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodm9pZCAwLCBzY29wZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIHNldEF1dG9GcmVlemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBlbmFibGUgc3RyaWN0IHNoYWxsb3cgY29weS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cbiAgICovXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5KHZhbHVlKSB7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSB2YWx1ZTtcbiAgfVxuICBhcHBseVBhdGNoZXMoYmFzZSwgcGF0Y2hlcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHBhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgYmFzZSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgcGF0Y2hlcyA9IHBhdGNoZXMuc2xpY2UoaSArIDEpO1xuICAgIH1cbiAgICBjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShcbiAgICAgIGJhc2UsXG4gICAgICAoZHJhZnQpID0+IGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KHZhbHVlLCBwYXJlbnQpIHtcbiAgY29uc3QgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KSA6IGNyZWF0ZVByb3h5UHJveHkodmFsdWUsIHBhcmVudCk7XG4gIGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpO1xuICBzY29wZS5kcmFmdHNfLnB1c2goZHJhZnQpO1xuICByZXR1cm4gZHJhZnQ7XG59XG5cbi8vIHNyYy9jb3JlL2N1cnJlbnQudHNcbmZ1bmN0aW9uIGN1cnJlbnQodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSlcbiAgICBkaWUoMTAsIHZhbHVlKTtcbiAgcmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdGFibGUodmFsdWUpIHx8IGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBsZXQgY29weTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pXG4gICAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5Xyk7XG4gIH0gZWxzZSB7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCB0cnVlKTtcbiAgfVxuICBlYWNoKGNvcHksIChrZXksIGNoaWxkVmFsdWUpID0+IHtcbiAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XG4gIH0pO1xuICBpZiAoc3RhdGUpIHtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL3BhdGNoZXMudHNcbmZ1bmN0aW9uIGVuYWJsZVBhdGNoZXMoKSB7XG4gIGNvbnN0IGVycm9yT2Zmc2V0ID0gMTY7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgICdTZXRzIGNhbm5vdCBoYXZlIFwicmVwbGFjZVwiIHBhdGNoZXMuJyxcbiAgICAgIGZ1bmN0aW9uKG9wKSB7XG4gICAgICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBvcDtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiICsgcGF0aDtcbiAgICAgIH0sXG4gICAgICBcIlBhdGNoaW5nIHJlc2VydmVkIGF0dHJpYnV0ZXMgbGlrZSBfX3Byb3RvX18sIHByb3RvdHlwZSBhbmQgY29uc3RydWN0b3IgaXMgbm90IGFsbG93ZWRcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgUkVQTEFDRSA9IFwicmVwbGFjZVwiO1xuICBjb25zdCBBREQgPSBcImFkZFwiO1xuICBjb25zdCBSRU1PVkUgPSBcInJlbW92ZVwiO1xuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNfKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG4gICAgICBjYXNlIDAgLyogT2JqZWN0ICovOlxuICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgICBwYXRjaGVzLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzXG4gICAgICAgICk7XG4gICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcbiAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgICBpbnZlcnNlUGF0Y2hlc1xuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgbGV0IHsgYmFzZV8sIGFzc2lnbmVkXyB9ID0gc3RhdGU7XG4gICAgbGV0IGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgaWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgO1xuICAgICAgW2Jhc2VfLCBjb3B5X10gPSBbY29weV8sIGJhc2VfXTtcbiAgICAgIFtwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXNzaWduZWRfW2ldICYmIGNvcHlfW2ldICE9PSBiYXNlX1tpXSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlX1tpXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBjb3B5Xy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGNvcHlfLmxlbmd0aCAtIDE7IGJhc2VfLmxlbmd0aCA8PSBpOyAtLWkpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICBwYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBjb25zdCB7IGJhc2VfLCBjb3B5XyB9ID0gc3RhdGU7XG4gICAgZWFjaChzdGF0ZS5hc3NpZ25lZF8sIChrZXksIGFzc2lnbmVkVmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KGNvcHlfLCBrZXkpO1xuICAgICAgY29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBREQ7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgICAgcGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7IG9wLCBwYXRoIH0gOiB7IG9wLCBwYXRoLCB2YWx1ZSB9KTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goXG4gICAgICAgIG9wID09PSBBREQgPyB7IG9wOiBSRU1PVkUsIHBhdGggfSA6IG9wID09PSBSRU1PVkUgPyB7IG9wOiBBREQsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH0gOiB7IG9wOiBSRVBMQUNFLCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKSB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgbGV0IHsgYmFzZV8sIGNvcHlfIH0gPSBzdGF0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGlmICghY29weV8uaGFzKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfSk7XG4gICAgaSA9IDA7XG4gICAgY29weV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2VWYWx1ZSwgcmVwbGFjZW1lbnQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogcmVwbGFjZW1lbnQgPT09IE5PVEhJTkcgPyB2b2lkIDAgOiByZXBsYWNlbWVudFxuICAgIH0pO1xuICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiBiYXNlVmFsdWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgY29uc3QgeyBwYXRoLCBvcCB9ID0gcGF0Y2g7XG4gICAgICBsZXQgYmFzZSA9IGRyYWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICAgIGxldCBwID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMCAvKiBPYmplY3QgKi8gfHwgcGFyZW50VHlwZSA9PT0gMSAvKiBBcnJheSAqLykgJiYgKHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gXCJjb25zdHJ1Y3RvclwiKSlcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgcCA9PT0gXCJwcm90b3R5cGVcIilcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAzKTtcbiAgICAgICAgYmFzZSA9IGdldChiYXNlLCBwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDIsIHBhdGguam9pbihcIi9cIikpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKTtcbiAgICAgIGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBSRVBMQUNFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgZGllKGVycm9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUREOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSBcIi1cIiA/IGJhc2UucHVzaCh2YWx1ZSkgOiBiYXNlLnNwbGljZShrZXksIDAsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFTU9WRTpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMSwgb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuICBmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaikge1xuICAgIGlmICghaXNEcmFmdGFibGUob2JqKSlcbiAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpO1xuICAgIGlmIChpc01hcChvYmopKVxuICAgICAgcmV0dXJuIG5ldyBNYXAoXG4gICAgICAgIEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSkubWFwKChbaywgdl0pID0+IFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXSlcbiAgICAgICk7XG4gICAgaWYgKGlzU2V0KG9iaikpXG4gICAgICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKTtcbiAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKGdldFByb3RvdHlwZU9mKG9iaikpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iailcbiAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSk7XG4gICAgaWYgKGhhcyhvYmosIERSQUZUQUJMRSkpXG4gICAgICBjbG9uZWRbRFJBRlRBQkxFXSA9IG9ialtEUkFGVEFCTEVdO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgZnVuY3Rpb24gY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob2JqKSB7XG4gICAgaWYgKGlzRHJhZnQob2JqKSkge1xuICAgICAgcmV0dXJuIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBvYmo7XG4gIH1cbiAgbG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xuICAgIGFwcGx5UGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cbiAgfSk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL21hcHNldC50c1xuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICBjbGFzcyBEcmFmdE1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDIgLyogTWFwICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYXNzaWduZWRfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIWxhdGVzdChzdGF0ZSkuaGFzKGtleSkgfHwgbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmJhc2VfLmhhcyhrZXkpKSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZWFjaChzdGF0ZS5iYXNlXywgKGtleSkgPT4ge1xuICAgICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgbGF0ZXN0KHN0YXRlKS5mb3JFYWNoKChfdmFsdWUsIGtleSwgX21hcCkgPT4ge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0KGtleSksIGtleSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSk7XG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gc3RhdGUuYmFzZV8uZ2V0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgZHJhZnQpO1xuICAgICAgcmV0dXJuIGRyYWZ0O1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMudmFsdWVzKCksXG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChyLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy5lbnRyaWVzKCksXG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChyLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgWyhEUkFGVF9TVEFURSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb3h5TWFwXyh0YXJnZXQsIHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0YXRlLmNvcHlfID0gbmV3IE1hcChzdGF0ZS5iYXNlXyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIERyYWZ0U2V0IGV4dGVuZHMgU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogMyAvKiBTZXQgKi8sXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5Xzogdm9pZCAwLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGRyYWZ0c186IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZSxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weV8uaGFzKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5kZWxldGUodmFsdWUpIHx8IChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgPyBzdGF0ZS5jb3B5Xy5kZWxldGUoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSA6IChcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZmFsc2VcbiAgICAgICkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8udmFsdWVzKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9XG4gICAgWyhEUkFGVF9TVEFURSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYiwgdGhpc0FyZykge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xuICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcyk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJveHlTZXRfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZVNldENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5jb3B5XyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBzdGF0ZS5iYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKGRyYWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnJldm9rZWRfKVxuICAgICAgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKTtcbiAgfVxuICBsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHsgcHJveHlNYXBfLCBwcm94eVNldF8gfSk7XG59XG5cbi8vIHNyYy9pbW1lci50c1xudmFyIGltbWVyID0gbmV3IEltbWVyMigpO1xudmFyIHByb2R1Y2UgPSBpbW1lci5wcm9kdWNlO1xudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9IGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuICBpbW1lclxuKTtcbnZhciBzZXRBdXRvRnJlZXplID0gaW1tZXIuc2V0QXV0b0ZyZWV6ZS5iaW5kKGltbWVyKTtcbnZhciBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSA9IGltbWVyLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5LmJpbmQoaW1tZXIpO1xudmFyIGFwcGx5UGF0Y2hlcyA9IGltbWVyLmFwcGx5UGF0Y2hlcy5iaW5kKGltbWVyKTtcbnZhciBjcmVhdGVEcmFmdCA9IGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xudmFyIGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY2FzdEltbXV0YWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQge1xuICBJbW1lcjIgYXMgSW1tZXIsXG4gIGFwcGx5UGF0Y2hlcyxcbiAgY2FzdERyYWZ0LFxuICBjYXN0SW1tdXRhYmxlLFxuICBjcmVhdGVEcmFmdCxcbiAgY3VycmVudCxcbiAgZW5hYmxlTWFwU2V0LFxuICBlbmFibGVQYXRjaGVzLFxuICBmaW5pc2hEcmFmdCxcbiAgZnJlZXplLFxuICBEUkFGVEFCTEUgYXMgaW1tZXJhYmxlLFxuICBpc0RyYWZ0LFxuICBpc0RyYWZ0YWJsZSxcbiAgTk9USElORyBhcyBub3RoaW5nLFxuICBvcmlnaW5hbCxcbiAgcHJvZHVjZSxcbiAgcHJvZHVjZVdpdGhQYXRjaGVzLFxuICBzZXRBdXRvRnJlZXplLFxuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLmxlZ2FjeS1lc20uanMubWFwIiwiLy8gU2hvdWxkIGJlIG5vIGltcG9ydHMgaGVyZSFcblxuLyoqXG4gKiBUaGUgc2VudGluZWwgdmFsdWUgcmV0dXJuZWQgYnkgcHJvZHVjZXJzIHRvIHJlcGxhY2UgdGhlIGRyYWZ0IHdpdGggdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3QgTk9USElORzogdW5pcXVlIHN5bWJvbCA9IFN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpXG5cbi8qKlxuICogVG8gbGV0IEltbWVyIHRyZWF0IHlvdXIgY2xhc3MgaW5zdGFuY2VzIGFzIHBsYWluIGltbXV0YWJsZSBvYmplY3RzXG4gKiAoYWxiZWl0IHdpdGggYSBjdXN0b20gcHJvdG90eXBlKSwgeW91IG11c3QgZGVmaW5lIGVpdGhlciBhbiBpbnN0YW5jZSBwcm9wZXJ0eVxuICogb3IgYSBzdGF0aWMgcHJvcGVydHkgb24gZWFjaCBvZiB5b3VyIGN1c3RvbSBjbGFzc2VzLlxuICpcbiAqIE90aGVyd2lzZSwgeW91ciBjbGFzcyBpbnN0YW5jZSB3aWxsIG5ldmVyIGJlIGRyYWZ0ZWQsIHdoaWNoIG1lYW5zIGl0IHdvbid0IGJlXG4gKiBzYWZlIHRvIG11dGF0ZSBpbiBhIHByb2R1Y2UgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBjb25zdCBEUkFGVEFCTEU6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpXG5cbmV4cG9ydCBjb25zdCBEUkFGVF9TVEFURTogdW5pcXVlIHN5bWJvbCA9IFN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKVxuIiwiZXhwb3J0IGNvbnN0IGVycm9ycyA9XG5cdHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIlxuXHRcdD8gW1xuXHRcdFx0XHQvLyBBbGwgZXJyb3IgY29kZXMsIHN0YXJ0aW5nIGJ5IDA6XG5cdFx0XHRcdGZ1bmN0aW9uKHBsdWdpbjogc3RyaW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm4gYHByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJyR7dGhpbmd9J2Bcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuXHRcdFx0XHRmdW5jdGlvbihkYXRhOiBhbnkpIHtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICtcblx0XHRcdFx0XHRcdGRhdGFcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcblx0XHRcdFx0XCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcblx0XHRcdFx0XCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcblx0XHRcdFx0XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcblx0XHRcdFx0XCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG5cdFx0XHRcdFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuXHRcdFx0XHRmdW5jdGlvbih0aGluZzogc3RyaW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGAnY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG5cdFx0XHRcdFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0XHRcdFx0XCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcblx0XHRcdFx0XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsXG5cdFx0XHRcdGZ1bmN0aW9uKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YFxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE5vdGU6IGlmIG1vcmUgZXJyb3JzIGFyZSBhZGRlZCwgdGhlIGVycm9yT2Zmc2V0IGluIFBhdGNoZXMudHMgc2hvdWxkIGJlIGluY3JlYXNlZFxuXHRcdFx0XHQvLyBTZWUgUGF0Y2hlcy50cyBmb3IgYWRkaXRpb25hbCBlcnJvcnNcblx0XHQgIF1cblx0XHQ6IFtdXG5cbmV4cG9ydCBmdW5jdGlvbiBkaWUoZXJyb3I6IG51bWJlciwgLi4uYXJnczogYW55W10pOiBuZXZlciB7XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0XHRjb25zdCBlID0gZXJyb3JzW2Vycm9yXVxuXHRcdGNvbnN0IG1zZyA9IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KG51bGwsIGFyZ3MgYXMgYW55KSA6IGVcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFtJbW1lcl0gJHttc2d9YClcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0YFtJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6ICR7ZXJyb3J9LiBGdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmYFxuXHQpXG59XG4iLCJpbXBvcnQge1xuXHREUkFGVF9TVEFURSxcblx0RFJBRlRBQkxFLFxuXHRPYmplY3Rpc2gsXG5cdERyYWZ0ZWQsXG5cdEFueU9iamVjdCxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdEltbWVyU3RhdGUsXG5cdEFyY2hUeXBlLFxuXHRkaWVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGNvbnN0IGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIEltbWVyIGRyYWZ0ICovXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cdHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdXG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBkcmFmdGVkIGJ5IEltbWVyICovXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2Vcblx0cmV0dXJuIChcblx0XHRpc1BsYWluT2JqZWN0KHZhbHVlKSB8fFxuXHRcdEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG5cdFx0ISF2YWx1ZVtEUkFGVEFCTEVdIHx8XG5cdFx0ISF2YWx1ZS5jb25zdHJ1Y3Rvcj8uW0RSQUZUQUJMRV0gfHxcblx0XHRpc01hcCh2YWx1ZSkgfHxcblx0XHRpc1NldCh2YWx1ZSlcblx0KVxufVxuXG5jb25zdCBvYmplY3RDdG9yU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2Vcblx0Y29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZSlcblx0aWYgKHByb3RvID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHRydWVcblx0fVxuXHRjb25zdCBDdG9yID1cblx0XHRPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvclxuXG5cdGlmIChDdG9yID09PSBPYmplY3QpIHJldHVybiB0cnVlXG5cblx0cmV0dXJuIChcblx0XHR0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nXG5cdClcbn1cblxuLyoqIEdldCB0aGUgdW5kZXJseWluZyBvYmplY3QgdGhhdCBpcyByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gZHJhZnQgKi9cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmlnaW5hbDxUPih2YWx1ZTogVCk6IFQgfCB1bmRlZmluZWRcbmV4cG9ydCBmdW5jdGlvbiBvcmlnaW5hbCh2YWx1ZTogRHJhZnRlZDxhbnk+KTogYW55IHtcblx0aWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDE1LCB2YWx1ZSlcblx0cmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlX1xufVxuXG4vKipcbiAqIEVhY2ggaXRlcmF0ZXMgYSBtYXAsIHNldCBvciBhcnJheS5cbiAqIE9yLCBpZiBhbnkgb3RoZXIga2luZCBvZiBvZiBvYmplY3QgYWxsIGl0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBSZWdhcmRsZXNzIHdoZXRoZXIgdGhleSBhcmUgZW51bWVyYWJsZSBvciBzeW1ib2xzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRvYmo6IFQsXG5cdGl0ZXI6IChrZXk6IHN0cmluZyB8IG51bWJlciwgdmFsdWU6IGFueSwgc291cmNlOiBUKSA9PiB2b2lkXG4pOiB2b2lkXG5leHBvcnQgZnVuY3Rpb24gZWFjaChvYmo6IGFueSwgaXRlcjogYW55KSB7XG5cdGlmIChnZXRBcmNodHlwZShvYmopID09PSBBcmNoVHlwZS5PYmplY3QpIHtcblx0XHRSZWZsZWN0Lm93bktleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRpdGVyKGtleSwgb2JqW2tleV0sIG9iailcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdG9iai5mb3JFYWNoKChlbnRyeTogYW55LCBpbmRleDogYW55KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSlcblx0fVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmc6IGFueSk6IEFyY2hUeXBlIHtcblx0Y29uc3Qgc3RhdGU6IHVuZGVmaW5lZCB8IEltbWVyU3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV1cblx0cmV0dXJuIHN0YXRlXG5cdFx0PyBzdGF0ZS50eXBlX1xuXHRcdDogQXJyYXkuaXNBcnJheSh0aGluZylcblx0XHQ/IEFyY2hUeXBlLkFycmF5XG5cdFx0OiBpc01hcCh0aGluZylcblx0XHQ/IEFyY2hUeXBlLk1hcFxuXHRcdDogaXNTZXQodGhpbmcpXG5cdFx0PyBBcmNoVHlwZS5TZXRcblx0XHQ6IEFyY2hUeXBlLk9iamVjdFxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaGFzKHRoaW5nOiBhbnksIHByb3A6IFByb3BlcnR5S2V5KTogYm9vbGVhbiB7XG5cdHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IEFyY2hUeXBlLk1hcFxuXHRcdD8gdGhpbmcuaGFzKHByb3ApXG5cdFx0OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQodGhpbmc6IEFueU1hcCB8IEFueU9iamVjdCwgcHJvcDogUHJvcGVydHlLZXkpOiBhbnkge1xuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IEFyY2hUeXBlLk1hcCA/IHRoaW5nLmdldChwcm9wKSA6IHRoaW5nW3Byb3BdXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQodGhpbmc6IGFueSwgcHJvcE9yT2xkVmFsdWU6IFByb3BlcnR5S2V5LCB2YWx1ZTogYW55KSB7XG5cdGNvbnN0IHQgPSBnZXRBcmNodHlwZSh0aGluZylcblx0aWYgKHQgPT09IEFyY2hUeXBlLk1hcCkgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSlcblx0ZWxzZSBpZiAodCA9PT0gQXJjaFR5cGUuU2V0KSB7XG5cdFx0dGhpbmcuYWRkKHZhbHVlKVxuXHR9IGVsc2UgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWVcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHg6IGFueSwgeTogYW55KTogYm9vbGVhbiB7XG5cdC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuXHRpZiAoeCA9PT0geSkge1xuXHRcdHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHlcblx0fVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNNYXAodGFyZ2V0OiBhbnkpOiB0YXJnZXQgaXMgQW55TWFwIHtcblx0cmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIE1hcFxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNTZXQodGFyZ2V0OiBhbnkpOiB0YXJnZXQgaXMgQW55U2V0IHtcblx0cmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIFNldFxufVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGxhdGVzdChzdGF0ZTogSW1tZXJTdGF0ZSk6IGFueSB7XG5cdHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlX1xufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZTogYW55LCBzdHJpY3Q6IGJvb2xlYW4pIHtcblx0aWYgKGlzTWFwKGJhc2UpKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXAoYmFzZSlcblx0fVxuXHRpZiAoaXNTZXQoYmFzZSkpIHtcblx0XHRyZXR1cm4gbmV3IFNldChiYXNlKVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSlcblxuXHRpZiAoIXN0cmljdCAmJiBpc1BsYWluT2JqZWN0KGJhc2UpKSB7XG5cdFx0aWYgKCFnZXRQcm90b3R5cGVPZihiYXNlKSkge1xuXHRcdFx0Y29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBiYXNlKVxuXHRcdH1cblx0XHRyZXR1cm4gey4uLmJhc2V9XG5cdH1cblxuXHRjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpXG5cdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKVxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBrZXk6IGFueSA9IGtleXNbaV1cblx0XHRjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XVxuXHRcdGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuXHRcdFx0ZGVzYy53cml0YWJsZSA9IHRydWVcblx0XHRcdGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZVxuXHRcdH1cblx0XHQvLyBsaWtlIG9iamVjdC5hc3NpZ24sIHdlIHdpbGwgcmVhZCBhbnkgX293bl8sIGdldC9zZXQgYWNjZXNzb3JzLiBUaGlzIGhlbHBzIGluIGRlYWxpbmdcblx0XHQvLyB3aXRoIGxpYnJhcmllcyB0aGF0IHRyYXAgdmFsdWVzLCBsaWtlIG1vYnggb3IgdnVlXG5cdFx0Ly8gdW5saWtlIG9iamVjdC5hc3NpZ24sIG5vbi1lbnVtZXJhYmxlcyB3aWxsIGJlIGNvcGllZCBhcyB3ZWxsXG5cdFx0aWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KVxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XSA9IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSwgLy8gY291bGQgbGl2ZSB3aXRoICEhZGVzYy5zZXQgYXMgd2VsbCBoZXJlLi4uXG5cdFx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdFx0dmFsdWU6IGJhc2Vba2V5XVxuXHRcdFx0fVxuXHR9XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKGdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycylcbn1cblxuLyoqXG4gKiBGcmVlemVzIGRyYWZ0YWJsZSBvYmplY3RzLiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gKiBCeSBkZWZhdWx0IGZyZWV6ZXMgc2hhbGxvd2x5LCBidXQgaWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBgdHJ1ZWAgaXQgd2lsbCBmcmVlemUgcmVjdXJzaXZlbHkuXG4gKlxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIGRlZXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyZWV6ZTxUPihvYmo6IFQsIGRlZXA/OiBib29sZWFuKTogVFxuZXhwb3J0IGZ1bmN0aW9uIGZyZWV6ZTxUPihvYmo6IGFueSwgZGVlcDogYm9vbGVhbiA9IGZhbHNlKTogVCB7XG5cdGlmIChpc0Zyb3plbihvYmopIHx8IGlzRHJhZnQob2JqKSB8fCAhaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuIG9ialxuXHRpZiAoZ2V0QXJjaHR5cGUob2JqKSA+IDEgLyogTWFwIG9yIFNldCAqLykge1xuXHRcdG9iai5zZXQgPSBvYmouYWRkID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucyBhcyBhbnlcblx0fVxuXHRPYmplY3QuZnJlZXplKG9iailcblx0aWYgKGRlZXApXG5cdFx0Ly8gU2VlICM1OTAsIGRvbid0IHJlY3Vyc2UgaW50byBub24tZW51bWVyYWJsZSAvIFN5bWJvbCBwcm9wZXJ0aWVzIHdoZW4gZnJlZXppbmdcblx0XHQvLyBTbyB1c2UgT2JqZWN0LmVudHJpZXMgKG9ubHkgc3RyaW5nLWxpa2UsIGVudW1lcmFibGVzKSBpbnN0ZWFkIG9mIGVhY2goKVxuXHRcdE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiBmcmVlemUodmFsdWUsIHRydWUpKVxuXHRyZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcblx0ZGllKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Zyb3plbihvYmo6IGFueSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iailcbn1cbiIsImltcG9ydCB7XG5cdEltbWVyU3RhdGUsXG5cdFBhdGNoLFxuXHREcmFmdGVkLFxuXHRJbW1lckJhc2VTdGF0ZSxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdEFyY2hUeXBlLFxuXHRkaWVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuLyoqIFBsdWdpbiB1dGlsaXRpZXMgKi9cbmNvbnN0IHBsdWdpbnM6IHtcblx0UGF0Y2hlcz86IHtcblx0XHRnZW5lcmF0ZVBhdGNoZXNfKFxuXHRcdFx0c3RhdGU6IEltbWVyU3RhdGUsXG5cdFx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdFx0KTogdm9pZFxuXHRcdGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcblx0XHRcdGJhc2U6IGFueSxcblx0XHRcdHJlcGxhY2VtZW50OiBhbnksXG5cdFx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHQpOiB2b2lkXG5cdFx0YXBwbHlQYXRjaGVzXzxUPihkcmFmdDogVCwgcGF0Y2hlczogUGF0Y2hbXSk6IFRcblx0fVxuXHRNYXBTZXQ/OiB7XG5cdFx0cHJveHlNYXBfPFQgZXh0ZW5kcyBBbnlNYXA+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFRcblx0XHRwcm94eVNldF88VCBleHRlbmRzIEFueVNldD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVFxuXHR9XG59ID0ge31cblxudHlwZSBQbHVnaW5zID0gdHlwZW9mIHBsdWdpbnNcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsdWdpbjxLIGV4dGVuZHMga2V5b2YgUGx1Z2lucz4oXG5cdHBsdWdpbktleTogS1xuKTogRXhjbHVkZTxQbHVnaW5zW0tdLCB1bmRlZmluZWQ+IHtcblx0Y29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5LZXldXG5cdGlmICghcGx1Z2luKSB7XG5cdFx0ZGllKDAsIHBsdWdpbktleSlcblx0fVxuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiBwbHVnaW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQbHVnaW48SyBleHRlbmRzIGtleW9mIFBsdWdpbnM+KFxuXHRwbHVnaW5LZXk6IEssXG5cdGltcGxlbWVudGF0aW9uOiBQbHVnaW5zW0tdXG4pOiB2b2lkIHtcblx0aWYgKCFwbHVnaW5zW3BsdWdpbktleV0pIHBsdWdpbnNbcGx1Z2luS2V5XSA9IGltcGxlbWVudGF0aW9uXG59XG4vKiogTWFwIC8gU2V0IHBsdWdpbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hcFN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHR0eXBlXzogQXJjaFR5cGUuTWFwXG5cdGNvcHlfOiBBbnlNYXAgfCB1bmRlZmluZWRcblx0YXNzaWduZWRfOiBNYXA8YW55LCBib29sZWFuPiB8IHVuZGVmaW5lZFxuXHRiYXNlXzogQW55TWFwXG5cdHJldm9rZWRfOiBib29sZWFuXG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlNYXAsIE1hcFN0YXRlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldFN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHR0eXBlXzogQXJjaFR5cGUuU2V0XG5cdGNvcHlfOiBBbnlTZXQgfCB1bmRlZmluZWRcblx0YmFzZV86IEFueVNldFxuXHRkcmFmdHNfOiBNYXA8YW55LCBEcmFmdGVkPiAvLyBtYXBzIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byB0aGUgZHJhZnQgdmFsdWUgaW4gdGhlIG5ldyBzZXRcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueVNldCwgU2V0U3RhdGU+XG59XG5cbi8qKiBQYXRjaGVzIHBsdWdpbiAqL1xuXG5leHBvcnQgdHlwZSBQYXRjaFBhdGggPSAoc3RyaW5nIHwgbnVtYmVyKVtdXG4iLCJpbXBvcnQge1xuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0RHJhZnRlZCxcblx0SW1tZXIsXG5cdERSQUZUX1NUQVRFLFxuXHRJbW1lclN0YXRlLFxuXHRBcmNoVHlwZSxcblx0Z2V0UGx1Z2luXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbi8qKiBFYWNoIHNjb3BlIHJlcHJlc2VudHMgYSBgcHJvZHVjZWAgY2FsbC4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBJbW1lclNjb3BlIHtcblx0cGF0Y2hlc18/OiBQYXRjaFtdXG5cdGludmVyc2VQYXRjaGVzXz86IFBhdGNoW11cblx0Y2FuQXV0b0ZyZWV6ZV86IGJvb2xlYW5cblx0ZHJhZnRzXzogYW55W11cblx0cGFyZW50Xz86IEltbWVyU2NvcGVcblx0cGF0Y2hMaXN0ZW5lcl8/OiBQYXRjaExpc3RlbmVyXG5cdGltbWVyXzogSW1tZXJcblx0dW5maW5hbGl6ZWREcmFmdHNfOiBudW1iZXJcbn1cblxubGV0IGN1cnJlbnRTY29wZTogSW1tZXJTY29wZSB8IHVuZGVmaW5lZFxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuXHRyZXR1cm4gY3VycmVudFNjb3BlIVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTY29wZShcblx0cGFyZW50XzogSW1tZXJTY29wZSB8IHVuZGVmaW5lZCxcblx0aW1tZXJfOiBJbW1lclxuKTogSW1tZXJTY29wZSB7XG5cdHJldHVybiB7XG5cdFx0ZHJhZnRzXzogW10sXG5cdFx0cGFyZW50Xyxcblx0XHRpbW1lcl8sXG5cdFx0Ly8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuXHRcdC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG5cdFx0Y2FuQXV0b0ZyZWV6ZV86IHRydWUsXG5cdFx0dW5maW5hbGl6ZWREcmFmdHNfOiAwXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKFxuXHRzY29wZTogSW1tZXJTY29wZSxcblx0cGF0Y2hMaXN0ZW5lcj86IFBhdGNoTGlzdGVuZXJcbikge1xuXHRpZiAocGF0Y2hMaXN0ZW5lcikge1xuXHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikgLy8gYXNzZXJ0IHdlIGhhdmUgdGhlIHBsdWdpblxuXHRcdHNjb3BlLnBhdGNoZXNfID0gW11cblx0XHRzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXVxuXHRcdHNjb3BlLnBhdGNoTGlzdGVuZXJfID0gcGF0Y2hMaXN0ZW5lclxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZva2VTY29wZShzY29wZTogSW1tZXJTY29wZSkge1xuXHRsZWF2ZVNjb3BlKHNjb3BlKVxuXHRzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpXG5cdC8vIEB0cy1pZ25vcmVcblx0c2NvcGUuZHJhZnRzXyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGU6IEltbWVyU2NvcGUpIHtcblx0aWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcblx0XHRjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXI6IEltbWVyKSB7XG5cdHJldHVybiAoY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcikpXG59XG5cbmZ1bmN0aW9uIHJldm9rZURyYWZ0KGRyYWZ0OiBEcmFmdGVkKSB7XG5cdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdXG5cdGlmIChzdGF0ZS50eXBlXyA9PT0gQXJjaFR5cGUuT2JqZWN0IHx8IHN0YXRlLnR5cGVfID09PSBBcmNoVHlwZS5BcnJheSlcblx0XHRzdGF0ZS5yZXZva2VfKClcblx0ZWxzZSBzdGF0ZS5yZXZva2VkXyA9IHRydWVcbn1cbiIsImltcG9ydCB7XG5cdEltbWVyU2NvcGUsXG5cdERSQUZUX1NUQVRFLFxuXHRpc0RyYWZ0YWJsZSxcblx0Tk9USElORyxcblx0UGF0Y2hQYXRoLFxuXHRlYWNoLFxuXHRoYXMsXG5cdGZyZWV6ZSxcblx0SW1tZXJTdGF0ZSxcblx0aXNEcmFmdCxcblx0U2V0U3RhdGUsXG5cdHNldCxcblx0QXJjaFR5cGUsXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRyZXZva2VTY29wZSxcblx0aXNGcm96ZW5cbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0OiBhbnksIHNjb3BlOiBJbW1lclNjb3BlKSB7XG5cdHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoXG5cdGNvbnN0IGJhc2VEcmFmdCA9IHNjb3BlLmRyYWZ0c18hWzBdXG5cdGNvbnN0IGlzUmVwbGFjZWQgPSByZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGJhc2VEcmFmdFxuXHRpZiAoaXNSZXBsYWNlZCkge1xuXHRcdGlmIChiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLm1vZGlmaWVkXykge1xuXHRcdFx0cmV2b2tlU2NvcGUoc2NvcGUpXG5cdFx0XHRkaWUoNClcblx0XHR9XG5cdFx0aWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcblx0XHRcdC8vIEZpbmFsaXplIHRoZSByZXN1bHQgaW4gY2FzZSBpdCBjb250YWlucyAob3IgaXMpIGEgc3Vic2V0IG9mIHRoZSBkcmFmdC5cblx0XHRcdHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCByZXN1bHQpXG5cdFx0XHRpZiAoIXNjb3BlLnBhcmVudF8pIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQpXG5cdFx0fVxuXHRcdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG5cdFx0XHRcdGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sXG5cdFx0XHRcdHJlc3VsdCxcblx0XHRcdFx0c2NvcGUucGF0Y2hlc18sXG5cdFx0XHRcdHNjb3BlLmludmVyc2VQYXRjaGVzXyFcblx0XHRcdClcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRmluYWxpemUgdGhlIGJhc2UgZHJhZnQuXG5cdFx0cmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pXG5cdH1cblx0cmV2b2tlU2NvcGUoc2NvcGUpXG5cdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdHNjb3BlLnBhdGNoTGlzdGVuZXJfIShzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfISlcblx0fVxuXHRyZXR1cm4gcmVzdWx0ICE9PSBOT1RISU5HID8gcmVzdWx0IDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZTogSW1tZXJTY29wZSwgdmFsdWU6IGFueSwgcGF0aD86IFBhdGNoUGF0aCkge1xuXHQvLyBEb24ndCByZWN1cnNlIGluIHRobyByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzXG5cdGlmIChpc0Zyb3plbih2YWx1ZSkpIHJldHVybiB2YWx1ZVxuXG5cdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdXG5cdC8vIEEgcGxhaW4gb2JqZWN0LCBtaWdodCBuZWVkIGZyZWV6aW5nLCBtaWdodCBjb250YWluIGRyYWZ0c1xuXHRpZiAoIXN0YXRlKSB7XG5cdFx0ZWFjaCh2YWx1ZSwgKGtleSwgY2hpbGRWYWx1ZSkgPT5cblx0XHRcdGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aClcblx0XHQpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH1cblx0Ly8gTmV2ZXIgZmluYWxpemUgZHJhZnRzIG93bmVkIGJ5IGFub3RoZXIgc2NvcGUuXG5cdGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSkgcmV0dXJuIHZhbHVlXG5cdC8vIFVubW9kaWZpZWQgZHJhZnQsIHJldHVybiB0aGUgKGZyb3plbikgb3JpZ2luYWxcblx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKVxuXHRcdHJldHVybiBzdGF0ZS5iYXNlX1xuXHR9XG5cdC8vIE5vdCBmaW5hbGl6ZWQgeWV0LCBsZXQncyBkbyB0aGF0IG5vd1xuXHRpZiAoIXN0YXRlLmZpbmFsaXplZF8pIHtcblx0XHRzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZVxuXHRcdHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLVxuXHRcdGNvbnN0IHJlc3VsdCA9IHN0YXRlLmNvcHlfXG5cdFx0Ly8gRmluYWxpemUgYWxsIGNoaWxkcmVuIG9mIHRoZSBjb3B5XG5cdFx0Ly8gRm9yIHNldHMgd2UgY2xvbmUgYmVmb3JlIGl0ZXJhdGluZywgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW4gZW5kbGVzcyBsb29wIGR1ZSB0byBtb2RpZnlpbmcgZHVyaW5nIGl0ZXJhdGlvbiwgc2VlICM2Mjhcblx0XHQvLyBUbyBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgaW4gYWxsIGNhc2VzIHdlIHRoZW4gY2xlYXIgdGhlIHNldFxuXHRcdC8vIEFuZCB3ZSBsZXQgZmluYWxpemVQcm9wZXJ0eSBrbm93IGl0IG5lZWRzIHRvIHJlLWFkZCBub24tZHJhZnQgY2hpbGRyZW4gYmFjayB0byB0aGUgdGFyZ2V0XG5cdFx0bGV0IHJlc3VsdEVhY2ggPSByZXN1bHRcblx0XHRsZXQgaXNTZXQgPSBmYWxzZVxuXHRcdGlmIChzdGF0ZS50eXBlXyA9PT0gQXJjaFR5cGUuU2V0KSB7XG5cdFx0XHRyZXN1bHRFYWNoID0gbmV3IFNldChyZXN1bHQpXG5cdFx0XHRyZXN1bHQuY2xlYXIoKVxuXHRcdFx0aXNTZXQgPSB0cnVlXG5cdFx0fVxuXHRcdGVhY2gocmVzdWx0RWFjaCwgKGtleSwgY2hpbGRWYWx1ZSkgPT5cblx0XHRcdGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgcmVzdWx0LCBrZXksIGNoaWxkVmFsdWUsIHBhdGgsIGlzU2V0KVxuXHRcdClcblx0XHQvLyBldmVyeXRoaW5nIGluc2lkZSBpcyBmcm96ZW4sIHdlIGNhbiBmcmVlemUgaGVyZVxuXHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgcmVzdWx0LCBmYWxzZSlcblx0XHQvLyBmaXJzdCB0aW1lIGZpbmFsaXppbmcsIGxldCdzIGNyZWF0ZSB0aG9zZSBwYXRjaGVzXG5cdFx0aWYgKHBhdGggJiYgcm9vdFNjb3BlLnBhdGNoZXNfKSB7XG5cdFx0XHRnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRyb290U2NvcGUucGF0Y2hlc18sXG5cdFx0XHRcdHJvb3RTY29wZS5pbnZlcnNlUGF0Y2hlc18hXG5cdFx0XHQpXG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdGF0ZS5jb3B5X1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KFxuXHRyb290U2NvcGU6IEltbWVyU2NvcGUsXG5cdHBhcmVudFN0YXRlOiB1bmRlZmluZWQgfCBJbW1lclN0YXRlLFxuXHR0YXJnZXRPYmplY3Q6IGFueSxcblx0cHJvcDogc3RyaW5nIHwgbnVtYmVyLFxuXHRjaGlsZFZhbHVlOiBhbnksXG5cdHJvb3RQYXRoPzogUGF0Y2hQYXRoLFxuXHR0YXJnZXRJc1NldD86IGJvb2xlYW5cbikge1xuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNoaWxkVmFsdWUgPT09IHRhcmdldE9iamVjdClcblx0XHRkaWUoNSlcblx0aWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcblx0XHRjb25zdCBwYXRoID1cblx0XHRcdHJvb3RQYXRoICYmXG5cdFx0XHRwYXJlbnRTdGF0ZSAmJlxuXHRcdFx0cGFyZW50U3RhdGUhLnR5cGVfICE9PSBBcmNoVHlwZS5TZXQgJiYgLy8gU2V0IG9iamVjdHMgYXJlIGF0b21pYyBzaW5jZSB0aGV5IGhhdmUgbm8ga2V5cy5cblx0XHRcdCFoYXMoKHBhcmVudFN0YXRlIGFzIEV4Y2x1ZGU8SW1tZXJTdGF0ZSwgU2V0U3RhdGU+KS5hc3NpZ25lZF8hLCBwcm9wKSAvLyBTa2lwIGRlZXAgcGF0Y2hlcyBmb3IgYXNzaWduZWQga2V5cy5cblx0XHRcdFx0PyByb290UGF0aCEuY29uY2F0KHByb3ApXG5cdFx0XHRcdDogdW5kZWZpbmVkXG5cdFx0Ly8gRHJhZnRzIG93bmVkIGJ5IGBzY29wZWAgYXJlIGZpbmFsaXplZCBoZXJlLlxuXHRcdGNvbnN0IHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aClcblx0XHRzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpXG5cdFx0Ly8gRHJhZnRzIGZyb20gYW5vdGhlciBzY29wZSBtdXN0IHByZXZlbnRlZCB0byBiZSBmcm96ZW5cblx0XHQvLyBpZiB3ZSBnb3QgYSBkcmFmdCBiYWNrIGZyb20gZmluYWxpemUsIHdlJ3JlIGluIGEgbmVzdGVkIHByb2R1Y2UgYW5kIHNob3VsZG4ndCBmcmVlemVcblx0XHRpZiAoaXNEcmFmdChyZXMpKSB7XG5cdFx0XHRyb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZVxuXHRcdH0gZWxzZSByZXR1cm5cblx0fSBlbHNlIGlmICh0YXJnZXRJc1NldCkge1xuXHRcdHRhcmdldE9iamVjdC5hZGQoY2hpbGRWYWx1ZSlcblx0fVxuXHQvLyBTZWFyY2ggbmV3IG9iamVjdHMgZm9yIHVuZmluYWxpemVkIGRyYWZ0cy4gRnJvemVuIG9iamVjdHMgc2hvdWxkIG5ldmVyIGNvbnRhaW4gZHJhZnRzLlxuXHRpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XG5cdFx0aWYgKCFyb290U2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHJvb3RTY29wZS51bmZpbmFsaXplZERyYWZ0c18gPCAxKSB7XG5cdFx0XHQvLyBvcHRpbWl6YXRpb246IGlmIGFuIG9iamVjdCBpcyBub3QgYSBkcmFmdCwgYW5kIHdlIGRvbid0IGhhdmUgdG9cblx0XHRcdC8vIGRlZXBmcmVlemUgZXZlcnl0aGluZywgYW5kIHdlIGFyZSBzdXJlIHRoYXQgbm8gZHJhZnRzIGFyZSBsZWZ0IGluIHRoZSByZW1haW5pbmcgb2JqZWN0XG5cdFx0XHQvLyBjYXVzZSB3ZSBzYXcgYW5kIGZpbmFsaXplZCBhbGwgZHJhZnRzIGFscmVhZHk7IHdlIGNhbiBzdG9wIHZpc2l0aW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuXHRcdFx0Ly8gVGhpcyBiZW5lZml0cyBlc3BlY2lhbGx5IGFkZGluZyBsYXJnZSBkYXRhIHRyZWUncyB3aXRob3V0IGZ1cnRoZXIgcHJvY2Vzc2luZy5cblx0XHRcdC8vIFNlZSBhZGQtZGF0YS5qcyBwZXJmIHRlc3Rcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpXG5cdFx0Ly8gSW1tZXIgZGVlcCBmcmVlemVzIHBsYWluIG9iamVjdHMsIHNvIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBzdGF0ZSwgd2UgZnJlZXplIGFzIHdlbGxcblx0XHQvLyBQZXIgIzU5MCwgd2UgbmV2ZXIgZnJlZXplIHN5bWJvbGljIHByb3BlcnRpZXMuIEp1c3QgdG8gbWFrZSBzdXJlIGRvbid0IGFjY2lkZW50YWxseSBpbnRlcmZlcmVcblx0XHQvLyB3aXRoIG90aGVyIGZyYW1ld29ya3MuXG5cdFx0aWYgKFxuXHRcdFx0KCFwYXJlbnRTdGF0ZSB8fCAhcGFyZW50U3RhdGUuc2NvcGVfLnBhcmVudF8pICYmXG5cdFx0XHR0eXBlb2YgcHJvcCAhPT0gXCJzeW1ib2xcIiAmJlxuXHRcdFx0T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldE9iamVjdCwgcHJvcClcblx0XHQpXG5cdFx0XHRtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpXG5cdH1cbn1cblxuZnVuY3Rpb24gbWF5YmVGcmVlemUoc2NvcGU6IEltbWVyU2NvcGUsIHZhbHVlOiBhbnksIGRlZXAgPSBmYWxzZSkge1xuXHQvLyB3ZSBuZXZlciBmcmVlemUgZm9yIGEgbm9uLXJvb3Qgc2NvcGU7IGFzIGl0IHdvdWxkIHByZXZlbnQgcHJ1bmluZyBmb3IgZHJhZnRzIGluc2lkZSB3cmFwcGluZyBvYmplY3RzXG5cdGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcblx0XHRmcmVlemUodmFsdWUsIGRlZXApXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdGVhY2gsXG5cdGhhcyxcblx0aXMsXG5cdGlzRHJhZnRhYmxlLFxuXHRzaGFsbG93Q29weSxcblx0bGF0ZXN0LFxuXHRJbW1lckJhc2VTdGF0ZSxcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0QW55T2JqZWN0LFxuXHRBbnlBcnJheSxcblx0T2JqZWN0aXNoLFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdGdldFByb3RvdHlwZU9mLFxuXHREUkFGVF9TVEFURSxcblx0ZGllLFxuXHRjcmVhdGVQcm94eSxcblx0QXJjaFR5cGUsXG5cdEltbWVyU2NvcGVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuaW50ZXJmYWNlIFByb3h5QmFzZVN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHRhc3NpZ25lZF86IHtcblx0XHRbcHJvcGVydHk6IHN0cmluZ106IGJvb2xlYW5cblx0fVxuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRyZXZva2VfKCk6IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm94eU9iamVjdFN0YXRlIGV4dGVuZHMgUHJveHlCYXNlU3RhdGUge1xuXHR0eXBlXzogQXJjaFR5cGUuT2JqZWN0XG5cdGJhc2VfOiBhbnlcblx0Y29weV86IGFueVxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBQcm94eU9iamVjdFN0YXRlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5QXJyYXlTdGF0ZSBleHRlbmRzIFByb3h5QmFzZVN0YXRlIHtcblx0dHlwZV86IEFyY2hUeXBlLkFycmF5XG5cdGJhc2VfOiBBbnlBcnJheVxuXHRjb3B5XzogQW55QXJyYXkgfCBudWxsXG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlBcnJheSwgUHJveHlBcnJheVN0YXRlPlxufVxuXG50eXBlIFByb3h5U3RhdGUgPSBQcm94eU9iamVjdFN0YXRlIHwgUHJveHlBcnJheVN0YXRlXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBkcmFmdCBvZiB0aGUgYGJhc2VgIG9iamVjdC5cbiAqXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBwYXJlbnQgZHJhZnQtc3RhdGUgKHVzZWQgaW50ZXJuYWxseSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5PFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRiYXNlOiBULFxuXHRwYXJlbnQ/OiBJbW1lclN0YXRlXG4pOiBEcmFmdGVkPFQsIFByb3h5U3RhdGU+IHtcblx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSlcblx0Y29uc3Qgc3RhdGU6IFByb3h5U3RhdGUgPSB7XG5cdFx0dHlwZV86IGlzQXJyYXkgPyBBcmNoVHlwZS5BcnJheSA6IChBcmNoVHlwZS5PYmplY3QgYXMgYW55KSxcblx0XHQvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG5cdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuXHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0Ly8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuXHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG5cdFx0YXNzaWduZWRfOiB7fSxcblx0XHQvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuXHRcdHBhcmVudF86IHBhcmVudCxcblx0XHQvLyBUaGUgYmFzZSBzdGF0ZS5cblx0XHRiYXNlXzogYmFzZSxcblx0XHQvLyBUaGUgYmFzZSBwcm94eS5cblx0XHRkcmFmdF86IG51bGwgYXMgYW55LCAvLyBzZXQgYmVsb3dcblx0XHQvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuXHRcdGNvcHlfOiBudWxsLFxuXHRcdC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuXHRcdHJldm9rZV86IG51bGwgYXMgYW55LFxuXHRcdGlzTWFudWFsXzogZmFsc2Vcblx0fVxuXG5cdC8vIHRoZSB0cmFwcyBtdXN0IHRhcmdldCBzb21ldGhpbmcsIGEgYml0IGxpa2UgdGhlICdyZWFsJyBiYXNlLlxuXHQvLyBidXQgYWxzbywgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRldGVybWluZSBmcm9tIHRoZSB0YXJnZXQgd2hhdCB0aGUgcmVsZXZhbnQgc3RhdGUgaXNcblx0Ly8gKHRvIGF2b2lkIGNyZWF0aW5nIHRyYXBzIHBlciBpbnN0YW5jZSB0byBjYXB0dXJlIHRoZSBzdGF0ZSBpbiBjbG9zdXJlLFxuXHQvLyBhbmQgdG8gYXZvaWQgY3JlYXRpbmcgd2VpcmQgaGlkZGVuIHByb3BlcnRpZXMgYXMgd2VsbClcblx0Ly8gU28gdGhlIHRyaWNrIGlzIHRvIHVzZSAnc3RhdGUnIGFzIHRoZSBhY3R1YWwgJ3RhcmdldCchIChhbmQgbWFrZSBzdXJlIHdlIGludGVyY2VwdCBldmVyeXRoaW5nKVxuXHQvLyBOb3RlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXksIHdlIHB1dCB0aGUgc3RhdGUgaW4gYW4gYXJyYXkgdG8gaGF2ZSBiZXR0ZXIgUmVmbGVjdCBkZWZhdWx0cyBvb3RiXG5cdGxldCB0YXJnZXQ6IFQgPSBzdGF0ZSBhcyBhbnlcblx0bGV0IHRyYXBzOiBQcm94eUhhbmRsZXI8b2JqZWN0IHwgQXJyYXk8YW55Pj4gPSBvYmplY3RUcmFwc1xuXHRpZiAoaXNBcnJheSkge1xuXHRcdHRhcmdldCA9IFtzdGF0ZV0gYXMgYW55XG5cdFx0dHJhcHMgPSBhcnJheVRyYXBzXG5cdH1cblxuXHRjb25zdCB7cmV2b2tlLCBwcm94eX0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcylcblx0c3RhdGUuZHJhZnRfID0gcHJveHkgYXMgYW55XG5cdHN0YXRlLnJldm9rZV8gPSByZXZva2Vcblx0cmV0dXJuIHByb3h5IGFzIGFueVxufVxuXG4vKipcbiAqIE9iamVjdCBkcmFmdHNcbiAqL1xuZXhwb3J0IGNvbnN0IG9iamVjdFRyYXBzOiBQcm94eUhhbmRsZXI8UHJveHlTdGF0ZT4gPSB7XG5cdGdldChzdGF0ZSwgcHJvcCkge1xuXHRcdGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlXG5cblx0XHRjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpXG5cdFx0aWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuXHRcdFx0Ly8gbm9uLWV4aXN0aW5nIG9yIG5vbi1vd24gcHJvcGVydHkuLi5cblx0XHRcdHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKVxuXHRcdH1cblx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXVxuXHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0XHQvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXG5cdFx0Ly8gQXNzaWduZWQgdmFsdWVzIGFyZSBuZXZlciBkcmFmdGVkLiBUaGlzIGNhdGNoZXMgYW55IGRyYWZ0cyB3ZSBjcmVhdGVkLCB0b28uXG5cdFx0aWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gKHN0YXRlLmNvcHlfIVtwcm9wIGFzIGFueV0gPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpKVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblx0aGFzKHN0YXRlLCBwcm9wKSB7XG5cdFx0cmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKVxuXHR9LFxuXHRvd25LZXlzKHN0YXRlKSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKVxuXHR9LFxuXHRzZXQoXG5cdFx0c3RhdGU6IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0cHJvcDogc3RyaW5nIC8qIHN0cmljdGx5IG5vdCwgYnV0IGhlbHBzIFRTICovLFxuXHRcdHZhbHVlXG5cdCkge1xuXHRcdGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0aWYgKGRlc2M/LnNldCkge1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIHdyaXRlIGlzIGNhcHR1cmVkIGJ5IGEgc2V0dGVyLCB3ZSBoYXZlXG5cdFx0XHQvLyB0byB0cmlnZ2VyIGl0IHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuXHRcdFx0ZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdC8vIHRoZSBsYXN0IGNoZWNrIGlzIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIHNldHRpbmcgYSBub24tZXhpc3RpbmcgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBhIGNoYW5nZSlcblx0XHRcdC8vIGZyb20gc2V0dGluZyBhbiBleGlzdGluZyBwcm9wZXJ0eSB3aXRoIHZhbHVlIHVuZGVmaW5lZCB0byB1bmRlZmluZWQgKHdoaWNoIGlzIG5vdCBhIGNoYW5nZSlcblx0XHRcdGNvbnN0IGN1cnJlbnQgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UsIGlmIHdlIGFzc2lnbmluZyB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gYSBkcmFmdCwgd2UgY2FuIGlnbm9yZSB0aGUgYXNzaWdubWVudFxuXHRcdFx0Y29uc3QgY3VycmVudFN0YXRlOiBQcm94eU9iamVjdFN0YXRlID0gY3VycmVudD8uW0RSQUZUX1NUQVRFXVxuXHRcdFx0aWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHN0YXRlLmNvcHlfIVtwcm9wXSA9IHZhbHVlXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRpZiAoaXModmFsdWUsIGN1cnJlbnQpICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQoc3RhdGUuY29weV8hW3Byb3BdID09PSB2YWx1ZSAmJlxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSkgfHxcblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogTmFOXG5cdFx0XHQoTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV8hW3Byb3BdKSlcblx0XHQpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHN0YXRlLmNvcHlfIVtwcm9wXSA9IHZhbHVlXG5cdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZVxuXHRcdHJldHVybiB0cnVlXG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wOiBzdHJpbmcpIHtcblx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcblx0XHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlXG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBhbiBvcmlnaW5hbGx5IG5vdCBhc3NpZ25lZCBwcm9wZXJ0eSB3YXMgZGVsZXRlZFxuXHRcdFx0ZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXVxuXHRcdH1cblx0XHRpZiAoc3RhdGUuY29weV8pIHtcblx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZVxuXHR9LFxuXHQvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuXHQvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuXHRcdGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKVxuXHRcdGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcClcblx0XHRpZiAoIWRlc2MpIHJldHVybiBkZXNjXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gQXJjaFR5cGUuQXJyYXkgfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcblx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiBvd25lcltwcm9wXVxuXHRcdH1cblx0fSxcblx0ZGVmaW5lUHJvcGVydHkoKSB7XG5cdFx0ZGllKDExKVxuXHR9LFxuXHRnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuXHRcdHJldHVybiBnZXRQcm90b3R5cGVPZihzdGF0ZS5iYXNlXylcblx0fSxcblx0c2V0UHJvdG90eXBlT2YoKSB7XG5cdFx0ZGllKDEyKVxuXHR9XG59XG5cbi8qKlxuICogQXJyYXkgZHJhZnRzXG4gKi9cblxuY29uc3QgYXJyYXlUcmFwczogUHJveHlIYW5kbGVyPFtQcm94eUFycmF5U3RhdGVdPiA9IHt9XG5lYWNoKG9iamVjdFRyYXBzLCAoa2V5LCBmbikgPT4ge1xuXHQvLyBAdHMtaWdub3JlXG5cdGFycmF5VHJhcHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXVxuXHRcdHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdH1cbn0pXG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24oc3RhdGUsIHByb3ApIHtcblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc05hTihwYXJzZUludChwcm9wIGFzIGFueSkpKVxuXHRcdGRpZSgxMylcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gYXJyYXlUcmFwcy5zZXQhLmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHVuZGVmaW5lZClcbn1cbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHByb3AsIHZhbHVlKSB7XG5cdGlmIChcblx0XHRwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiZcblx0XHRwcm9wICE9PSBcImxlbmd0aFwiICYmXG5cdFx0aXNOYU4ocGFyc2VJbnQocHJvcCBhcyBhbnkpKVxuXHQpXG5cdFx0ZGllKDE0KVxuXHRyZXR1cm4gb2JqZWN0VHJhcHMuc2V0IS5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pXG59XG5cbi8vIEFjY2VzcyBhIHByb3BlcnR5IHdpdGhvdXQgY3JlYXRpbmcgYW4gSW1tZXIgZHJhZnQuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0OiBEcmFmdGVkLCBwcm9wOiBQcm9wZXJ0eUtleSkge1xuXHRjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXVxuXHRjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdFxuXHRyZXR1cm4gc291cmNlW3Byb3BdXG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlOiBJbW1lclN0YXRlLCBzb3VyY2U6IGFueSwgcHJvcDogUHJvcGVydHlLZXkpIHtcblx0Y29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKVxuXHRyZXR1cm4gZGVzY1xuXHRcdD8gYHZhbHVlYCBpbiBkZXNjXG5cdFx0XHQ/IGRlc2MudmFsdWVcblx0XHRcdDogLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuXHRcdFx0ICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcblx0XHRcdCAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxuXHRcdDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oXG5cdHNvdXJjZTogYW55LFxuXHRwcm9wOiBQcm9wZXJ0eUtleVxuKTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcblx0Ly8gJ2luJyBjaGVja3MgcHJvdG8hXG5cdGlmICghKHByb3AgaW4gc291cmNlKSkgcmV0dXJuIHVuZGVmaW5lZFxuXHRsZXQgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihzb3VyY2UpXG5cdHdoaWxlIChwcm90bykge1xuXHRcdGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKVxuXHRcdGlmIChkZXNjKSByZXR1cm4gZGVzY1xuXHRcdHByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pXG5cdH1cblx0cmV0dXJuIHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya0NoYW5nZWQoc3RhdGU6IEltbWVyU3RhdGUpIHtcblx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRzdGF0ZS5tb2RpZmllZF8gPSB0cnVlXG5cdFx0aWYgKHN0YXRlLnBhcmVudF8pIHtcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudF8pXG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZToge1xuXHRiYXNlXzogYW55XG5cdGNvcHlfOiBhbnlcblx0c2NvcGVfOiBJbW1lclNjb3BlXG59KSB7XG5cdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KFxuXHRcdFx0c3RhdGUuYmFzZV8sXG5cdFx0XHRzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5X1xuXHRcdClcblx0fVxufVxuIiwiaW1wb3J0IHtcblx0SVByb2R1Y2VXaXRoUGF0Y2hlcyxcblx0SVByb2R1Y2UsXG5cdEltbWVyU3RhdGUsXG5cdERyYWZ0ZWQsXG5cdGlzRHJhZnRhYmxlLFxuXHRwcm9jZXNzUmVzdWx0LFxuXHRQYXRjaCxcblx0T2JqZWN0aXNoLFxuXHREUkFGVF9TVEFURSxcblx0RHJhZnQsXG5cdFBhdGNoTGlzdGVuZXIsXG5cdGlzRHJhZnQsXG5cdGlzTWFwLFxuXHRpc1NldCxcblx0Y3JlYXRlUHJveHlQcm94eSxcblx0Z2V0UGx1Z2luLFxuXHRkaWUsXG5cdGVudGVyU2NvcGUsXG5cdHJldm9rZVNjb3BlLFxuXHRsZWF2ZVNjb3BlLFxuXHR1c2VQYXRjaGVzSW5TY29wZSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHROT1RISU5HLFxuXHRmcmVlemUsXG5cdGN1cnJlbnRcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuaW50ZXJmYWNlIFByb2R1Y2Vyc0ZucyB7XG5cdHByb2R1Y2U6IElQcm9kdWNlXG5cdHByb2R1Y2VXaXRoUGF0Y2hlczogSVByb2R1Y2VXaXRoUGF0Y2hlc1xufVxuXG5leHBvcnQgY2xhc3MgSW1tZXIgaW1wbGVtZW50cyBQcm9kdWNlcnNGbnMge1xuXHRhdXRvRnJlZXplXzogYm9vbGVhbiA9IHRydWVcblx0dXNlU3RyaWN0U2hhbGxvd0NvcHlfOiBib29sZWFuID0gZmFsc2VcblxuXHRjb25zdHJ1Y3Rvcihjb25maWc/OiB7YXV0b0ZyZWV6ZT86IGJvb2xlYW47IHVzZVN0cmljdFNoYWxsb3dDb3B5PzogYm9vbGVhbn0pIHtcblx0XHRpZiAodHlwZW9mIGNvbmZpZz8uYXV0b0ZyZWV6ZSA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHR0aGlzLnNldEF1dG9GcmVlemUoY29uZmlnIS5hdXRvRnJlZXplKVxuXHRcdGlmICh0eXBlb2YgY29uZmlnPy51c2VTdHJpY3RTaGFsbG93Q29weSA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHR0aGlzLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5KGNvbmZpZyEudXNlU3RyaWN0U2hhbGxvd0NvcHkpXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG5cdCAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xuXHQgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcblx0ICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0ICpcblx0ICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG5cdCAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG5cdCAqXG5cdCAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuXHQgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG5cdCAqXG5cdCAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG5cdCAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuXHQgKi9cblx0cHJvZHVjZTogSVByb2R1Y2UgPSAoYmFzZTogYW55LCByZWNpcGU/OiBhbnksIHBhdGNoTGlzdGVuZXI/OiBhbnkpID0+IHtcblx0XHQvLyBjdXJyaWVkIGludm9jYXRpb25cblx0XHRpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlXG5cdFx0XHRyZWNpcGUgPSBiYXNlXG5cblx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoXG5cdFx0XHRcdHRoaXM6IGFueSxcblx0XHRcdFx0YmFzZSA9IGRlZmF1bHRCYXNlLFxuXHRcdFx0XHQuLi5hcmdzOiBhbnlbXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZSwgKGRyYWZ0OiBEcmFmdGVkKSA9PiByZWNpcGUuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncykpIC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg2KVxuXHRcdGlmIChwYXRjaExpc3RlbmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcblx0XHRcdGRpZSg3KVxuXG5cdFx0bGV0IHJlc3VsdFxuXG5cdFx0Ly8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cdFx0aWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRcdGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdW5kZWZpbmVkKVxuXHRcdFx0bGV0IGhhc0Vycm9yID0gdHJ1ZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzdWx0ID0gcmVjaXBlKHByb3h5KVxuXHRcdFx0XHRoYXNFcnJvciA9IGZhbHNlXG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHQvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcblx0XHRcdFx0aWYgKGhhc0Vycm9yKSByZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0ZWxzZSBsZWF2ZVNjb3BlKHNjb3BlKVxuXHRcdFx0fVxuXHRcdFx0dXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpXG5cdFx0XHRyZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKVxuXHRcdH0gZWxzZSBpZiAoIWJhc2UgfHwgdHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHJlc3VsdCA9IHJlY2lwZShiYXNlKVxuXHRcdFx0aWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSByZXN1bHQgPSBiYXNlXG5cdFx0XHRpZiAocmVzdWx0ID09PSBOT1RISU5HKSByZXN1bHQgPSB1bmRlZmluZWRcblx0XHRcdGlmICh0aGlzLmF1dG9GcmVlemVfKSBmcmVlemUocmVzdWx0LCB0cnVlKVxuXHRcdFx0aWYgKHBhdGNoTGlzdGVuZXIpIHtcblx0XHRcdFx0Y29uc3QgcDogUGF0Y2hbXSA9IFtdXG5cdFx0XHRcdGNvbnN0IGlwOiBQYXRjaFtdID0gW11cblx0XHRcdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCBwLCBpcClcblx0XHRcdFx0cGF0Y2hMaXN0ZW5lcihwLCBpcClcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9IGVsc2UgZGllKDEsIGJhc2UpXG5cdH1cblxuXHRwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXMgPSAoYmFzZTogYW55LCByZWNpcGU/OiBhbnkpOiBhbnkgPT4ge1xuXHRcdC8vIGN1cnJpZWQgaW52b2NhdGlvblxuXHRcdGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gKHN0YXRlOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PlxuXHRcdFx0XHR0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0OiBhbnkpID0+IGJhc2UoZHJhZnQsIC4uLmFyZ3MpKVxuXHRcdH1cblxuXHRcdGxldCBwYXRjaGVzOiBQYXRjaFtdLCBpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIChwOiBQYXRjaFtdLCBpcDogUGF0Y2hbXSkgPT4ge1xuXHRcdFx0cGF0Y2hlcyA9IHBcblx0XHRcdGludmVyc2VQYXRjaGVzID0gaXBcblx0XHR9KVxuXHRcdHJldHVybiBbcmVzdWx0LCBwYXRjaGVzISwgaW52ZXJzZVBhdGNoZXMhXVxuXHR9XG5cblx0Y3JlYXRlRHJhZnQ8VCBleHRlbmRzIE9iamVjdGlzaD4oYmFzZTogVCk6IERyYWZ0PFQ+IHtcblx0XHRpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSBkaWUoOClcblx0XHRpZiAoaXNEcmFmdChiYXNlKSkgYmFzZSA9IGN1cnJlbnQoYmFzZSlcblx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGJhc2UsIHVuZGVmaW5lZClcblx0XHRwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZVxuXHRcdGxlYXZlU2NvcGUoc2NvcGUpXG5cdFx0cmV0dXJuIHByb3h5IGFzIGFueVxuXHR9XG5cblx0ZmluaXNoRHJhZnQ8RCBleHRlbmRzIERyYWZ0PGFueT4+KFxuXHRcdGRyYWZ0OiBELFxuXHRcdHBhdGNoTGlzdGVuZXI/OiBQYXRjaExpc3RlbmVyXG5cdCk6IEQgZXh0ZW5kcyBEcmFmdDxpbmZlciBUPiA/IFQgOiBuZXZlciB7XG5cdFx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSBkcmFmdCAmJiAoZHJhZnQgYXMgYW55KVtEUkFGVF9TVEFURV1cblx0XHRpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pIGRpZSg5KVxuXHRcdGNvbnN0IHtzY29wZV86IHNjb3BlfSA9IHN0YXRlXG5cdFx0dXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpXG5cdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHQodW5kZWZpbmVkLCBzY29wZSlcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXG5cdCAqL1xuXHRzZXRBdXRvRnJlZXplKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0dGhpcy5hdXRvRnJlZXplXyA9IHZhbHVlXG5cdH1cblxuXHQvKipcblx0ICogUGFzcyB0cnVlIHRvIGVuYWJsZSBzdHJpY3Qgc2hhbGxvdyBjb3B5LlxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0LCBpbW1lciBkb2VzIG5vdCBjb3B5IHRoZSBvYmplY3QgZGVzY3JpcHRvcnMgc3VjaCBhcyBnZXR0ZXIsIHNldHRlciBhbmQgbm9uLWVudW1yYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkodmFsdWU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IHZhbHVlXG5cdH1cblxuXHRhcHBseVBhdGNoZXM8VCBleHRlbmRzIE9iamVjdGlzaD4oYmFzZTogVCwgcGF0Y2hlczogUGF0Y2hbXSk6IFQge1xuXHRcdC8vIElmIGEgcGF0Y2ggcmVwbGFjZXMgdGhlIGVudGlyZSBzdGF0ZSwgdGFrZSB0aGF0IHJlcGxhY2VtZW50IGFzIGJhc2Vcblx0XHQvLyBiZWZvcmUgYXBwbHlpbmcgcGF0Y2hlc1xuXHRcdGxldCBpOiBudW1iZXJcblx0XHRmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBwYXRjaCA9IHBhdGNoZXNbaV1cblx0XHRcdGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcblx0XHRcdFx0YmFzZSA9IHBhdGNoLnZhbHVlXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHRoZXJlIHdhcyBhIHBhdGNoIHRoYXQgcmVwbGFjZWQgdGhlIGVudGlyZSBzdGF0ZSwgc3RhcnQgZnJvbSB0aGVcblx0XHQvLyBwYXRjaCBhZnRlciB0aGF0LlxuXHRcdGlmIChpID4gLTEpIHtcblx0XHRcdHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKVxuXHRcdH1cblxuXHRcdGNvbnN0IGFwcGx5UGF0Y2hlc0ltcGwgPSBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmFwcGx5UGF0Y2hlc19cblx0XHRpZiAoaXNEcmFmdChiYXNlKSkge1xuXHRcdFx0Ly8gTi5COiBuZXZlciBoaXRzIGlmIHNvbWUgcGF0Y2ggYSByZXBsYWNlbWVudCwgcGF0Y2hlcyBhcmUgbmV2ZXIgZHJhZnRzXG5cdFx0XHRyZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKVxuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UsIHByb2R1Y2UgYSBjb3B5IG9mIHRoZSBiYXNlIHN0YXRlLlxuXHRcdHJldHVybiB0aGlzLnByb2R1Y2UoYmFzZSwgKGRyYWZ0OiBEcmFmdGVkKSA9PlxuXHRcdFx0YXBwbHlQYXRjaGVzSW1wbChkcmFmdCwgcGF0Y2hlcylcblx0XHQpXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3h5PFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHR2YWx1ZTogVCxcblx0cGFyZW50PzogSW1tZXJTdGF0ZVxuKTogRHJhZnRlZDxULCBJbW1lclN0YXRlPiB7XG5cdC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxuXHRjb25zdCBkcmFmdDogRHJhZnRlZCA9IGlzTWFwKHZhbHVlKVxuXHRcdD8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KVxuXHRcdDogaXNTZXQodmFsdWUpXG5cdFx0PyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpXG5cdFx0OiBjcmVhdGVQcm94eVByb3h5KHZhbHVlLCBwYXJlbnQpXG5cblx0Y29uc3Qgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKClcblx0c2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KVxuXHRyZXR1cm4gZHJhZnRcbn1cbiIsImltcG9ydCB7XG5cdGRpZSxcblx0aXNEcmFmdCxcblx0c2hhbGxvd0NvcHksXG5cdGVhY2gsXG5cdERSQUZUX1NUQVRFLFxuXHRzZXQsXG5cdEltbWVyU3RhdGUsXG5cdGlzRHJhZnRhYmxlLFxuXHRpc0Zyb3plblxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogVGFrZXMgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIGRyYWZ0IGFuZCBmaW5hbGl6ZXMgaXQgKGJ1dCB3aXRob3V0IGZyZWV6aW5nKS4gVGhpcyBpcyBhIGdyZWF0IHV0aWxpdHkgdG8gcHJpbnQgdGhlIGN1cnJlbnQgc3RhdGUgZHVyaW5nIGRlYnVnZ2luZyAobm8gUHJveGllcyBpbiB0aGUgd2F5KS4gVGhlIG91dHB1dCBvZiBjdXJyZW50IGNhbiBhbHNvIGJlIHNhZmVseSBsZWFrZWQgb3V0c2lkZSB0aGUgcHJvZHVjZXIuICovXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudDxUPih2YWx1ZTogVCk6IFRcbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50KHZhbHVlOiBhbnkpOiBhbnkge1xuXHRpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMTAsIHZhbHVlKVxuXHRyZXR1cm4gY3VycmVudEltcGwodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlOiBhbnkpOiBhbnkge1xuXHRpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSB8fCBpc0Zyb3plbih2YWx1ZSkpIHJldHVybiB2YWx1ZVxuXHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSB8IHVuZGVmaW5lZCA9IHZhbHVlW0RSQUZUX1NUQVRFXVxuXHRsZXQgY29weTogYW55XG5cdGlmIChzdGF0ZSkge1xuXHRcdGlmICghc3RhdGUubW9kaWZpZWRfKSByZXR1cm4gc3RhdGUuYmFzZV9cblx0XHQvLyBPcHRpbWl6YXRpb246IGF2b2lkIGdlbmVyYXRpbmcgbmV3IGRyYWZ0cyBkdXJpbmcgY29weWluZ1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlXG5cdFx0Y29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5Xylcblx0fSBlbHNlIHtcblx0XHRjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHRydWUpXG5cdH1cblx0Ly8gcmVjdXJzZVxuXHRlYWNoKGNvcHksIChrZXksIGNoaWxkVmFsdWUpID0+IHtcblx0XHRzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSlcblx0fSlcblx0aWYgKHN0YXRlKSB7XG5cdFx0c3RhdGUuZmluYWxpemVkXyA9IGZhbHNlXG5cdH1cblx0cmV0dXJuIGNvcHlcbn1cbiIsImltcG9ydCB7aW1tZXJhYmxlfSBmcm9tIFwiLi4vaW1tZXJcIlxuaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdFNldFN0YXRlLFxuXHRQcm94eUFycmF5U3RhdGUsXG5cdE1hcFN0YXRlLFxuXHRQcm94eU9iamVjdFN0YXRlLFxuXHRQYXRjaFBhdGgsXG5cdGdldCxcblx0ZWFjaCxcblx0aGFzLFxuXHRnZXRBcmNodHlwZSxcblx0Z2V0UHJvdG90eXBlT2YsXG5cdGlzU2V0LFxuXHRpc01hcCxcblx0bG9hZFBsdWdpbixcblx0QXJjaFR5cGUsXG5cdGRpZSxcblx0aXNEcmFmdCxcblx0aXNEcmFmdGFibGUsXG5cdE5PVEhJTkcsXG5cdGVycm9yc1xufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcblx0Y29uc3QgZXJyb3JPZmZzZXQgPSAxNlxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdFx0ZXJyb3JzLnB1c2goXG5cdFx0XHQnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG5cdFx0XHRmdW5jdGlvbihvcDogc3RyaW5nKSB7XG5cdFx0XHRcdHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBvcFxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uKHBhdGg6IHN0cmluZykge1xuXHRcdFx0XHRyZXR1cm4gXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGhcblx0XHRcdH0sXG5cdFx0XHRcIlBhdGNoaW5nIHJlc2VydmVkIGF0dHJpYnV0ZXMgbGlrZSBfX3Byb3RvX18sIHByb3RvdHlwZSBhbmQgY29uc3RydWN0b3IgaXMgbm90IGFsbG93ZWRcIlxuXHRcdClcblx0fVxuXG5cdGNvbnN0IFJFUExBQ0UgPSBcInJlcGxhY2VcIlxuXHRjb25zdCBBREQgPSBcImFkZFwiXG5cdGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCJcblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNfKFxuXHRcdHN0YXRlOiBJbW1lclN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpOiB2b2lkIHtcblx0XHRzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG5cdFx0XHRjYXNlIEFyY2hUeXBlLk9iamVjdDpcblx0XHRcdGNhc2UgQXJjaFR5cGUuTWFwOlxuXHRcdFx0XHRyZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdGJhc2VQYXRoLFxuXHRcdFx0XHRcdHBhdGNoZXMsXG5cdFx0XHRcdFx0aW52ZXJzZVBhdGNoZXNcblx0XHRcdFx0KVxuXHRcdFx0Y2FzZSBBcmNoVHlwZS5BcnJheTpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpXG5cdFx0XHRjYXNlIEFyY2hUeXBlLlNldDpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRcdFx0XHQoc3RhdGUgYXMgYW55KSBhcyBTZXRTdGF0ZSxcblx0XHRcdFx0XHRiYXNlUGF0aCxcblx0XHRcdFx0XHRwYXRjaGVzLFxuXHRcdFx0XHRcdGludmVyc2VQYXRjaGVzXG5cdFx0XHRcdClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhcblx0XHRzdGF0ZTogUHJveHlBcnJheVN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpIHtcblx0XHRsZXQge2Jhc2VfLCBhc3NpZ25lZF99ID0gc3RhdGVcblx0XHRsZXQgY29weV8gPSBzdGF0ZS5jb3B5XyFcblxuXHRcdC8vIFJlZHVjZSBjb21wbGV4aXR5IGJ5IGVuc3VyaW5nIGBiYXNlYCBpcyBuZXZlciBsb25nZXIuXG5cdFx0aWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0O1tiYXNlXywgY29weV9dID0gW2NvcHlfLCBiYXNlX11cblx0XHRcdDtbcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXVxuXHRcdH1cblxuXHRcdC8vIFByb2Nlc3MgcmVwbGFjZWQgaW5kaWNlcy5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXNzaWduZWRfW2ldICYmIGNvcHlfW2ldICE9PSBiYXNlX1tpXSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0XHRvcDogUkVQTEFDRSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuXHRcdFx0XHRcdC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuXHRcdFx0XHRcdHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcblx0XHRcdFx0fSlcblx0XHRcdFx0aW52ZXJzZVBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoYmFzZV9baV0pXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJvY2VzcyBhZGRlZCBpbmRpY2VzLlxuXHRcdGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBjb3B5Xy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRvcDogQURELFxuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHQvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcblx0XHRcdFx0Ly8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG5cdFx0XHRcdHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcblx0XHRcdH0pXG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSBjb3B5Xy5sZW5ndGggLSAxOyBiYXNlXy5sZW5ndGggPD0gaTsgLS1pKSB7XG5cdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRvcDogUkVNT1ZFLFxuXHRcdFx0XHRwYXRoXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoaXMgaXMgdXNlZCBmb3IgYm90aCBNYXAgb2JqZWN0cyBhbmQgbm9ybWFsIG9iamVjdHMuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcblx0XHRzdGF0ZTogTWFwU3RhdGUgfCBQcm94eU9iamVjdFN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpIHtcblx0XHRjb25zdCB7YmFzZV8sIGNvcHlffSA9IHN0YXRlXG5cdFx0ZWFjaChzdGF0ZS5hc3NpZ25lZF8hLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XG5cdFx0XHRjb25zdCBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSlcblx0XHRcdGNvbnN0IHZhbHVlID0gZ2V0KGNvcHlfISwga2V5KVxuXHRcdFx0Y29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBRERcblx0XHRcdGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKSByZXR1cm5cblx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5IGFzIGFueSlcblx0XHRcdHBhdGNoZXMucHVzaChvcCA9PT0gUkVNT1ZFID8ge29wLCBwYXRofSA6IHtvcCwgcGF0aCwgdmFsdWV9KVxuXHRcdFx0aW52ZXJzZVBhdGNoZXMucHVzaChcblx0XHRcdFx0b3AgPT09IEFERFxuXHRcdFx0XHRcdD8ge29wOiBSRU1PVkUsIHBhdGh9XG5cdFx0XHRcdFx0OiBvcCA9PT0gUkVNT1ZFXG5cdFx0XHRcdFx0PyB7b3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSl9XG5cdFx0XHRcdFx0OiB7b3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpfVxuXHRcdFx0KVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoXG5cdFx0c3RhdGU6IFNldFN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpIHtcblx0XHRsZXQge2Jhc2VfLCBjb3B5X30gPSBzdGF0ZVxuXG5cdFx0bGV0IGkgPSAwXG5cdFx0YmFzZV8uZm9yRWFjaCgodmFsdWU6IGFueSkgPT4ge1xuXHRcdFx0aWYgKCFjb3B5XyEuaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0XHRvcDogUkVNT1ZFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdFx0aW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG5cdFx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRpKytcblx0XHR9KVxuXHRcdGkgPSAwXG5cdFx0Y29weV8hLmZvckVhY2goKHZhbHVlOiBhbnkpID0+IHtcblx0XHRcdGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0XHRvcDogQURELFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdFx0aW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG5cdFx0XHRcdFx0b3A6IFJFTU9WRSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRpKytcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdGJhc2VWYWx1ZTogYW55LFxuXHRcdHJlcGxhY2VtZW50OiBhbnksXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpOiB2b2lkIHtcblx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRwYXRoOiBbXSxcblx0XHRcdHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHVuZGVmaW5lZCA6IHJlcGxhY2VtZW50XG5cdFx0fSlcblx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcblx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0cGF0aDogW10sXG5cdFx0XHR2YWx1ZTogYmFzZVZhbHVlXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5UGF0Y2hlc188VD4oZHJhZnQ6IFQsIHBhdGNoZXM6IFBhdGNoW10pOiBUIHtcblx0XHRwYXRjaGVzLmZvckVhY2gocGF0Y2ggPT4ge1xuXHRcdFx0Y29uc3Qge3BhdGgsIG9wfSA9IHBhdGNoXG5cblx0XHRcdGxldCBiYXNlOiBhbnkgPSBkcmFmdFxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSlcblx0XHRcdFx0bGV0IHAgPSBwYXRoW2ldXG5cdFx0XHRcdGlmICh0eXBlb2YgcCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcCAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHAgPSBcIlwiICsgcFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VlICM3MzgsIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdChwYXJlbnRUeXBlID09PSBBcmNoVHlwZS5PYmplY3QgfHwgcGFyZW50VHlwZSA9PT0gQXJjaFR5cGUuQXJyYXkpICYmXG5cdFx0XHRcdFx0KHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuXHRcdFx0XHQpXG5cdFx0XHRcdFx0ZGllKGVycm9yT2Zmc2V0ICsgMylcblx0XHRcdFx0aWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgcCA9PT0gXCJwcm90b3R5cGVcIilcblx0XHRcdFx0XHRkaWUoZXJyb3JPZmZzZXQgKyAzKVxuXHRcdFx0XHRiYXNlID0gZ2V0KGJhc2UsIHApXG5cdFx0XHRcdGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikgZGllKGVycm9yT2Zmc2V0ICsgMiwgcGF0aC5qb2luKFwiL1wiKSlcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpIC8vIHVzZWQgdG8gY2xvbmUgcGF0Y2ggdG8gZW5zdXJlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZCwgc2VlICM0MTFcblx0XHRcdGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuXHRcdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0XHRjYXNlIFJFUExBQ0U6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2hUeXBlLk1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNoVHlwZS5TZXQ6XG5cdFx0XHRcdFx0XHRcdGRpZShlcnJvck9mZnNldClcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCdzIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0XHQvLyBpbiB0aGUgZm9sbG93aW5nIGFkZCBvciByZW1vdmUgb3BzLCB0aGUgdmFsdWUgZmllbGQgaW5zaWRlIHRoZSBwYXRjaCB3aWxsIGFsc28gYmUgbW9kaWZ5ZWRcblx0XHRcdFx0XHRcdFx0Ly8gc28gd2UgdXNlIHZhbHVlIGZyb20gdGhlIGNsb25lZCBwYXRjaFxuXHRcdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoYmFzZVtrZXldID0gdmFsdWUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIEFERDpcblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgQXJjaFR5cGUuQXJyYXk6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBrZXkgPT09IFwiLVwiXG5cdFx0XHRcdFx0XHRcdFx0PyBiYXNlLnB1c2godmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0OiBiYXNlLnNwbGljZShrZXkgYXMgYW55LCAwLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaFR5cGUuTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaFR5cGUuU2V0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5hZGQodmFsdWUpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBSRU1PVkU6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2hUeXBlLkFycmF5OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zcGxpY2Uoa2V5IGFzIGFueSwgMSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaFR5cGUuTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5kZWxldGUoa2V5KVxuXHRcdFx0XHRcdFx0Y2FzZSBBcmNoVHlwZS5TZXQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSlcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBkZWxldGUgYmFzZVtrZXldXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGRpZShlcnJvck9mZnNldCArIDEsIG9wKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRyZXR1cm4gZHJhZnRcblx0fVxuXG5cdC8vIG9wdGltaXplOiB0aGlzIGlzIHF1aXRlIGEgcGVyZm9ybWFuY2UgaGl0LCBjYW4gd2UgZGV0ZWN0IGludGVsbGlnZW50bHkgd2hlbiBpdCBpcyBuZWVkZWQ/XG5cdC8vIEUuZy4gYXV0by1kcmFmdCB3aGVuIG5ldyBvYmplY3RzIGZyb20gb3V0c2lkZSBhcmUgYXNzaWduZWQgYW5kIG1vZGlmaWVkP1xuXHQvLyAoU2VlIGZhaWxpbmcgdGVzdCB3aGVuIGRlZXBDbG9uZSBqdXN0IHJldHVybnMgb2JqKVxuXHRmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlPFQ+KG9iajogVCk6IFRcblx0ZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmo6IGFueSkge1xuXHRcdGlmICghaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuIG9ialxuXHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpXG5cdFx0aWYgKGlzTWFwKG9iaikpXG5cdFx0XHRyZXR1cm4gbmV3IE1hcChcblx0XHRcdFx0QXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuXHRcdFx0KVxuXHRcdGlmIChpc1NldChvYmopKSByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKVxuXHRcdGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2Yob2JqKSlcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSlcblx0XHRpZiAoaGFzKG9iaiwgaW1tZXJhYmxlKSkgY2xvbmVkW2ltbWVyYWJsZV0gPSBvYmpbaW1tZXJhYmxlXVxuXHRcdHJldHVybiBjbG9uZWRcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkPFQ+KG9iajogVCk6IFQge1xuXHRcdGlmIChpc0RyYWZ0KG9iaikpIHtcblx0XHRcdHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iailcblx0XHR9IGVsc2UgcmV0dXJuIG9ialxuXHR9XG5cblx0bG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xuXHRcdGFwcGx5UGF0Y2hlc18sXG5cdFx0Z2VuZXJhdGVQYXRjaGVzXyxcblx0XHRnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cblx0fSlcbn1cbiIsIi8vIHR5cGVzIG9ubHkhXG5pbXBvcnQge1xuXHRJbW1lclN0YXRlLFxuXHRBbnlNYXAsXG5cdEFueVNldCxcblx0TWFwU3RhdGUsXG5cdFNldFN0YXRlLFxuXHREUkFGVF9TVEFURSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHRsYXRlc3QsXG5cdGlzRHJhZnRhYmxlLFxuXHRjcmVhdGVQcm94eSxcblx0bG9hZFBsdWdpbixcblx0bWFya0NoYW5nZWQsXG5cdGRpZSxcblx0QXJjaFR5cGUsXG5cdGVhY2hcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcblx0Y2xhc3MgRHJhZnRNYXAgZXh0ZW5kcyBNYXAge1xuXHRcdFtEUkFGVF9TVEFURV06IE1hcFN0YXRlXG5cblx0XHRjb25zdHJ1Y3Rvcih0YXJnZXQ6IEFueU1hcCwgcGFyZW50PzogSW1tZXJTdGF0ZSkge1xuXHRcdFx0c3VwZXIoKVxuXHRcdFx0dGhpc1tEUkFGVF9TVEFURV0gPSB7XG5cdFx0XHRcdHR5cGVfOiBBcmNoVHlwZS5NYXAsXG5cdFx0XHRcdHBhcmVudF86IHBhcmVudCxcblx0XHRcdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdFx0XHRtb2RpZmllZF86IGZhbHNlLFxuXHRcdFx0XHRmaW5hbGl6ZWRfOiBmYWxzZSxcblx0XHRcdFx0Y29weV86IHVuZGVmaW5lZCxcblx0XHRcdFx0YXNzaWduZWRfOiB1bmRlZmluZWQsXG5cdFx0XHRcdGJhc2VfOiB0YXJnZXQsXG5cdFx0XHRcdGRyYWZ0XzogdGhpcyBhcyBhbnksXG5cdFx0XHRcdGlzTWFudWFsXzogZmFsc2UsXG5cdFx0XHRcdHJldm9rZWRfOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdldCBzaXplKCk6IG51bWJlciB7XG5cdFx0XHRyZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplXG5cdFx0fVxuXG5cdFx0aGFzKGtleTogYW55KTogYm9vbGVhbiB7XG5cdFx0XHRyZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KVxuXHRcdH1cblxuXHRcdHNldChrZXk6IGFueSwgdmFsdWU6IGFueSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRwcmVwYXJlTWFwQ29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgdHJ1ZSlcblx0XHRcdFx0c3RhdGUuY29weV8hLnNldChrZXksIHZhbHVlKVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIHRydWUpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdGRlbGV0ZShrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIGZhbHNlKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5kZWxldGUoa2V5KVxuXHRcdFx0fVxuXHRcdFx0c3RhdGUuY29weV8hLmRlbGV0ZShrZXkpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblxuXHRcdGNsZWFyKCkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcblx0XHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKClcblx0XHRcdFx0ZWFjaChzdGF0ZS5iYXNlXywga2V5ID0+IHtcblx0XHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIGZhbHNlKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuY2xlYXIoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvckVhY2goY2I6ICh2YWx1ZTogYW55LCBrZXk6IGFueSwgc2VsZjogYW55KSA9PiB2b2lkLCB0aGlzQXJnPzogYW55KSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0bGF0ZXN0KHN0YXRlKS5mb3JFYWNoKChfdmFsdWU6IGFueSwga2V5OiBhbnksIF9tYXA6IGFueSkgPT4ge1xuXHRcdFx0XHRjYi5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0KGtleSksIGtleSwgdGhpcylcblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0Z2V0KGtleTogYW55KTogYW55IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSlcblx0XHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAvLyBlaXRoZXIgYWxyZWFkeSBkcmFmdGVkIG9yIHJlYXNzaWduZWRcblx0XHRcdH1cblx0XHRcdC8vIGRlc3BpdGUgd2hhdCBpdCBsb29rcywgdGhpcyBjcmVhdGVzIGEgZHJhZnQgb25seSBvbmNlLCBzZWUgYWJvdmUgY29uZGl0aW9uXG5cdFx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSlcblx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0c3RhdGUuY29weV8hLnNldChrZXksIGRyYWZ0KVxuXHRcdFx0cmV0dXJuIGRyYWZ0XG5cdFx0fVxuXG5cdFx0a2V5cygpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpXG5cdFx0fVxuXG5cdFx0dmFsdWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcblx0XHRcdFx0bmV4dDogKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcblx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdGlmIChyLmRvbmUpIHJldHVybiByXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKVxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkb25lOiBmYWxzZSxcblx0XHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGFzIGFueVxuXHRcdH1cblxuXHRcdGVudHJpZXMoKTogSXRlcmFibGVJdGVyYXRvcjxbYW55LCBhbnldPiB7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy5lbnRyaWVzKCksXG5cdFx0XHRcdG5leHQ6ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRpZiAoci5kb25lKSByZXR1cm4gclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogZmFsc2UsXG5cdFx0XHRcdFx0XHR2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBhcyBhbnlcblx0XHR9XG5cblx0XHRbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRcdHJldHVybiB0aGlzLmVudHJpZXMoKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb3h5TWFwXzxUIGV4dGVuZHMgQW55TWFwPih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudClcblx0fVxuXG5cdGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlOiBNYXBTdGF0ZSkge1xuXHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdHN0YXRlLmFzc2lnbmVkXyA9IG5ldyBNYXAoKVxuXHRcdFx0c3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKVxuXHRcdH1cblx0fVxuXG5cdGNsYXNzIERyYWZ0U2V0IGV4dGVuZHMgU2V0IHtcblx0XHRbRFJBRlRfU1RBVEVdOiBTZXRTdGF0ZVxuXHRcdGNvbnN0cnVjdG9yKHRhcmdldDogQW55U2V0LCBwYXJlbnQ/OiBJbW1lclN0YXRlKSB7XG5cdFx0XHRzdXBlcigpXG5cdFx0XHR0aGlzW0RSQUZUX1NUQVRFXSA9IHtcblx0XHRcdFx0dHlwZV86IEFyY2hUeXBlLlNldCxcblx0XHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0XHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0XHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdFx0XHRjb3B5XzogdW5kZWZpbmVkLFxuXHRcdFx0XHRiYXNlXzogdGFyZ2V0LFxuXHRcdFx0XHRkcmFmdF86IHRoaXMsXG5cdFx0XHRcdGRyYWZ0c186IG5ldyBNYXAoKSxcblx0XHRcdFx0cmV2b2tlZF86IGZhbHNlLFxuXHRcdFx0XHRpc01hbnVhbF86IGZhbHNlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2V0IHNpemUoKTogbnVtYmVyIHtcblx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemVcblx0XHR9XG5cblx0XHRoYXModmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcblx0XHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdFx0cmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSlcblx0XHRcdH1cblx0XHRcdGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKSByZXR1cm4gdHJ1ZVxuXHRcdFx0aWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSlcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblxuXHRcdGFkZCh2YWx1ZTogYW55KTogYW55IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5hZGQodmFsdWUpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdGRlbGV0ZSh2YWx1ZTogYW55KTogYW55IHtcblx0XHRcdGlmICghdGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5kZWxldGUodmFsdWUpIHx8XG5cdFx0XHRcdChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSlcblx0XHRcdFx0XHQ/IHN0YXRlLmNvcHlfIS5kZWxldGUoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKVxuXHRcdFx0XHRcdDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2UpXG5cdFx0XHQpXG5cdFx0fVxuXG5cdFx0Y2xlYXIoKSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuXHRcdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5jbGVhcigpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFsdWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gc3RhdGUuY29weV8hLnZhbHVlcygpXG5cdFx0fVxuXG5cdFx0ZW50cmllcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFthbnksIGFueV0+IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdHJldHVybiBzdGF0ZS5jb3B5XyEuZW50cmllcygpXG5cdFx0fVxuXG5cdFx0a2V5cygpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzKClcblx0XHR9XG5cblx0XHRbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcygpXG5cdFx0fVxuXG5cdFx0Zm9yRWFjaChjYjogYW55LCB0aGlzQXJnPzogYW55KSB7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKClcblx0XHRcdGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KClcblx0XHRcdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0Y2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcylcblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHByb3h5U2V0XzxUIGV4dGVuZHMgQW55U2V0Pih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudClcblx0fVxuXG5cdGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlOiBTZXRTdGF0ZSkge1xuXHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdC8vIGNyZWF0ZSBkcmFmdHMgZm9yIGFsbCBlbnRyaWVzIHRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlclxuXHRcdFx0c3RhdGUuY29weV8gPSBuZXcgU2V0KClcblx0XHRcdHN0YXRlLmJhc2VfLmZvckVhY2godmFsdWUgPT4ge1xuXHRcdFx0XHRpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpXG5cdFx0XHRcdFx0c3RhdGUuZHJhZnRzXy5zZXQodmFsdWUsIGRyYWZ0KVxuXHRcdFx0XHRcdHN0YXRlLmNvcHlfIS5hZGQoZHJhZnQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdGUuY29weV8hLmFkZCh2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGU6IGFueSAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovKSB7XG5cdFx0aWYgKHN0YXRlLnJldm9rZWRfKSBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpXG5cdH1cblxuXHRsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHtwcm94eU1hcF8sIHByb3h5U2V0X30pXG59XG4iLCJpbXBvcnQge1xuXHRJUHJvZHVjZSxcblx0SVByb2R1Y2VXaXRoUGF0Y2hlcyxcblx0SW1tZXIsXG5cdERyYWZ0LFxuXHRJbW11dGFibGVcbn0gZnJvbSBcIi4vaW50ZXJuYWxcIlxuXG5leHBvcnQge1xuXHREcmFmdCxcblx0SW1tdXRhYmxlLFxuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0b3JpZ2luYWwsXG5cdGN1cnJlbnQsXG5cdGlzRHJhZnQsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HIGFzIG5vdGhpbmcsXG5cdERSQUZUQUJMRSBhcyBpbW1lcmFibGUsXG5cdGZyZWV6ZSxcblx0T2JqZWN0aXNoXG59IGZyb20gXCIuL2ludGVybmFsXCJcblxuY29uc3QgaW1tZXIgPSBuZXcgSW1tZXIoKVxuXG4vKipcbiAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXG4gKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG4gKlxuICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuICpcbiAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y2U6IElQcm9kdWNlID0gaW1tZXIucHJvZHVjZVxuXG4vKipcbiAqIExpa2UgYHByb2R1Y2VgLCBidXQgYHByb2R1Y2VXaXRoUGF0Y2hlc2AgYWx3YXlzIHJldHVybnMgYSB0dXBsZVxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXMgPSBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcblx0aW1tZXJcbilcblxuLyoqXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuICpcbiAqIEFsd2F5cyBmcmVlemUgYnkgZGVmYXVsdCwgZXZlbiBpbiBwcm9kdWN0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF1dG9GcmVlemUgPSBpbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpXG5cbi8qKlxuICogUGFzcyB0cnVlIHRvIGVuYWJsZSBzdHJpY3Qgc2hhbGxvdyBjb3B5LlxuICpcbiAqIEJ5IGRlZmF1bHQsIGltbWVyIGRvZXMgbm90IGNvcHkgdGhlIG9iamVjdCBkZXNjcmlwdG9ycyBzdWNoIGFzIGdldHRlciwgc2V0dGVyIGFuZCBub24tZW51bXJhYmxlIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSA9IGltbWVyLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5LmJpbmQoaW1tZXIpXG5cbi8qKlxuICogQXBwbHkgYW4gYXJyYXkgb2YgSW1tZXIgcGF0Y2hlcyB0byB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHByb2R1Y2VyLCB3aGljaCBtZWFucyBjb3B5LW9uLXdyaXRlIGlzIGluIGVmZmVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5UGF0Y2hlcyA9IGltbWVyLmFwcGx5UGF0Y2hlcy5iaW5kKGltbWVyKVxuXG4vKipcbiAqIENyZWF0ZSBhbiBJbW1lciBkcmFmdCBmcm9tIHRoZSBnaXZlbiBiYXNlIHN0YXRlLCB3aGljaCBtYXkgYmUgYSBkcmFmdCBpdHNlbGYuXG4gKiBUaGUgZHJhZnQgY2FuIGJlIG1vZGlmaWVkIHVudGlsIHlvdSBmaW5hbGl6ZSBpdCB3aXRoIHRoZSBgZmluaXNoRHJhZnRgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRHJhZnQgPSBpbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKVxuXG4vKipcbiAqIEZpbmFsaXplIGFuIEltbWVyIGRyYWZ0IGZyb20gYSBgY3JlYXRlRHJhZnRgIGNhbGwsIHJldHVybmluZyB0aGUgYmFzZSBzdGF0ZVxuICogKGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlKSBvciBhIG1vZGlmaWVkIGNvcHkuIFRoZSBkcmFmdCBtdXN0ICpub3QqIGJlXG4gKiBtdXRhdGVkIGFmdGVyd2FyZHMuXG4gKlxuICogUGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSAybmQgYXJndW1lbnQgdG8gZ2VuZXJhdGUgSW1tZXIgcGF0Y2hlcyBiYXNlZCBvbiB0aGVcbiAqIGNoYW5nZXMgdGhhdCB3ZXJlIG1hZGUuXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5pc2hEcmFmdCA9IGltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxuICogdG8gYW4gZHJhZnQgdHlwZSBhbmQgbWFrZSBUeXBlU2NyaXB0IGhhcHB5XG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXN0RHJhZnQ8VD4odmFsdWU6IFQpOiBEcmFmdDxUPiB7XG5cdHJldHVybiB2YWx1ZSBhcyBhbnlcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGEgbXV0YWJsZSB0eXBlXG4gKiB0byBhbiBpbW11dGFibGUgdHlwZSBhbmQgbWFrZSBUeXBlU2NyaXB0IGhhcHB5XG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RJbW11dGFibGU8VD4odmFsdWU6IFQpOiBJbW11dGFibGU8VD4ge1xuXHRyZXR1cm4gdmFsdWUgYXMgYW55XG59XG5cbmV4cG9ydCB7SW1tZXJ9XG5cbmV4cG9ydCB7ZW5hYmxlUGF0Y2hlc30gZnJvbSBcIi4vcGx1Z2lucy9wYXRjaGVzXCJcbmV4cG9ydCB7ZW5hYmxlTWFwU2V0fSBmcm9tIFwiLi9wbHVnaW5zL21hcHNldFwiXG4iLCJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL2Rldk1vZGVDaGVja3MvaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnRzXG52YXIgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKHJlc3VsdEZ1bmMsIGlucHV0U2VsZWN0b3JzUmVzdWx0cywgb3V0cHV0U2VsZWN0b3JSZXN1bHQpID0+IHtcbiAgaWYgKGlucHV0U2VsZWN0b3JzUmVzdWx0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRTZWxlY3RvcnNSZXN1bHRzWzBdID09PSBvdXRwdXRTZWxlY3RvclJlc3VsdCkge1xuICAgIGxldCBpc0lucHV0U2FtZUFzT3V0cHV0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG4gICAgICBpZiAocmVzdWx0RnVuYyhlbXB0eU9iamVjdCkgPT09IGVtcHR5T2JqZWN0KVxuICAgICAgICBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIGlmIChpc0lucHV0U2FtZUFzT3V0cHV0KSB7XG4gICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgO1xuICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlIHJlc3VsdCBmdW5jdGlvbiByZXR1cm5lZCBpdHMgb3duIGlucHV0cyB3aXRob3V0IG1vZGlmaWNhdGlvbi4gZS5nXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvc10sIHRvZG9zID0+IHRvZG9zKWBcXG5UaGlzIGNvdWxkIGxlYWQgdG8gaW5lZmZpY2llbnQgbWVtb2l6YXRpb24gYW5kIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMuXFxuRW5zdXJlIHRyYW5zZm9ybWF0aW9uIGxvZ2ljIGlzIGluIHRoZSByZXN1bHQgZnVuY3Rpb24sIGFuZCBleHRyYWN0aW9uIGxvZ2ljIGlzIGluIHRoZSBpbnB1dCBzZWxlY3RvcnMuXCIsXG4gICAgICAgIHsgc3RhY2sgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9kZXZNb2RlQ2hlY2tzL2lucHV0U3RhYmlsaXR5Q2hlY2sudHNcbnZhciBydW5JbnB1dFN0YWJpbGl0eUNoZWNrID0gKGlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0LCBvcHRpb25zLCBpbnB1dFNlbGVjdG9yQXJncykgPT4ge1xuICBjb25zdCB7IG1lbW9pemUsIG1lbW9pemVPcHRpb25zIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IGlucHV0U2VsZWN0b3JSZXN1bHRzLCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgfSA9IGlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0O1xuICBjb25zdCBjcmVhdGVBbkVtcHR5T2JqZWN0ID0gbWVtb2l6ZSgoKSA9PiAoe30pLCAuLi5tZW1vaXplT3B0aW9ucyk7XG4gIGNvbnN0IGFyZUlucHV0U2VsZWN0b3JSZXN1bHRzRXF1YWwgPSBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzKSA9PT0gY3JlYXRlQW5FbXB0eU9iamVjdC5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkpO1xuICBpZiAoIWFyZUlucHV0U2VsZWN0b3JSZXN1bHRzRXF1YWwpIHtcbiAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIDtcbiAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJBbiBpbnB1dCBzZWxlY3RvciByZXR1cm5lZCBhIGRpZmZlcmVudCByZXN1bHQgd2hlbiBwYXNzZWQgc2FtZSBhcmd1bWVudHMuXFxuVGhpcyBtZWFucyB5b3VyIG91dHB1dCBzZWxlY3RvciB3aWxsIGxpa2VseSBydW4gbW9yZSBmcmVxdWVudGx5IHRoYW4gaW50ZW5kZWQuXFxuQXZvaWQgcmV0dXJuaW5nIGEgbmV3IHJlZmVyZW5jZSBpbnNpZGUgeW91ciBpbnB1dCBzZWxlY3RvciwgZS5nLlxcbmBjcmVhdGVTZWxlY3Rvcihbc3RhdGUgPT4gc3RhdGUudG9kb3MubWFwKHRvZG8gPT4gdG9kby5pZCldLCB0b2RvSWRzID0+IHRvZG9JZHMubGVuZ3RoKWBcIixcbiAgICAgIHtcbiAgICAgICAgYXJndW1lbnRzOiBpbnB1dFNlbGVjdG9yQXJncyxcbiAgICAgICAgZmlyc3RJbnB1dHM6IGlucHV0U2VsZWN0b3JSZXN1bHRzLFxuICAgICAgICBzZWNvbmRJbnB1dHM6IGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSxcbiAgICAgICAgc3RhY2tcbiAgICAgIH1cbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvZGV2TW9kZUNoZWNrcy9zZXRHbG9iYWxEZXZNb2RlQ2hlY2tzLnRzXG52YXIgZ2xvYmFsRGV2TW9kZUNoZWNrcyA9IHtcbiAgaW5wdXRTdGFiaWxpdHlDaGVjazogXCJvbmNlXCIsXG4gIGlkZW50aXR5RnVuY3Rpb25DaGVjazogXCJvbmNlXCJcbn07XG52YXIgc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyA9IChkZXZNb2RlQ2hlY2tzKSA9PiB7XG4gIE9iamVjdC5hc3NpZ24oZ2xvYmFsRGV2TW9kZUNoZWNrcywgZGV2TW9kZUNoZWNrcyk7XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBOT1RfRk9VTkQgPSBcIk5PVF9GT1VORFwiO1xuZnVuY3Rpb24gYXNzZXJ0SXNGdW5jdGlvbihmdW5jLCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAke3R5cGVvZiBmdW5jfWApIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzT2JqZWN0KG9iamVjdCwgZXJyb3JNZXNzYWdlID0gYGV4cGVjdGVkIGFuIG9iamVjdCwgaW5zdGVhZCByZWNlaXZlZCAke3R5cGVvZiBvYmplY3R9YCkge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNBcnJheU9mRnVuY3Rpb25zKGFycmF5LCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYWxsIGl0ZW1zIHRvIGJlIGZ1bmN0aW9ucywgaW5zdGVhZCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBgKSB7XG4gIGlmICghYXJyYXkuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgY29uc3QgaXRlbVR5cGVzID0gYXJyYXkubWFwKFxuICAgICAgKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgPyBgZnVuY3Rpb24gJHtpdGVtLm5hbWUgfHwgXCJ1bm5hbWVkXCJ9KClgIDogdHlwZW9mIGl0ZW1cbiAgICApLmpvaW4oXCIsIFwiKTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2Vycm9yTWVzc2FnZX1bJHtpdGVtVHlwZXN9XWApO1xuICB9XG59XG52YXIgZW5zdXJlSXNBcnJheSA9IChpdGVtKSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXTtcbn07XG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY3JlYXRlU2VsZWN0b3JBcmdzKSB7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoY3JlYXRlU2VsZWN0b3JBcmdzWzBdKSA/IGNyZWF0ZVNlbGVjdG9yQXJnc1swXSA6IGNyZWF0ZVNlbGVjdG9yQXJncztcbiAgYXNzZXJ0SXNBcnJheU9mRnVuY3Rpb25zKFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBgY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbGwgaW5wdXQtc2VsZWN0b3JzIHRvIGJlIGZ1bmN0aW9ucywgYnV0IHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGBcbiAgKTtcbiAgcmV0dXJuIGRlcGVuZGVuY2llcztcbn1cbmZ1bmN0aW9uIGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhkZXBlbmRlbmNpZXMsIGlucHV0U2VsZWN0b3JBcmdzKSB7XG4gIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gW107XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBkZXBlbmRlbmNpZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cy5wdXNoKGRlcGVuZGVuY2llc1tpXS5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yQXJncykpO1xuICB9XG4gIHJldHVybiBpbnB1dFNlbGVjdG9yUmVzdWx0cztcbn1cbnZhciBnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mbyA9IChmaXJzdFJ1biwgZGV2TW9kZUNoZWNrcykgPT4ge1xuICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgaW5wdXRTdGFiaWxpdHlDaGVjayB9ID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdsb2JhbERldk1vZGVDaGVja3MpLCBkZXZNb2RlQ2hlY2tzKTtcbiAgcmV0dXJuIHtcbiAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjogaWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4sXG4gICAgICBydW46IHJ1bklkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH0sXG4gICAgaW5wdXRTdGFiaWxpdHlDaGVjazoge1xuICAgICAgc2hvdWxkUnVuOiBpbnB1dFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGlucHV0U3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLFxuICAgICAgcnVuOiBydW5JbnB1dFN0YWJpbGl0eUNoZWNrXG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2F1dG90cmFja01lbW9pemUvYXV0b3RyYWNraW5nLnRzXG52YXIgJFJFVklTSU9OID0gMDtcbnZhciBDVVJSRU5UX1RSQUNLRVIgPSBudWxsO1xudmFyIENlbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJldmlzaW9uXCIsICRSRVZJU0lPTik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl92YWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2xhc3RWYWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2lzRXF1YWxcIiwgdHJpcGxlRXEpO1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2lzRXF1YWwgPSBpc0VxdWFsO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyByZWFkLCBpdCdsbCBhZGQgaXRzZWxmIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIgaWZcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxuICBnZXQgdmFsdWUoKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSID09IG51bGwgPyB2b2lkIDAgOiBDVVJSRU5UX1RSQUNLRVIuYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICAvLyBXaGVuZXZlciBhIHN0b3JhZ2UgdmFsdWUgaXMgdXBkYXRlZCwgd2UgYnVtcCB0aGUgZ2xvYmFsIHJldmlzaW9uIGNsb2NrLFxuICAvLyBhc3NpZ24gdGhlIHJldmlzaW9uIGZvciB0aGlzIHN0b3JhZ2UgdG8gdGhlIG5ldyB2YWx1ZSwgX2FuZF8gd2Ugc2NoZWR1bGUgYVxuICAvLyByZXJlbmRlci4gVGhpcyBpcyBpbXBvcnRhbnQsIGFuZCBpdCdzIHdoYXQgbWFrZXMgYXV0b3RyYWNraW5nICBfcHVsbF9cbiAgLy8gYmFzZWQuIFdlIGRvbid0IGFjdGl2ZWx5IHRlbGwgdGhlIGNhY2hlcyB3aGljaCBkZXBlbmQgb24gdGhlIHN0b3JhZ2UgdGhhdFxuICAvLyBhbnl0aGluZyBoYXMgaGFwcGVuZWQuIEluc3RlYWQsIHdlIHJlY29tcHV0ZSB0aGUgY2FjaGVzIHdoZW4gbmVlZGVkLlxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gbmV3VmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnJldmlzaW9uID0gKyskUkVWSVNJT047XG4gIH1cbn07XG5mdW5jdGlvbiB0cmlwbGVFcShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIFRyYWNraW5nQ2FjaGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jYWNoZWRWYWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NhY2hlZFJldmlzaW9uXCIsIC0xKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2RlcHNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoaXRzXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmblwiKTtcbiAgICB0aGlzLmZuID0gZm47XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2FjaGVkVmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5fY2FjaGVkUmV2aXNpb24gPSAtMTtcbiAgICB0aGlzLl9kZXBzID0gW107XG4gICAgdGhpcy5oaXRzID0gMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKHRoaXMucmV2aXNpb24gPiB0aGlzLl9jYWNoZWRSZXZpc2lvbikge1xuICAgICAgY29uc3QgeyBmbiB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFja2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IHByZXZUcmFja2VyID0gQ1VSUkVOVF9UUkFDS0VSO1xuICAgICAgQ1VSUkVOVF9UUkFDS0VSID0gY3VycmVudFRyYWNrZXI7XG4gICAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IGZuKCk7XG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBwcmV2VHJhY2tlcjtcbiAgICAgIHRoaXMuaGl0cysrO1xuICAgICAgdGhpcy5fZGVwcyA9IEFycmF5LmZyb20oY3VycmVudFRyYWNrZXIpO1xuICAgICAgdGhpcy5fY2FjaGVkUmV2aXNpb24gPSB0aGlzLnJldmlzaW9uO1xuICAgIH1cbiAgICBDVVJSRU5UX1RSQUNLRVIgPT0gbnVsbCA/IHZvaWQgMCA6IENVUlJFTlRfVFJBQ0tFUi5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFZhbHVlO1xuICB9XG4gIGdldCByZXZpc2lvbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4udGhpcy5fZGVwcy5tYXAoKGQpID0+IGQucmV2aXNpb24pLCAwKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFZhbHVlKGNlbGwpIHtcbiAgaWYgKCEoY2VsbCBpbnN0YW5jZW9mIENlbGwpKSB7XG4gICAgY29uc29sZS53YXJuKFwiTm90IGEgdmFsaWQgY2VsbCEgXCIsIGNlbGwpO1xuICB9XG4gIHJldHVybiBjZWxsLnZhbHVlO1xufVxuZnVuY3Rpb24gc2V0VmFsdWUoc3RvcmFnZSwgdmFsdWUpIHtcbiAgaWYgKCEoc3RvcmFnZSBpbnN0YW5jZW9mIENlbGwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwic2V0VmFsdWUgbXVzdCBiZSBwYXNzZWQgYSB0cmFja2VkIHN0b3JlIGNyZWF0ZWQgd2l0aCBgY3JlYXRlU3RvcmFnZWAuXCJcbiAgICApO1xuICB9XG4gIHN0b3JhZ2UudmFsdWUgPSBzdG9yYWdlLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNlbGwoaW5pdGlhbFZhbHVlLCBpc0VxdWFsID0gdHJpcGxlRXEpIHtcbiAgcmV0dXJuIG5ldyBDZWxsKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZShmbikge1xuICBhc3NlcnRJc0Z1bmN0aW9uKFxuICAgIGZuLFxuICAgIFwidGhlIGZpcnN0IHBhcmFtZXRlciB0byBgY3JlYXRlQ2FjaGVgIG11c3QgYmUgYSBmdW5jdGlvblwiXG4gICk7XG4gIHJldHVybiBuZXcgVHJhY2tpbmdDYWNoZShmbik7XG59XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL3RyYWNraW5nLnRzXG52YXIgbmV2ZXJFcSA9IChhLCBiKSA9PiBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVRhZygpIHtcbiAgcmV0dXJuIGNyZWF0ZUNlbGwobnVsbCwgbmV2ZXJFcSk7XG59XG5mdW5jdGlvbiBkaXJ0eVRhZyh0YWcsIHZhbHVlKSB7XG4gIHNldFZhbHVlKHRhZywgdmFsdWUpO1xufVxudmFyIGNvbnN1bWVDb2xsZWN0aW9uID0gKG5vZGUpID0+IHtcbiAgbGV0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZztcbiAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgIHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZyA9IGNyZWF0ZVRhZygpO1xuICB9XG4gIGdldFZhbHVlKHRhZyk7XG59O1xudmFyIGRpcnR5Q29sbGVjdGlvbiA9IChub2RlKSA9PiB7XG4gIGNvbnN0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZztcbiAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgIGRpcnR5VGFnKHRhZywgbnVsbCk7XG4gIH1cbn07XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL3Byb3h5LnRzXG52YXIgUkVEVVhfUFJPWFlfTEFCRUwgPSBTeW1ib2woKTtcbnZhciBuZXh0SWQgPSAwO1xudmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbnZhciBPYmplY3RUcmVlTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb3h5XCIsIG5ldyBQcm94eSh0aGlzLCBvYmplY3RQcm94eUhhbmRsZXIpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFnXCIsIGNyZWF0ZVRhZygpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFnc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNoaWxkcmVuXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29sbGVjdGlvblRhZ1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRcIiwgbmV4dElkKyspO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG59O1xudmFyIG9iamVjdFByb3h5SGFuZGxlciA9IHtcbiAgZ2V0KG5vZGUsIGtleSkge1xuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVJlc3VsdCgpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgICBjb25zdCBjaGlsZFZhbHVlID0gUmVmbGVjdC5nZXQodmFsdWUsIGtleSk7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgaW4gcHJvdG8pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgY2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldO1xuICAgICAgICBpZiAoY2hpbGROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmNoaWxkcmVuW2tleV0gPSBjcmVhdGVOb2RlKGNoaWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGUudGFnKSB7XG4gICAgICAgICAgZ2V0VmFsdWUoY2hpbGROb2RlLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5wcm94eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YWcgPSBub2RlLnRhZ3Nba2V5XTtcbiAgICAgICAgaWYgKHRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGFnID0gbm9kZS50YWdzW2tleV0gPSBjcmVhdGVUYWcoKTtcbiAgICAgICAgICB0YWcudmFsdWUgPSBjaGlsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKHRhZyk7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBjYWxjdWxhdGVSZXN1bHQoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBvd25LZXlzKG5vZGUpIHtcbiAgICBjb25zdW1lQ29sbGVjdGlvbihub2RlKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKG5vZGUudmFsdWUpO1xuICB9LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZSwgcHJvcCkge1xuICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLnZhbHVlLCBwcm9wKTtcbiAgfSxcbiAgaGFzKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gUmVmbGVjdC5oYXMobm9kZS52YWx1ZSwgcHJvcCk7XG4gIH1cbn07XG52YXIgQXJyYXlUcmVlTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb3h5XCIsIG5ldyBQcm94eShbdGhpc10sIGFycmF5UHJveHlIYW5kbGVyKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhZ1wiLCBjcmVhdGVUYWcoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhZ3NcIiwge30pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjaGlsZHJlblwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbGxlY3Rpb25UYWdcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIsIG5leHRJZCsrKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy50YWcudmFsdWUgPSB2YWx1ZTtcbiAgfVxufTtcbnZhciBhcnJheVByb3h5SGFuZGxlciA9IHtcbiAgZ2V0KFtub2RlXSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0KG5vZGUsIGtleSk7XG4gIH0sXG4gIG93bktleXMoW25vZGVdKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5vd25LZXlzKG5vZGUpO1xuICB9LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoW25vZGVdLCBwcm9wKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZSwgcHJvcCk7XG4gIH0sXG4gIGhhcyhbbm9kZV0sIHByb3ApIHtcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmhhcyhub2RlLCBwcm9wKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheVRyZWVOb2RlKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IE9iamVjdFRyZWVOb2RlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUobm9kZSwgbmV3VmFsdWUpIHtcbiAgY29uc3QgeyB2YWx1ZSwgdGFncywgY2hpbGRyZW4gfSA9IG5vZGU7XG4gIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkobmV3VmFsdWUpICYmIHZhbHVlLmxlbmd0aCAhPT0gbmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGxldCBvbGRLZXlzU2l6ZSA9IDA7XG4gICAgICBsZXQgbmV3S2V5c1NpemUgPSAwO1xuICAgICAgbGV0IGFueUtleXNBZGRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBfa2V5IGluIHZhbHVlKSB7XG4gICAgICAgIG9sZEtleXNTaXplKys7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdWYWx1ZSkge1xuICAgICAgICBuZXdLZXlzU2l6ZSsrO1xuICAgICAgICBpZiAoIShrZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgYW55S2V5c0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaXNEaWZmZXJlbnQgPSBhbnlLZXlzQWRkZWQgfHwgb2xkS2V5c1NpemUgIT09IG5ld0tleXNTaXplO1xuICAgICAgaWYgKGlzRGlmZmVyZW50KSB7XG4gICAgICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gdGFncykge1xuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSBuZXdWYWx1ZVtrZXldO1xuICAgIGlmIChjaGlsZFZhbHVlICE9PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSk7XG4gICAgICBkaXJ0eVRhZyh0YWdzW2tleV0sIG5ld0NoaWxkVmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgbmV3Q2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRhZ3Nba2V5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltrZXldO1xuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSBuZXdWYWx1ZVtrZXldO1xuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBjaGlsZE5vZGUudmFsdWU7XG4gICAgaWYgKGNoaWxkVmFsdWUgPT09IG5ld0NoaWxkVmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgbmV3Q2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlTm9kZShjaGlsZE5vZGUsIG5ld0NoaWxkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVOb2RlKGNoaWxkTm9kZSk7XG4gICAgICBkZWxldGUgY2hpbGRyZW5ba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlbGV0ZU5vZGUobm9kZSkge1xuICBpZiAobm9kZS50YWcpIHtcbiAgICBkaXJ0eVRhZyhub2RlLnRhZywgbnVsbCk7XG4gIH1cbiAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBub2RlLnRhZ3MpIHtcbiAgICBkaXJ0eVRhZyhub2RlLnRhZ3Nba2V5XSwgbnVsbCk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgIGRlbGV0ZU5vZGUobm9kZS5jaGlsZHJlbltrZXldKTtcbiAgfVxufVxuXG4vLyBzcmMvbHJ1TWVtb2l6ZS50c1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uQ2FjaGUoZXF1YWxzKSB7XG4gIGxldCBlbnRyeTtcbiAgcmV0dXJuIHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBpZiAoZW50cnkgJiYgZXF1YWxzKGVudHJ5LmtleSwga2V5KSkge1xuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgIGVudHJ5ID0geyBrZXksIHZhbHVlIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBlbnRyeSA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgbGV0IGVudHJpZXMgPSBbXTtcbiAgZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGNvbnN0IGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleCgoZW50cnkpID0+IGVxdWFscyhrZXksIGVudHJ5LmtleSkpO1xuICAgIGlmIChjYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTtcbiAgICAgIGlmIChjYWNoZUluZGV4ID4gMCkge1xuICAgICAgICBlbnRyaWVzLnNwbGljZShjYWNoZUluZGV4LCAxKTtcbiAgICAgICAgZW50cmllcy51bnNoaWZ0KGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuICBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChnZXQoa2V5KSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICBlbnRyaWVzLnVuc2hpZnQoeyBrZXksIHZhbHVlIH0pO1xuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBlbnRyaWVzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudHJpZXMgPSBbXTtcbiAgfVxuICByZXR1cm4geyBnZXQsIHB1dCwgZ2V0RW50cmllcywgY2xlYXIgfTtcbn1cbnZhciByZWZlcmVuY2VFcXVhbGl0eUNoZWNrID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjaykge1xuICByZXR1cm4gZnVuY3Rpb24gYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwocHJldiwgbmV4dCkge1xuICAgIGlmIChwcmV2ID09PSBudWxsIHx8IG5leHQgPT09IG51bGwgfHwgcHJldi5sZW5ndGggIT09IG5leHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBwcmV2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXF1YWxpdHlDaGVjayhwcmV2W2ldLCBuZXh0W2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gbHJ1TWVtb2l6ZShmdW5jLCBlcXVhbGl0eUNoZWNrT3JPcHRpb25zKSB7XG4gIGNvbnN0IHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSBcIm9iamVjdFwiID8gZXF1YWxpdHlDaGVja09yT3B0aW9ucyA6IHsgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9ucyB9O1xuICBjb25zdCB7XG4gICAgZXF1YWxpdHlDaGVjayA9IHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXG4gICAgbWF4U2l6ZSA9IDEsXG4gICAgcmVzdWx0RXF1YWxpdHlDaGVja1xuICB9ID0gcHJvdmlkZWRPcHRpb25zO1xuICBjb25zdCBjb21wYXJhdG9yID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spO1xuICBsZXQgcmVzdWx0c0NvdW50ID0gMDtcbiAgY29uc3QgY2FjaGUgPSBtYXhTaXplID09PSAxID8gY3JlYXRlU2luZ2xldG9uQ2FjaGUoY29tcGFyYXRvcikgOiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBjb21wYXJhdG9yKTtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgbGV0IHZhbHVlID0gY2FjaGUuZ2V0KGFyZ3VtZW50cyk7XG4gICAgaWYgKHZhbHVlID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIHZhbHVlID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgcmVzdWx0c0NvdW50Kys7XG4gICAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gY2FjaGUuZ2V0RW50cmllcygpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKFxuICAgICAgICAgIChlbnRyeSkgPT4gcmVzdWx0RXF1YWxpdHlDaGVjayhlbnRyeS52YWx1ZSwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUucHV0KGFyZ3VtZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICBjYWNoZS5jbGVhcigpO1xuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KCk7XG4gIH07XG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudDtcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XG4gICAgcmVzdWx0c0NvdW50ID0gMDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9hdXRvdHJhY2tNZW1vaXplLnRzXG5mdW5jdGlvbiBhdXRvdHJhY2tNZW1vaXplKGZ1bmMpIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUoXG4gICAgW11cbiAgKTtcbiAgbGV0IGxhc3RBcmdzID0gbnVsbDtcbiAgY29uc3Qgc2hhbGxvd0VxdWFsID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2spO1xuICBjb25zdCBjYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IHtcbiAgICBjb25zdCByZXMgPSBmdW5jLmFwcGx5KG51bGwsIG5vZGUucHJveHkpO1xuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChsYXN0QXJncywgYXJndW1lbnRzKSkge1xuICAgICAgdXBkYXRlTm9kZShub2RlLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgfVxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gKCkgPT4ge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIHNyYy93ZWFrTWFwTWVtb2l6ZS50c1xudmFyIFN0cm9uZ1JlZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVyZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG52YXIgUmVmID0gdHlwZW9mIFdlYWtSZWYgIT09IFwidW5kZWZpbmVkXCIgPyBXZWFrUmVmIDogU3Ryb25nUmVmO1xudmFyIFVOVEVSTUlOQVRFRCA9IDA7XG52YXIgVEVSTUlOQVRFRCA9IDE7XG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGUoKSB7XG4gIHJldHVybiB7XG4gICAgczogVU5URVJNSU5BVEVELFxuICAgIHY6IHZvaWQgMCxcbiAgICBvOiBudWxsLFxuICAgIHA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHdlYWtNYXBNZW1vaXplKGZ1bmMsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gIGNvbnN0IHsgcmVzdWx0RXF1YWxpdHlDaGVjayB9ID0gb3B0aW9ucztcbiAgbGV0IGxhc3RSZXN1bHQ7XG4gIGxldCByZXN1bHRzQ291bnQgPSAwO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjYWNoZU5vZGUgPSBmbk5vZGU7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFyZ3VtZW50cztcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiICYmIGFyZyAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgb2JqZWN0Q2FjaGUgPSBjYWNoZU5vZGUubztcbiAgICAgICAgaWYgKG9iamVjdENhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLm8gPSBvYmplY3RDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdE5vZGUgPSBvYmplY3RDYWNoZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKG9iamVjdE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gb2JqZWN0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByaW1pdGl2ZUNhY2hlID0gY2FjaGVOb2RlLnA7XG4gICAgICAgIGlmIChwcmltaXRpdmVDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5wID0gcHJpbWl0aXZlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU5vZGUgPSBwcmltaXRpdmVDYWNoZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZU5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIHByaW1pdGl2ZUNhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gcHJpbWl0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkTm9kZSA9IGNhY2hlTm9kZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChjYWNoZU5vZGUucyA9PT0gVEVSTUlOQVRFRCkge1xuICAgICAgcmVzdWx0ID0gY2FjaGVOb2RlLnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHJlc3VsdHNDb3VudCsrO1xuICAgIH1cbiAgICB0ZXJtaW5hdGVkTm9kZS5zID0gVEVSTUlOQVRFRDtcbiAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xuICAgICAgY29uc3QgbGFzdFJlc3VsdFZhbHVlID0gKF9iID0gKF9hID0gbGFzdFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogbGFzdFJlc3VsdC5kZXJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobGFzdFJlc3VsdCkpICE9IG51bGwgPyBfYiA6IGxhc3RSZXN1bHQ7XG4gICAgICBpZiAobGFzdFJlc3VsdFZhbHVlICE9IG51bGwgJiYgcmVzdWx0RXF1YWxpdHlDaGVjayhsYXN0UmVzdWx0VmFsdWUsIHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gbGFzdFJlc3VsdFZhbHVlO1xuICAgICAgICByZXN1bHRzQ291bnQgIT09IDAgJiYgcmVzdWx0c0NvdW50LS07XG4gICAgICB9XG4gICAgICBjb25zdCBuZWVkc1dlYWtSZWYgPSB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIHJlc3VsdCAhPT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBsYXN0UmVzdWx0ID0gbmVlZHNXZWFrUmVmID8gbmV3IFJlZihyZXN1bHQpIDogcmVzdWx0O1xuICAgIH1cbiAgICB0ZXJtaW5hdGVkTm9kZS52ID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICBmbk5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpO1xuICB9O1xuICBtZW1vaXplZC5yZXN1bHRzQ291bnQgPSAoKSA9PiByZXN1bHRzQ291bnQ7XG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xuICAgIHJlc3VsdHNDb3VudCA9IDA7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gc3JjL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvci50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemVPck9wdGlvbnMsIC4uLm1lbW9pemVPcHRpb25zRnJvbUFyZ3MpIHtcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3JDcmVhdG9yT3B0aW9ucyA9IHR5cGVvZiBtZW1vaXplT3JPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgbWVtb2l6ZTogbWVtb2l6ZU9yT3B0aW9ucyxcbiAgICBtZW1vaXplT3B0aW9uczogbWVtb2l6ZU9wdGlvbnNGcm9tQXJnc1xuICB9IDogbWVtb2l6ZU9yT3B0aW9ucztcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3IyID0gKC4uLmNyZWF0ZVNlbGVjdG9yQXJncykgPT4ge1xuICAgIGxldCByZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgbGV0IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgbGV0IGxhc3RSZXN1bHQ7XG4gICAgbGV0IGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHt9O1xuICAgIGxldCByZXN1bHRGdW5jID0gY3JlYXRlU2VsZWN0b3JBcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0gcmVzdWx0RnVuYztcbiAgICAgIHJlc3VsdEZ1bmMgPSBjcmVhdGVTZWxlY3RvckFyZ3MucG9wKCk7XG4gICAgfVxuICAgIGFzc2VydElzRnVuY3Rpb24oXG4gICAgICByZXN1bHRGdW5jLFxuICAgICAgYGNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYW4gb3V0cHV0IGZ1bmN0aW9uIGFmdGVyIHRoZSBpbnB1dHMsIGJ1dCByZWNlaXZlZDogWyR7dHlwZW9mIHJlc3VsdEZ1bmN9XWBcbiAgICApO1xuICAgIGNvbnN0IGNvbWJpbmVkT3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBjcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zKSwgZGlyZWN0bHlQYXNzZWRPcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBtZW1vaXplLFxuICAgICAgbWVtb2l6ZU9wdGlvbnMgPSBbXSxcbiAgICAgIGFyZ3NNZW1vaXplID0gd2Vha01hcE1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZU9wdGlvbnMgPSBbXSxcbiAgICAgIGRldk1vZGVDaGVja3MgPSB7fVxuICAgIH0gPSBjb21iaW5lZE9wdGlvbnM7XG4gICAgY29uc3QgZmluYWxNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpO1xuICAgIGNvbnN0IGZpbmFsQXJnc01lbW9pemVPcHRpb25zID0gZW5zdXJlSXNBcnJheShhcmdzTWVtb2l6ZU9wdGlvbnMpO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpO1xuICAgIGNvbnN0IG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUoZnVuY3Rpb24gcmVjb21wdXRhdGlvbldyYXBwZXIoKSB7XG4gICAgICByZWNvbXB1dGF0aW9ucysrO1xuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKTtcbiAgICB9LCAuLi5maW5hbE1lbW9pemVPcHRpb25zKTtcbiAgICBsZXQgZmlyc3RSdW4gPSB0cnVlO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYXJnc01lbW9pemUoZnVuY3Rpb24gZGVwZW5kZW5jaWVzQ2hlY2tlcigpIHtcbiAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucysrO1xuICAgICAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXG4gICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICApO1xuICAgICAgbGFzdFJlc3VsdCA9IG1lbW9pemVkUmVzdWx0RnVuYy5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSBnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mbyhmaXJzdFJ1biwgZGV2TW9kZUNoZWNrcyk7XG4gICAgICAgIGlmIChpZGVudGl0eUZ1bmN0aW9uQ2hlY2suc2hvdWxkUnVuKSB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnJ1bihcbiAgICAgICAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICAgICAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFN0YWJpbGl0eUNoZWNrLnNob3VsZFJ1bikge1xuICAgICAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSA9IGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXRTdGFiaWxpdHlDaGVjay5ydW4oXG4gICAgICAgICAgICB7IGlucHV0U2VsZWN0b3JSZXN1bHRzLCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgfSxcbiAgICAgICAgICAgIHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnM6IGZpbmFsTWVtb2l6ZU9wdGlvbnMgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0UnVuKVxuICAgICAgICAgIGZpcnN0UnVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9LCAuLi5maW5hbEFyZ3NNZW1vaXplT3B0aW9ucyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2VsZWN0b3IsIHtcbiAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICBtZW1vaXplZFJlc3VsdEZ1bmMsXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyxcbiAgICAgIHJlc2V0RGVwZW5kZW5jeVJlY29tcHV0YXRpb25zOiAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgICB9LFxuICAgICAgbGFzdFJlc3VsdDogKCkgPT4gbGFzdFJlc3VsdCxcbiAgICAgIHJlY29tcHV0YXRpb25zOiAoKSA9PiByZWNvbXB1dGF0aW9ucyxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfSxcbiAgICAgIG1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZVxuICAgIH0pO1xuICB9O1xuICBPYmplY3QuYXNzaWduKGNyZWF0ZVNlbGVjdG9yMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlU2VsZWN0b3IyO1xufVxudmFyIGNyZWF0ZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IudHNcbnZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKFxuICAoaW5wdXRTZWxlY3RvcnNPYmplY3QsIHNlbGVjdG9yQ3JlYXRvciA9IGNyZWF0ZVNlbGVjdG9yKSA9PiB7XG4gICAgYXNzZXJ0SXNPYmplY3QoXG4gICAgICBpbnB1dFNlbGVjdG9yc09iamVjdCxcbiAgICAgIGBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgZXhwZWN0cyBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgJHt0eXBlb2YgaW5wdXRTZWxlY3RvcnNPYmplY3R9YFxuICAgICk7XG4gICAgY29uc3QgaW5wdXRTZWxlY3RvcktleXMgPSBPYmplY3Qua2V5cyhpbnB1dFNlbGVjdG9yc09iamVjdCk7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gaW5wdXRTZWxlY3RvcktleXMubWFwKFxuICAgICAgKGtleSkgPT4gaW5wdXRTZWxlY3RvcnNPYmplY3Rba2V5XVxuICAgICk7XG4gICAgY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgKC4uLmlucHV0U2VsZWN0b3JSZXN1bHRzKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnB1dFNlbGVjdG9yUmVzdWx0cy5yZWR1Y2UoKGNvbXBvc2l0aW9uLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb21wb3NpdGlvbltpbnB1dFNlbGVjdG9yS2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gc3RydWN0dXJlZFNlbGVjdG9yO1xuICB9LFxuICB7IHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH1cbik7XG5leHBvcnQge1xuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IsXG4gIGxydU1lbW9pemUsXG4gIHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXG4gIHNldEdsb2JhbERldk1vZGVDaGVja3MsXG4gIGF1dG90cmFja01lbW9pemUgYXMgdW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSxcbiAgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNlbGVjdC5sZWdhY3ktZXNtLmpzLm1hcCIsImltcG9ydCB0eXBlIHsgQW55RnVuY3Rpb24gfSBmcm9tICcuLi90eXBlcydcblxuLyoqXG4gKiBSdW5zIGEgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiByZXN1bHQgZnVuY3Rpb24gYmVoYXZlcyBhcyBhblxuICogaWRlbnRpdHkgZnVuY3Rpb24uIEFuIGlkZW50aXR5IGZ1bmN0aW9uIGlzIG9uZSB0aGF0IHJldHVybnMgaXRzXG4gKiBpbnB1dCB1bmNoYW5nZWQsIGZvciBleGFtcGxlLCBgeCA9PiB4YC4gVGhpcyBjaGVjayBoZWxwcyBlbnN1cmVcbiAqIGVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIGJ5IGVuY291cmFnaW5nXG4gKiBwcm9wZXIgdXNlIG9mIHRyYW5zZm9ybWF0aW9uIGxvZ2ljIGluIHJlc3VsdCBmdW5jdGlvbnMgYW5kXG4gKiBleHRyYWN0aW9uIGxvZ2ljIGluIGlucHV0IHNlbGVjdG9ycy5cbiAqXG4gKiBAcGFyYW0gcmVzdWx0RnVuYyAtIFRoZSByZXN1bHQgZnVuY3Rpb24gdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSBpbnB1dFNlbGVjdG9yc1Jlc3VsdHMgLSBUaGUgcmVzdWx0cyBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzLlxuICogQHBhcmFtIG91dHB1dFNlbGVjdG9yUmVzdWx0IC0gVGhlIHJlc3VsdCBvZiB0aGUgb3V0cHV0IHNlbGVjdG9yLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9kZXZlbG9wbWVudC1vbmx5LXN0YWJpbGl0eS1jaGVja3MjaWRlbnRpdHlmdW5jdGlvbmNoZWNrIGBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tgfVxuICpcbiAqIEBzaW5jZSA1LjAuMFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSAoXG4gIHJlc3VsdEZ1bmM6IEFueUZ1bmN0aW9uLFxuICBpbnB1dFNlbGVjdG9yc1Jlc3VsdHM6IHVua25vd25bXSxcbiAgb3V0cHV0U2VsZWN0b3JSZXN1bHQ6IHVua25vd25cbikgPT4ge1xuICBpZiAoXG4gICAgaW5wdXRTZWxlY3RvcnNSZXN1bHRzLmxlbmd0aCA9PT0gMSAmJlxuICAgIGlucHV0U2VsZWN0b3JzUmVzdWx0c1swXSA9PT0gb3V0cHV0U2VsZWN0b3JSZXN1bHRcbiAgKSB7XG4gICAgbGV0IGlzSW5wdXRTYW1lQXNPdXRwdXQgPSBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbXB0eU9iamVjdCA9IHt9XG4gICAgICBpZiAocmVzdWx0RnVuYyhlbXB0eU9iamVjdCkgPT09IGVtcHR5T2JqZWN0KSBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbiAgICBpZiAoaXNJbnB1dFNhbWVBc091dHB1dCkge1xuICAgICAgbGV0IHN0YWNrOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaSwgbm8tZXh0cmEtc2VtaVxuICAgICAgICA7KHsgc3RhY2sgfSA9IGUgYXMgRXJyb3IpXG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmcnICtcbiAgICAgICAgICAnXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvc10sIHRvZG9zID0+IHRvZG9zKWAnICtcbiAgICAgICAgICAnXFxuVGhpcyBjb3VsZCBsZWFkIHRvIGluZWZmaWNpZW50IG1lbW9pemF0aW9uIGFuZCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzLicgK1xuICAgICAgICAgICdcXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy4nLFxuICAgICAgICB7IHN0YWNrIH1cbiAgICAgIClcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQ3JlYXRlU2VsZWN0b3JPcHRpb25zLCBVbmtub3duTWVtb2l6ZXIgfSBmcm9tICcuLi90eXBlcydcblxuLyoqXG4gKiBSdW5zIGEgc3RhYmlsaXR5IGNoZWNrIHRvIGVuc3VyZSB0aGUgaW5wdXQgc2VsZWN0b3IgcmVzdWx0cyByZW1haW4gc3RhYmxlXG4gKiB3aGVuIHByb3ZpZGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLiBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGRldGVjdFxuICogY2hhbmdlcyBpbiB0aGUgb3V0cHV0IG9mIGlucHV0IHNlbGVjdG9ycywgd2hpY2ggY2FuIGltcGFjdCB0aGUgcGVyZm9ybWFuY2Ugb2YgbWVtb2l6ZWQgc2VsZWN0b3JzLlxuICpcbiAqIEBwYXJhbSBpbnB1dFNlbGVjdG9yUmVzdWx0c09iamVjdCAtIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBhcnJheXM6IGBpbnB1dFNlbGVjdG9yUmVzdWx0c2AgYW5kIGBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHlgLCByZXByZXNlbnRpbmcgdGhlIHJlc3VsdHMgb2YgaW5wdXQgc2VsZWN0b3JzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIG9iamVjdCBjb25zaXN0aW5nIG9mIGEgYG1lbW9pemVgIGZ1bmN0aW9uIGFuZCBhIGBtZW1vaXplT3B0aW9uc2Agb2JqZWN0LlxuICogQHBhcmFtIGlucHV0U2VsZWN0b3JBcmdzIC0gTGlzdCBvZiBhcmd1bWVudHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBpbnB1dCBzZWxlY3RvcnMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2RldmVsb3BtZW50LW9ubHktc3RhYmlsaXR5LWNoZWNrcy8jaW5wdXRzdGFiaWxpdHljaGVjayBgaW5wdXRTdGFiaWxpdHlDaGVja2B9XG4gKlxuICogQHNpbmNlIDUuMC4wXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1bklucHV0U3RhYmlsaXR5Q2hlY2sgPSAoXG4gIGlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0OiB7XG4gICAgaW5wdXRTZWxlY3RvclJlc3VsdHM6IHVua25vd25bXVxuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weTogdW5rbm93bltdXG4gIH0sXG4gIG9wdGlvbnM6IFJlcXVpcmVkPFxuICAgIFBpY2s8XG4gICAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8VW5rbm93bk1lbW9pemVyLCBVbmtub3duTWVtb2l6ZXI+LFxuICAgICAgJ21lbW9pemUnIHwgJ21lbW9pemVPcHRpb25zJ1xuICAgID5cbiAgPixcbiAgaW5wdXRTZWxlY3RvckFyZ3M6IHVua25vd25bXSB8IElBcmd1bWVudHNcbikgPT4ge1xuICBjb25zdCB7IG1lbW9pemUsIG1lbW9pemVPcHRpb25zIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9ID1cbiAgICBpbnB1dFNlbGVjdG9yUmVzdWx0c09iamVjdFxuICBjb25zdCBjcmVhdGVBbkVtcHR5T2JqZWN0ID0gbWVtb2l6ZSgoKSA9PiAoe30pLCAuLi5tZW1vaXplT3B0aW9ucylcbiAgLy8gaWYgdGhlIG1lbW9pemUgbWV0aG9kIHRoaW5rcyB0aGUgcGFyYW1ldGVycyBhcmUgZXF1YWwsIHRoZXNlICpzaG91bGQqIGJlIHRoZSBzYW1lIHJlZmVyZW5jZVxuICBjb25zdCBhcmVJbnB1dFNlbGVjdG9yUmVzdWx0c0VxdWFsID1cbiAgICBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzKSA9PT1cbiAgICBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSlcbiAgaWYgKCFhcmVJbnB1dFNlbGVjdG9yUmVzdWx0c0VxdWFsKSB7XG4gICAgbGV0IHN0YWNrOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWksIG5vLWV4dHJhLXNlbWlcbiAgICAgIDsoeyBzdGFjayB9ID0gZSBhcyBFcnJvcilcbiAgICB9XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ0FuIGlucHV0IHNlbGVjdG9yIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIHBhc3NlZCBzYW1lIGFyZ3VtZW50cy4nICtcbiAgICAgICAgJ1xcblRoaXMgbWVhbnMgeW91ciBvdXRwdXQgc2VsZWN0b3Igd2lsbCBsaWtlbHkgcnVuIG1vcmUgZnJlcXVlbnRseSB0aGFuIGludGVuZGVkLicgK1xuICAgICAgICAnXFxuQXZvaWQgcmV0dXJuaW5nIGEgbmV3IHJlZmVyZW5jZSBpbnNpZGUgeW91ciBpbnB1dCBzZWxlY3RvciwgZS5nLicgK1xuICAgICAgICAnXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKV0sIHRvZG9JZHMgPT4gdG9kb0lkcy5sZW5ndGgpYCcsXG4gICAgICB7XG4gICAgICAgIGFyZ3VtZW50czogaW5wdXRTZWxlY3RvckFyZ3MsXG4gICAgICAgIGZpcnN0SW5wdXRzOiBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgICAgICAgc2Vjb25kSW5wdXRzOiBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHksXG4gICAgICAgIHN0YWNrXG4gICAgICB9XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IERldk1vZGVDaGVja3MgfSBmcm9tICcuLi90eXBlcydcblxuLyoqXG4gKiBHbG9iYWwgY29uZmlndXJhdGlvbiBmb3IgZGV2ZWxvcG1lbnQgbW9kZSBjaGVja3MuIFRoaXMgc3BlY2lmaWVzIHRoZSBkZWZhdWx0XG4gKiBmcmVxdWVuY3kgYXQgd2hpY2ggZWFjaCBkZXZlbG9wbWVudCBtb2RlIGNoZWNrIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKlxuICogQHNpbmNlIDUuMC4wXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGdsb2JhbERldk1vZGVDaGVja3M6IERldk1vZGVDaGVja3MgPSB7XG4gIGlucHV0U3RhYmlsaXR5Q2hlY2s6ICdvbmNlJyxcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiAnb25jZSdcbn1cblxuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGRldmVsb3BtZW50IG1vZGUgY2hlY2tzIHNldHRpbmdzIGZvciBhbGwgc2VsZWN0b3JzLlxuICpcbiAqIFJlc2VsZWN0IHBlcmZvcm1zIGFkZGl0aW9uYWwgY2hlY2tzIGluIGRldmVsb3BtZW50IG1vZGUgdG8gaGVscCBpZGVudGlmeSBhbmRcbiAqIHdhcm4gYWJvdXQgcG90ZW50aWFsIGlzc3VlcyBpbiBzZWxlY3RvciBiZWhhdmlvci4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvXG4gKiBjdXN0b21pemUgdGhlIGJlaGF2aW9yIG9mIHRoZXNlIGNoZWNrcyBhY3Jvc3MgYWxsIHNlbGVjdG9ycyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqICoqTm90ZSoqOiBUaGlzIHNldHRpbmcgY2FuIHN0aWxsIGJlIG92ZXJyaWRkZW4gcGVyIHNlbGVjdG9yIGluc2lkZSBgY3JlYXRlU2VsZWN0b3JgJ3MgYG9wdGlvbnNgIG9iamVjdC5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVzZWxlY3QjMi1wZXItc2VsZWN0b3ItYnktcGFzc2luZy1hbi1pZGVudGl0eWZ1bmN0aW9uY2hlY2stb3B0aW9uLWRpcmVjdGx5LXRvLWNyZWF0ZXNlbGVjdG9yIHBlci1zZWxlY3Rvci1jb25maWd1cmF0aW9ufVxuICogYW5kIHtAbGlua2NvZGUgQ3JlYXRlU2VsZWN0b3JPcHRpb25zLmlkZW50aXR5RnVuY3Rpb25DaGVjayBpZGVudGl0eUZ1bmN0aW9uQ2hlY2t9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogX1RoZSBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcyBkbyBub3QgcnVuIGluIHByb2R1Y3Rpb24gYnVpbGRzLl9cbiAqXG4gKiBAcGFyYW0gZGV2TW9kZUNoZWNrcyAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBkZXNpcmVkIHNldHRpbmdzIGZvciBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcy4gWW91IGNhbiBwcm92aWRlIHBhcnRpYWwgb3ZlcnJpZGVzLiBVbnNwZWNpZmllZCBzZXR0aW5ncyB3aWxsIHJldGFpbiB0aGVpciBjdXJyZW50IHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldEdsb2JhbERldk1vZGVDaGVja3MgfSBmcm9tICdyZXNlbGVjdCdcbiAqIGltcG9ydCB7IERldk1vZGVDaGVja3MgfSBmcm9tICcuLi90eXBlcydcbiAqXG4gKiAvLyBSdW4gb25seSB0aGUgZmlyc3QgdGltZSB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkLiAoZGVmYXVsdClcbiAqIHNldEdsb2JhbERldk1vZGVDaGVja3MoeyBpbnB1dFN0YWJpbGl0eUNoZWNrOiAnb25jZScgfSlcbiAqXG4gKiAvLyBSdW4gZXZlcnkgdGltZSB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkLlxuICogc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyh7IGlucHV0U3RhYmlsaXR5Q2hlY2s6ICdhbHdheXMnIH0pXG4gKlxuICogLy8gTmV2ZXIgcnVuIHRoZSBpbnB1dCBzdGFiaWxpdHkgY2hlY2suXG4gKiBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzKHsgaW5wdXRTdGFiaWxpdHlDaGVjazogJ25ldmVyJyB9KVxuICpcbiAqIC8vIFJ1biBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQuIChkZWZhdWx0KVxuICogc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyh7IGlkZW50aXR5RnVuY3Rpb25DaGVjazogJ29uY2UnIH0pXG4gKlxuICogLy8gUnVuIGV2ZXJ5IHRpbWUgdGhlIHNlbGVjdG9yIGlzIGNhbGxlZC5cbiAqIHNldEdsb2JhbERldk1vZGVDaGVja3MoeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6ICdhbHdheXMnIH0pXG4gKlxuICogLy8gTmV2ZXIgcnVuIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBjaGVjay5cbiAqIHNldEdsb2JhbERldk1vZGVDaGVja3MoeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6ICduZXZlcicgfSlcbiAqIGBgYFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2RldmVsb3BtZW50LW9ubHktc3RhYmlsaXR5LWNoZWNrcyBEZXZlbG9wbWVudC1Pbmx5IFN0YWJpbGl0eSBDaGVja3N9XG4gKiBAc2VlIHtAbGluayBodHRwczovL3Jlc2VsZWN0LmpzLm9yZy9hcGkvZGV2ZWxvcG1lbnQtb25seS1zdGFiaWxpdHktY2hlY2tzIzEtZ2xvYmFsbHktdGhyb3VnaC1zZXRnbG9iYWxkZXZtb2RlY2hlY2tzIGdsb2JhbC1jb25maWd1cmF0aW9ufVxuICpcbiAqIEBzaW5jZSA1LjAuMFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyA9IChcbiAgZGV2TW9kZUNoZWNrczogUGFydGlhbDxEZXZNb2RlQ2hlY2tzPlxuKSA9PiB7XG4gIE9iamVjdC5hc3NpZ24oZ2xvYmFsRGV2TW9kZUNoZWNrcywgZGV2TW9kZUNoZWNrcylcbn1cbiIsImltcG9ydCB7IHJ1bklkZW50aXR5RnVuY3Rpb25DaGVjayB9IGZyb20gJy4vZGV2TW9kZUNoZWNrcy9pZGVudGl0eUZ1bmN0aW9uQ2hlY2snXG5pbXBvcnQgeyBydW5JbnB1dFN0YWJpbGl0eUNoZWNrIH0gZnJvbSAnLi9kZXZNb2RlQ2hlY2tzL2lucHV0U3RhYmlsaXR5Q2hlY2snXG5pbXBvcnQgeyBnbG9iYWxEZXZNb2RlQ2hlY2tzIH0gZnJvbSAnLi9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1pbXBvcnRzXG5pbXBvcnQgdHlwZSB7XG4gIERldk1vZGVDaGVja3MsXG4gIFNlbGVjdG9yLFxuICBTZWxlY3RvckFycmF5LFxuICBEZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mb1xufSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgY29uc3QgTk9UX0ZPVU5EID0gJ05PVF9GT1VORCdcbmV4cG9ydCB0eXBlIE5PVF9GT1VORF9UWVBFID0gdHlwZW9mIE5PVF9GT1VORFxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLiBJZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLFxuICogYSBgVHlwZUVycm9yYCBpcyB0aHJvd24gd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtICBlcnJvck1lc3NhZ2UgLSBBbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byB1c2UgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIEB0aHJvd3MgQSBgVHlwZUVycm9yYCBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNGdW5jdGlvbjxGdW5jdGlvblR5cGUgZXh0ZW5kcyBGdW5jdGlvbj4oXG4gIGZ1bmM6IHVua25vd24sXG4gIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIGZ1bmN9YFxuKTogYXNzZXJ0cyBmdW5jIGlzIEZ1bmN0aW9uVHlwZSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXJyb3JNZXNzYWdlKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIG9iamVjdC4gSWYgdGhlIGFzc2VydGlvbiBmYWlscyxcbiAqIGEgYFR5cGVFcnJvcmAgaXMgdGhyb3duIHdpdGggYW4gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtICBlcnJvck1lc3NhZ2UgLSBBbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byB1c2UgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIEB0aHJvd3MgQSBgVHlwZUVycm9yYCBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNPYmplY3Q8T2JqZWN0VHlwZSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb2JqZWN0OiB1bmtub3duLFxuICBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYW4gb2JqZWN0LCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIG9iamVjdH1gXG4pOiBhc3NlcnRzIG9iamVjdCBpcyBPYmplY3RUeXBlIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvdmlkZWQgYXJyYXkgaXMgYW4gYXJyYXkgb2YgZnVuY3Rpb25zLiBJZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLFxuICogYSBgVHlwZUVycm9yYCBpcyB0aHJvd24gd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSAgZXJyb3JNZXNzYWdlIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG8gdXNlIGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBAdGhyb3dzIEEgYFR5cGVFcnJvcmAgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzQXJyYXlPZkZ1bmN0aW9uczxGdW5jdGlvblR5cGUgZXh0ZW5kcyBGdW5jdGlvbj4oXG4gIGFycmF5OiB1bmtub3duW10sXG4gIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGBcbik6IGFzc2VydHMgYXJyYXkgaXMgRnVuY3Rpb25UeXBlW10ge1xuICBpZiAoXG4gICAgIWFycmF5LmV2ZXJ5KChpdGVtKTogaXRlbSBpcyBGdW5jdGlvblR5cGUgPT4gdHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpXG4gICkge1xuICAgIGNvbnN0IGl0ZW1UeXBlcyA9IGFycmF5XG4gICAgICAubWFwKGl0ZW0gPT5cbiAgICAgICAgdHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IGBmdW5jdGlvbiAke2l0ZW0ubmFtZSB8fCAndW5uYW1lZCd9KClgXG4gICAgICAgICAgOiB0eXBlb2YgaXRlbVxuICAgICAgKVxuICAgICAgLmpvaW4oJywgJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2Vycm9yTWVzc2FnZX1bJHtpdGVtVHlwZXN9XWApXG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgaW5wdXQgaXMgYW4gYXJyYXkuIElmIGl0J3MgYWxyZWFkeSBhbiBhcnJheSwgaXQncyByZXR1cm5lZCBhcyBpcy5cbiAqIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBuZXcgYXJyYXkuXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5wdXQgaXRlbS4gSWYgdGhlIGlucHV0IGlzIGFscmVhZHkgYW4gYXJyYXksIGl0J3MgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnN1cmVJc0FycmF5ID0gKGl0ZW06IHVua25vd24pID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dXG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIFwiZGVwZW5kZW5jaWVzXCIgLyBcImlucHV0IHNlbGVjdG9yc1wiIGZyb20gdGhlIGFyZ3VtZW50cyBvZiBgY3JlYXRlU2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSBjcmVhdGVTZWxlY3RvckFyZ3MgLSBBcmd1bWVudHMgcGFzc2VkIHRvIGBjcmVhdGVTZWxlY3RvcmAgYXMgYW4gYXJyYXkuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBcImlucHV0IHNlbGVjdG9yc1wiIC8gXCJkZXBlbmRlbmNpZXNcIi5cbiAqIEB0aHJvd3MgQSBgVHlwZUVycm9yYCBpZiBhbnkgb2YgdGhlIGlucHV0IHNlbGVjdG9ycyBpcyBub3QgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY3JlYXRlU2VsZWN0b3JBcmdzOiB1bmtub3duW10pIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShjcmVhdGVTZWxlY3RvckFyZ3NbMF0pXG4gICAgPyBjcmVhdGVTZWxlY3RvckFyZ3NbMF1cbiAgICA6IGNyZWF0ZVNlbGVjdG9yQXJnc1xuXG4gIGFzc2VydElzQXJyYXlPZkZ1bmN0aW9uczxTZWxlY3Rvcj4oXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYFxuICApXG5cbiAgcmV0dXJuIGRlcGVuZGVuY2llcyBhcyBTZWxlY3RvckFycmF5XG59XG5cbi8qKlxuICogUnVucyBlYWNoIGlucHV0IHNlbGVjdG9yIGFuZCByZXR1cm5zIHRoZWlyIGNvbGxlY3RpdmUgcmVzdWx0cyBhcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gZGVwZW5kZW5jaWVzIC0gQW4gYXJyYXkgb2YgXCJkZXBlbmRlbmNpZXNcIiBvciBcImlucHV0IHNlbGVjdG9yc1wiLlxuICogQHBhcmFtIGlucHV0U2VsZWN0b3JBcmdzIC0gQW4gYXJyYXkgb2YgYXJndW1lbnRzIGJlaW5nIHBhc3NlZCB0byB0aGUgaW5wdXQgc2VsZWN0b3JzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgaW5wdXQgc2VsZWN0b3IgcmVzdWx0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhcbiAgZGVwZW5kZW5jaWVzOiBTZWxlY3RvckFycmF5LFxuICBpbnB1dFNlbGVjdG9yQXJnczogdW5rbm93bltdIHwgSUFyZ3VtZW50c1xuKSB7XG4gIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gW11cbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlcGVuZGVuY2llc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBhbmQgbXV0YXRlIGEgbG9jYWwgbGlzdCBvZiBwYXJhbXMgZm9yIHBlcmZvcm1hbmNlLlxuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JBcmdzKSlcbiAgfVxuICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHNcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgZXhlY3V0aW9uIGluZm9ybWF0aW9uIGZvciBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcy5cbiAqXG4gKiBAcGFyYW0gZGV2TW9kZUNoZWNrcyAtIEN1c3RvbSBTZXR0aW5ncyBmb3IgZGV2ZWxvcG1lbnQgbW9kZSBjaGVja3MuIFRoZXNlIHNldHRpbmdzIHdpbGwgb3ZlcnJpZGUgdGhlIGdsb2JhbCBkZWZhdWx0cy5cbiAqIEBwYXJhbSBmaXJzdFJ1biAtIEluZGljYXRlcyB3aGV0aGVyIGl0IGlzIHRoZSBmaXJzdCB0aW1lIHRoZSBzZWxlY3RvciBoYXMgcnVuLlxuICogQHJldHVybnMgIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBleGVjdXRpb24gaW5mb3JtYXRpb24gZm9yIGVhY2ggZGV2ZWxvcG1lbnQgbW9kZSBjaGVjay5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKFxuICBmaXJzdFJ1bjogYm9vbGVhbixcbiAgZGV2TW9kZUNoZWNrczogUGFydGlhbDxEZXZNb2RlQ2hlY2tzPlxuKSA9PiB7XG4gIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSB7XG4gICAgLi4uZ2xvYmFsRGV2TW9kZUNoZWNrcyxcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjpcbiAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSAnYWx3YXlzJyB8fFxuICAgICAgICAoaWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSAnb25jZScgJiYgZmlyc3RSdW4pLFxuICAgICAgcnVuOiBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9LFxuICAgIGlucHV0U3RhYmlsaXR5Q2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjpcbiAgICAgICAgaW5wdXRTdGFiaWxpdHlDaGVjayA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgKGlucHV0U3RhYmlsaXR5Q2hlY2sgPT09ICdvbmNlJyAmJiBmaXJzdFJ1biksXG4gICAgICBydW46IHJ1bklucHV0U3RhYmlsaXR5Q2hlY2tcbiAgICB9XG4gIH0gc2F0aXNmaWVzIERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvXG59XG4iLCIvLyBPcmlnaW5hbCBhdXRvdHJhY2tpbmcgaW1wbGVtZW50YXRpb24gc291cmNlOlxuLy8gLSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wenVyYXEvNzliZjg2MmUwZjhjZDk1MjFiNzljNGI2ZWNjZGM0Zjlcbi8vIEFkZGl0aW9uYWwgcmVmZXJlbmNlczpcbi8vIC0gaHR0cHM6Ly93d3cucHp1cmFxLmNvbS9ibG9nL2hvdy1hdXRvdHJhY2tpbmctd29ya3Ncbi8vIC0gaHR0cHM6Ly92NS5jaHJpc2tyeWNoby5jb20vam91cm5hbC9hdXRvdHJhY2tpbmctZWxlZ2FudC1keC12aWEtY3V0dGluZy1lZGdlLWNzL1xuaW1wb3J0IHR5cGUgeyBFcXVhbGl0eUZuIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBhc3NlcnRJc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMnXG5cbi8vIFRoZSBnbG9iYWwgcmV2aXNpb24gY2xvY2suIEV2ZXJ5IHRpbWUgc3RhdGUgY2hhbmdlcywgdGhlIGNsb2NrIGluY3JlbWVudHMuXG5leHBvcnQgbGV0ICRSRVZJU0lPTiA9IDBcblxuLy8gVGhlIGN1cnJlbnQgZGVwZW5kZW5jeSB0cmFja2VyLiBXaGVuZXZlciB3ZSBjb21wdXRlIGEgY2FjaGUsIHdlIGNyZWF0ZSBhIFNldFxuLy8gdG8gdHJhY2sgYW55IGRlcGVuZGVuY2llcyB0aGF0IGFyZSB1c2VkIHdoaWxlIGNvbXB1dGluZy4gSWYgbm8gY2FjaGUgaXNcbi8vIGNvbXB1dGluZywgdGhlbiB0aGUgdHJhY2tlciBpcyBudWxsLlxubGV0IENVUlJFTlRfVFJBQ0tFUjogU2V0PENlbGw8YW55PiB8IFRyYWNraW5nQ2FjaGU+IHwgbnVsbCA9IG51bGxcblxuLy8gU3RvcmFnZSByZXByZXNlbnRzIGEgcm9vdCB2YWx1ZSBpbiB0aGUgc3lzdGVtIC0gdGhlIGFjdHVhbCBzdGF0ZSBvZiBvdXIgYXBwLlxuZXhwb3J0IGNsYXNzIENlbGw8VD4ge1xuICByZXZpc2lvbiA9ICRSRVZJU0lPTlxuXG4gIF92YWx1ZTogVFxuICBfbGFzdFZhbHVlOiBUXG4gIF9pc0VxdWFsOiBFcXVhbGl0eUZuID0gdHJpcGxlRXFcblxuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWU6IFQsIGlzRXF1YWw6IEVxdWFsaXR5Rm4gPSB0cmlwbGVFcSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlXG4gICAgdGhpcy5faXNFcXVhbCA9IGlzRXF1YWxcbiAgfVxuXG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyByZWFkLCBpdCdsbCBhZGQgaXRzZWxmIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIgaWZcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxuICBnZXQgdmFsdWUoKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSPy5hZGQodGhpcylcblxuICAgIHJldHVybiB0aGlzLl92YWx1ZVxuICB9XG5cbiAgLy8gV2hlbmV2ZXIgYSBzdG9yYWdlIHZhbHVlIGlzIHVwZGF0ZWQsIHdlIGJ1bXAgdGhlIGdsb2JhbCByZXZpc2lvbiBjbG9jayxcbiAgLy8gYXNzaWduIHRoZSByZXZpc2lvbiBmb3IgdGhpcyBzdG9yYWdlIHRvIHRoZSBuZXcgdmFsdWUsIF9hbmRfIHdlIHNjaGVkdWxlIGFcbiAgLy8gcmVyZW5kZXIuIFRoaXMgaXMgaW1wb3J0YW50LCBhbmQgaXQncyB3aGF0IG1ha2VzIGF1dG90cmFja2luZyAgX3B1bGxfXG4gIC8vIGJhc2VkLiBXZSBkb24ndCBhY3RpdmVseSB0ZWxsIHRoZSBjYWNoZXMgd2hpY2ggZGVwZW5kIG9uIHRoZSBzdG9yYWdlIHRoYXRcbiAgLy8gYW55dGhpbmcgaGFzIGhhcHBlbmVkLiBJbnN0ZWFkLCB3ZSByZWNvbXB1dGUgdGhlIGNhY2hlcyB3aGVuIG5lZWRlZC5cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IG5ld1ZhbHVlKSByZXR1cm5cblxuICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWVcbiAgICB0aGlzLnJldmlzaW9uID0gKyskUkVWSVNJT05cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlwbGVFcShhOiB1bmtub3duLCBiOiB1bmtub3duKSB7XG4gIHJldHVybiBhID09PSBiXG59XG5cbi8vIENhY2hlcyByZXByZXNlbnQgZGVyaXZlZCBzdGF0ZSBpbiB0aGUgc3lzdGVtLiBUaGV5IGFyZSB1bHRpbWF0ZWx5IGZ1bmN0aW9uc1xuLy8gdGhhdCBhcmUgbWVtb2l6ZWQgYmFzZWQgb24gd2hhdCBzdGF0ZSB0aGV5IHVzZSB0byBwcm9kdWNlIHRoZWlyIG91dHB1dCxcbi8vIG1lYW5pbmcgdGhleSB3aWxsIG9ubHkgcmVydW4gSUZGIGEgc3RvcmFnZSB2YWx1ZSB0aGF0IGNvdWxkIGFmZmVjdCB0aGUgb3V0cHV0XG4vLyBoYXMgY2hhbmdlZC4gT3RoZXJ3aXNlLCB0aGV5J2xsIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlLlxuZXhwb3J0IGNsYXNzIFRyYWNraW5nQ2FjaGUge1xuICBfY2FjaGVkVmFsdWU6IGFueVxuICBfY2FjaGVkUmV2aXNpb24gPSAtMVxuICBfZGVwczogYW55W10gPSBbXVxuICBoaXRzID0gMFxuXG4gIGZuOiAoKSA9PiBhbnlcblxuICBjb25zdHJ1Y3RvcihmbjogKCkgPT4gYW55KSB7XG4gICAgdGhpcy5mbiA9IGZuXG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2NhY2hlZFJldmlzaW9uID0gLTFcbiAgICB0aGlzLl9kZXBzID0gW11cbiAgICB0aGlzLmhpdHMgPSAwXG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgLy8gV2hlbiBnZXR0aW5nIHRoZSB2YWx1ZSBmb3IgYSBDYWNoZSwgZmlyc3Qgd2UgY2hlY2sgYWxsIHRoZSBkZXBlbmRlbmNpZXMgb2ZcbiAgICAvLyB0aGUgY2FjaGUgdG8gc2VlIHdoYXQgdGhlaXIgY3VycmVudCByZXZpc2lvbiBpcy4gSWYgdGhlIGN1cnJlbnQgcmV2aXNpb24gaXNcbiAgICAvLyBncmVhdGVyIHRoYW4gdGhlIGNhY2hlZCByZXZpc2lvbiwgdGhlbiBzb21ldGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMucmV2aXNpb24gPiB0aGlzLl9jYWNoZWRSZXZpc2lvbikge1xuICAgICAgY29uc3QgeyBmbiB9ID0gdGhpc1xuXG4gICAgICAvLyBXZSBjcmVhdGUgYSBuZXcgZGVwZW5kZW5jeSB0cmFja2VyIGZvciB0aGlzIGNhY2hlLiBBcyB0aGUgY2FjaGUgcnVuc1xuICAgICAgLy8gaXRzIGZ1bmN0aW9uLCBhbnkgU3RvcmFnZSBvciBDYWNoZSBpbnN0YW5jZXMgd2hpY2ggYXJlIHVzZWQgd2hpbGVcbiAgICAgIC8vIGNvbXB1dGluZyB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgdHJhY2tlci4gSW4gdGhlIGVuZCwgaXQgd2lsbCBiZSB0aGVcbiAgICAgIC8vIGZ1bGwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgdGhhdCB0aGlzIENhY2hlIGRlcGVuZHMgb24uXG4gICAgICBjb25zdCBjdXJyZW50VHJhY2tlciA9IG5ldyBTZXQ8Q2VsbDxhbnk+PigpXG4gICAgICBjb25zdCBwcmV2VHJhY2tlciA9IENVUlJFTlRfVFJBQ0tFUlxuXG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBjdXJyZW50VHJhY2tlclxuXG4gICAgICAvLyB0cnkge1xuICAgICAgdGhpcy5fY2FjaGVkVmFsdWUgPSBmbigpXG4gICAgICAvLyB9IGZpbmFsbHkge1xuICAgICAgQ1VSUkVOVF9UUkFDS0VSID0gcHJldlRyYWNrZXJcbiAgICAgIHRoaXMuaGl0cysrXG4gICAgICB0aGlzLl9kZXBzID0gQXJyYXkuZnJvbShjdXJyZW50VHJhY2tlcilcblxuICAgICAgLy8gU2V0IHRoZSBjYWNoZWQgcmV2aXNpb24uIFRoaXMgaXMgdGhlIGN1cnJlbnQgY2xvY2sgY291bnQgb2YgYWxsIHRoZVxuICAgICAgLy8gZGVwZW5kZW5jaWVzLiBJZiBhbnkgZGVwZW5kZW5jeSBjaGFuZ2VzLCB0aGlzIG51bWJlciB3aWxsIGJlIGxlc3NcbiAgICAgIC8vIHRoYW4gdGhlIG5ldyByZXZpc2lvbi5cbiAgICAgIHRoaXMuX2NhY2hlZFJldmlzaW9uID0gdGhpcy5yZXZpc2lvblxuICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgY3VycmVudCB0cmFja2VyLCBpdCBtZWFucyBhbm90aGVyIENhY2hlIGlzIGNvbXB1dGluZyBhbmRcbiAgICAvLyB1c2luZyB0aGlzIG9uZSwgc28gd2UgYWRkIHRoaXMgb25lIHRvIHRoZSB0cmFja2VyLlxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpXG5cbiAgICAvLyBBbHdheXMgcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFZhbHVlXG4gIH1cblxuICBnZXQgcmV2aXNpb24oKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgcmV2aXNpb24gaXMgdGhlIG1heCBvZiBhbGwgdGhlIGRlcGVuZGVuY2llcycgcmV2aXNpb25zLlxuICAgIHJldHVybiBNYXRoLm1heCguLi50aGlzLl9kZXBzLm1hcChkID0+IGQucmV2aXNpb24pLCAwKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZTxUPihjZWxsOiBDZWxsPFQ+KTogVCB7XG4gIGlmICghKGNlbGwgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIGNvbnNvbGUud2FybignTm90IGEgdmFsaWQgY2VsbCEgJywgY2VsbClcbiAgfVxuXG4gIHJldHVybiBjZWxsLnZhbHVlXG59XG5cbnR5cGUgQ2VsbFZhbHVlPFQgZXh0ZW5kcyBDZWxsPHVua25vd24+PiA9IFQgZXh0ZW5kcyBDZWxsPGluZmVyIFU+ID8gVSA6IG5ldmVyXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRWYWx1ZTxUIGV4dGVuZHMgQ2VsbDx1bmtub3duPj4oXG4gIHN0b3JhZ2U6IFQsXG4gIHZhbHVlOiBDZWxsVmFsdWU8VD5cbik6IHZvaWQge1xuICBpZiAoIShzdG9yYWdlIGluc3RhbmNlb2YgQ2VsbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ3NldFZhbHVlIG11c3QgYmUgcGFzc2VkIGEgdHJhY2tlZCBzdG9yZSBjcmVhdGVkIHdpdGggYGNyZWF0ZVN0b3JhZ2VgLidcbiAgICApXG4gIH1cblxuICBzdG9yYWdlLnZhbHVlID0gc3RvcmFnZS5fbGFzdFZhbHVlID0gdmFsdWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNlbGw8VCA9IHVua25vd24+KFxuICBpbml0aWFsVmFsdWU6IFQsXG4gIGlzRXF1YWw6IEVxdWFsaXR5Rm4gPSB0cmlwbGVFcVxuKTogQ2VsbDxUPiB7XG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWNoZTxUID0gdW5rbm93bj4oZm46ICgpID0+IFQpOiBUcmFja2luZ0NhY2hlIHtcbiAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICBmbixcbiAgICAndGhlIGZpcnN0IHBhcmFtZXRlciB0byBgY3JlYXRlQ2FjaGVgIG11c3QgYmUgYSBmdW5jdGlvbidcbiAgKVxuXG4gIHJldHVybiBuZXcgVHJhY2tpbmdDYWNoZShmbilcbn1cbiIsImltcG9ydCB0eXBlIHsgQ2VsbCB9IGZyb20gJy4vYXV0b3RyYWNraW5nJ1xuaW1wb3J0IHtcbiAgZ2V0VmFsdWUgYXMgY29uc3VtZVRhZyxcbiAgY3JlYXRlQ2VsbCBhcyBjcmVhdGVTdG9yYWdlLFxuICBzZXRWYWx1ZVxufSBmcm9tICcuL2F1dG90cmFja2luZydcblxuZXhwb3J0IHR5cGUgVGFnID0gQ2VsbDx1bmtub3duPlxuXG5jb25zdCBuZXZlckVxID0gKGE6IGFueSwgYjogYW55KTogYm9vbGVhbiA9PiBmYWxzZVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFnKCk6IFRhZyB7XG4gIHJldHVybiBjcmVhdGVTdG9yYWdlKG51bGwsIG5ldmVyRXEpXG59XG5leHBvcnQgeyBjb25zdW1lVGFnIH1cbmV4cG9ydCBmdW5jdGlvbiBkaXJ0eVRhZyh0YWc6IFRhZywgdmFsdWU6IGFueSk6IHZvaWQge1xuICBzZXRWYWx1ZSh0YWcsIHZhbHVlKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vZGU8XG4gIFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID1cbiAgICB8IEFycmF5PHVua25vd24+XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuPiB7XG4gIGNvbGxlY3Rpb25UYWc6IFRhZyB8IG51bGxcbiAgdGFnOiBUYWcgfCBudWxsXG4gIHRhZ3M6IFJlY29yZDxzdHJpbmcsIFRhZz5cbiAgY2hpbGRyZW46IFJlY29yZDxzdHJpbmcsIE5vZGU+XG4gIHByb3h5OiBUXG4gIHZhbHVlOiBUXG4gIGlkOiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnN1bWVDb2xsZWN0aW9uID0gKG5vZGU6IE5vZGUpOiB2b2lkID0+IHtcbiAgbGV0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZ1xuXG4gIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKVxuICB9XG5cbiAgY29uc3VtZVRhZyh0YWcpXG59XG5cbmV4cG9ydCBjb25zdCBkaXJ0eUNvbGxlY3Rpb24gPSAobm9kZTogTm9kZSk6IHZvaWQgPT4ge1xuICBjb25zdCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWdcblxuICBpZiAodGFnICE9PSBudWxsKSB7XG4gICAgZGlydHlUYWcodGFnLCBudWxsKVxuICB9XG59XG4iLCIvLyBPcmlnaW5hbCBzb3VyY2U6XG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1vbmlobWlnL3RyYWNrZWQtcmVkdXgvYmxvYi9tYXN0ZXIvcGFja2FnZXMvdHJhY2tlZC1yZWR1eC9zcmMvLXByaXZhdGUvcHJveHkudHNcblxuaW1wb3J0IHR5cGUgeyBOb2RlLCBUYWcgfSBmcm9tICcuL3RyYWNraW5nJ1xuaW1wb3J0IHtcbiAgY29uc3VtZUNvbGxlY3Rpb24sXG4gIGNvbnN1bWVUYWcsXG4gIGNyZWF0ZVRhZyxcbiAgZGlydHlDb2xsZWN0aW9uLFxuICBkaXJ0eVRhZ1xufSBmcm9tICcuL3RyYWNraW5nJ1xuXG5leHBvcnQgY29uc3QgUkVEVVhfUFJPWFlfTEFCRUwgPSBTeW1ib2woKVxuXG5sZXQgbmV4dElkID0gMFxuXG5jb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSlcblxuY2xhc3MgT2JqZWN0VHJlZU5vZGU8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiBpbXBsZW1lbnRzIE5vZGU8VD4ge1xuICBwcm94eTogVCA9IG5ldyBQcm94eSh0aGlzLCBvYmplY3RQcm94eUhhbmRsZXIpIGFzIHVua25vd24gYXMgVFxuICB0YWcgPSBjcmVhdGVUYWcoKVxuICB0YWdzID0ge30gYXMgUmVjb3JkPHN0cmluZywgVGFnPlxuICBjaGlsZHJlbiA9IHt9IGFzIFJlY29yZDxzdHJpbmcsIE5vZGU+XG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsXG4gIGlkID0gbmV4dElkKytcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlXG4gIH1cbn1cblxuY29uc3Qgb2JqZWN0UHJveHlIYW5kbGVyID0ge1xuICBnZXQobm9kZTogTm9kZSwga2V5OiBzdHJpbmcgfCBzeW1ib2wpOiB1bmtub3duIHtcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoKSB7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlXG5cbiAgICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBSZWZsZWN0LmdldCh2YWx1ZSwga2V5KVxuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiBwcm90bykge1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkVmFsdWUgPT09ICdvYmplY3QnICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5ba2V5XVxuXG4gICAgICAgIGlmIChjaGlsZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5ba2V5XSA9IGNyZWF0ZU5vZGUoY2hpbGRWYWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZE5vZGUudGFnKSB7XG4gICAgICAgICAgY29uc3VtZVRhZyhjaGlsZE5vZGUudGFnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5wcm94eVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHRhZyA9IG5vZGUudGFnc1trZXldXG5cbiAgICAgICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFnID0gbm9kZS50YWdzW2tleV0gPSBjcmVhdGVUYWcoKVxuICAgICAgICAgIHRhZy52YWx1ZSA9IGNoaWxkVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVUYWcodGFnKVxuXG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGNhbGN1bGF0ZVJlc3VsdCgpXG4gICAgcmV0dXJuIHJlc1xuICB9LFxuXG4gIG93bktleXMobm9kZTogTm9kZSk6IEFycmF5TGlrZTxzdHJpbmcgfCBzeW1ib2w+IHtcbiAgICBjb25zdW1lQ29sbGVjdGlvbihub2RlKVxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMobm9kZS52YWx1ZSlcbiAgfSxcblxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgbm9kZTogTm9kZSxcbiAgICBwcm9wOiBzdHJpbmcgfCBzeW1ib2xcbiAgKTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS52YWx1ZSwgcHJvcClcbiAgfSxcblxuICBoYXMobm9kZTogTm9kZSwgcHJvcDogc3RyaW5nIHwgc3ltYm9sKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApXG4gIH1cbn1cblxuY2xhc3MgQXJyYXlUcmVlTm9kZTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4+IGltcGxlbWVudHMgTm9kZTxUPiB7XG4gIHByb3h5OiBUID0gbmV3IFByb3h5KFt0aGlzXSwgYXJyYXlQcm94eUhhbmRsZXIpIGFzIHVua25vd24gYXMgVFxuICB0YWcgPSBjcmVhdGVUYWcoKVxuICB0YWdzID0ge31cbiAgY2hpbGRyZW4gPSB7fVxuICBjb2xsZWN0aW9uVGFnID0gbnVsbFxuICBpZCA9IG5leHRJZCsrXG5cbiAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBUKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy50YWcudmFsdWUgPSB2YWx1ZVxuICB9XG59XG5cbmNvbnN0IGFycmF5UHJveHlIYW5kbGVyID0ge1xuICBnZXQoW25vZGVdOiBbTm9kZV0sIGtleTogc3RyaW5nIHwgc3ltYm9sKTogdW5rbm93biB7XG4gICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5nZXQobm9kZSwga2V5KVxuICB9LFxuXG4gIG93bktleXMoW25vZGVdOiBbTm9kZV0pOiBBcnJheUxpa2U8c3RyaW5nIHwgc3ltYm9sPiB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5vd25LZXlzKG5vZGUpXG4gIH0sXG5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIFtub2RlXTogW05vZGVdLFxuICAgIHByb3A6IHN0cmluZyB8IHN5bWJvbFxuICApOiBQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApXG4gIH0sXG5cbiAgaGFzKFtub2RlXTogW05vZGVdLCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmhhcyhub2RlLCBwcm9wKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgdmFsdWU6IFRcbik6IE5vZGU8VD4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5VHJlZU5vZGUodmFsdWUpXG4gIH1cblxuICByZXR1cm4gbmV3IE9iamVjdFRyZWVOb2RlKHZhbHVlKSBhcyBOb2RlPFQ+XG59XG5cbmNvbnN0IGtleXNNYXAgPSBuZXcgV2Vha01hcDxcbiAgQXJyYXk8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgU2V0PHN0cmluZz5cbj4oKVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTm9kZTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIG5vZGU6IE5vZGU8VD4sXG4gIG5ld1ZhbHVlOiBUXG4pOiB2b2lkIHtcbiAgY29uc3QgeyB2YWx1ZSwgdGFncywgY2hpbGRyZW4gfSA9IG5vZGVcblxuICBub2RlLnZhbHVlID0gbmV3VmFsdWVcblxuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJlxuICAgIHZhbHVlLmxlbmd0aCAhPT0gbmV3VmFsdWUubGVuZ3RoXG4gICkge1xuICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGxldCBvbGRLZXlzU2l6ZSA9IDBcbiAgICAgIGxldCBuZXdLZXlzU2l6ZSA9IDBcbiAgICAgIGxldCBhbnlLZXlzQWRkZWQgPSBmYWxzZVxuXG4gICAgICBmb3IgKGNvbnN0IF9rZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgb2xkS2V5c1NpemUrK1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdWYWx1ZSkge1xuICAgICAgICBuZXdLZXlzU2l6ZSsrXG4gICAgICAgIGlmICghKGtleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICBhbnlLZXlzQWRkZWQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0RpZmZlcmVudCA9IGFueUtleXNBZGRlZCB8fCBvbGRLZXlzU2l6ZSAhPT0gbmV3S2V5c1NpemVcblxuICAgICAgaWYgKGlzRGlmZmVyZW50KSB7XG4gICAgICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHRhZ3MpIHtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldXG4gICAgY29uc3QgbmV3Q2hpbGRWYWx1ZSA9IChuZXdWYWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilba2V5XVxuXG4gICAgaWYgKGNoaWxkVmFsdWUgIT09IG5ld0NoaWxkVmFsdWUpIHtcbiAgICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKVxuICAgICAgZGlydHlUYWcodGFnc1trZXldLCBuZXdDaGlsZFZhbHVlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRhZ3Nba2V5XVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5ba2V5XVxuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSAobmV3VmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tleV1cblxuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBjaGlsZE5vZGUudmFsdWVcblxuICAgIGlmIChjaGlsZFZhbHVlID09PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZU5vZGUoY2hpbGROb2RlLCBuZXdDaGlsZFZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVOb2RlKGNoaWxkTm9kZSlcbiAgICAgIGRlbGV0ZSBjaGlsZHJlbltrZXldXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZU5vZGUobm9kZTogTm9kZSk6IHZvaWQge1xuICBpZiAobm9kZS50YWcpIHtcbiAgICBkaXJ0eVRhZyhub2RlLnRhZywgbnVsbClcbiAgfVxuICBkaXJ0eUNvbGxlY3Rpb24obm9kZSlcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS50YWdzKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpXG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgIGRlbGV0ZU5vZGUobm9kZS5jaGlsZHJlbltrZXldKVxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIEFueUZ1bmN0aW9uLFxuICBEZWZhdWx0TWVtb2l6ZUZpZWxkcyxcbiAgRXF1YWxpdHlGbixcbiAgU2ltcGxpZnlcbn0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHR5cGUgeyBOT1RfRk9VTkRfVFlQRSB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgeyBOT1RfRk9VTkQgfSBmcm9tICcuL3V0aWxzJ1xuXG4vLyBDYWNoZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBFcmlrIFJhc211c3NlbidzIGBscnUtbWVtb2l6ZWA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXJpa3Jhcy9scnUtbWVtb2l6ZVxuXG5pbnRlcmZhY2UgRW50cnkge1xuICBrZXk6IHVua25vd25cbiAgdmFsdWU6IHVua25vd25cbn1cblxuaW50ZXJmYWNlIENhY2hlIHtcbiAgZ2V0KGtleTogdW5rbm93bik6IHVua25vd24gfCBOT1RfRk9VTkRfVFlQRVxuICBwdXQoa2V5OiB1bmtub3duLCB2YWx1ZTogdW5rbm93bik6IHZvaWRcbiAgZ2V0RW50cmllcygpOiBFbnRyeVtdXG4gIGNsZWFyKCk6IHZvaWRcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uQ2FjaGUoZXF1YWxzOiBFcXVhbGl0eUZuKTogQ2FjaGUge1xuICBsZXQgZW50cnk6IEVudHJ5IHwgdW5kZWZpbmVkXG4gIHJldHVybiB7XG4gICAgZ2V0KGtleTogdW5rbm93bikge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOT1RfRk9VTkRcbiAgICB9LFxuXG4gICAgcHV0KGtleTogdW5rbm93biwgdmFsdWU6IHVua25vd24pIHtcbiAgICAgIGVudHJ5ID0geyBrZXksIHZhbHVlIH1cbiAgICB9LFxuXG4gICAgZ2V0RW50cmllcygpIHtcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXVxuICAgIH0sXG5cbiAgICBjbGVhcigpIHtcbiAgICAgIGVudHJ5ID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxydUNhY2hlKG1heFNpemU6IG51bWJlciwgZXF1YWxzOiBFcXVhbGl0eUZuKTogQ2FjaGUge1xuICBsZXQgZW50cmllczogRW50cnlbXSA9IFtdXG5cbiAgZnVuY3Rpb24gZ2V0KGtleTogdW5rbm93bikge1xuICAgIGNvbnN0IGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChlbnRyeSA9PiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpKVxuXG4gICAgLy8gV2UgZm91bmQgYSBjYWNoZWQgZW50cnlcbiAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF1cblxuICAgICAgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxuICAgICAgaWYgKGNhY2hlSW5kZXggPiAwKSB7XG4gICAgICAgIGVudHJpZXMuc3BsaWNlKGNhY2hlSW5kZXgsIDEpXG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXG4gICAgfVxuXG4gICAgLy8gTm8gZW50cnkgZm91bmQgaW4gY2FjaGUsIHJldHVybiBzZW50aW5lbFxuICAgIHJldHVybiBOT1RfRk9VTkRcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChrZXk6IHVua25vd24sIHZhbHVlOiB1bmtub3duKSB7XG4gICAgaWYgKGdldChrZXkpID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xuICAgICAgZW50cmllcy51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KVxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBlbnRyaWVzLnBvcCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50cmllcyA9IFtdXG4gIH1cblxuICByZXR1cm4geyBnZXQsIHB1dCwgZ2V0RW50cmllcywgY2xlYXIgfVxufVxuXG4vKipcbiAqIFJ1bnMgYSBzaW1wbGUgcmVmZXJlbmNlIGVxdWFsaXR5IGNoZWNrLlxuICogV2hhdCB7QGxpbmtjb2RlIGxydU1lbW9pemUgbHJ1TWVtb2l6ZX0gdXNlcyBieSBkZWZhdWx0LlxuICpcbiAqICoqTm90ZSoqOiBUaGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBkZWZhdWx0RXF1YWxpdHlDaGVja2AuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlRXF1YWxpdHlDaGVjazogRXF1YWxpdHlGbiA9IChhLCBiKSA9PiBhID09PSBiXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjazogRXF1YWxpdHlGbikge1xuICByZXR1cm4gZnVuY3Rpb24gYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoXG4gICAgcHJldjogdW5rbm93bltdIHwgSUFyZ3VtZW50cyB8IG51bGwsXG4gICAgbmV4dDogdW5rbm93bltdIHwgSUFyZ3VtZW50cyB8IG51bGxcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKHByZXYgPT09IG51bGwgfHwgbmV4dCA9PT0gbnVsbCB8fCBwcmV2Lmxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIERvIHRoaXMgaW4gYSBmb3IgbG9vcCAoYW5kIG5vdCBhIGBmb3JFYWNoYCBvciBhbiBgZXZlcnlgKSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGVxdWFsaXR5IGFzIGZhc3QgYXMgcG9zc2libGUuXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHByZXZcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSBiZWhhdmlvciBvZiBhIGZ1bmN0aW9uIG1lbW9pemVkIHdpdGhcbiAqIExSVSAoTGVhc3QgUmVjZW50bHkgVXNlZCkgY2FjaGluZy5cbiAqXG4gKiBAdGVtcGxhdGUgUmVzdWx0IC0gVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExydU1lbW9pemVPcHRpb25zPFJlc3VsdCA9IGFueT4ge1xuICAvKipcbiAgICogRnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHRoZSBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvZiB0aGVcbiAgICogcHJvdmlkZWQgY2FsY3VsYXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBkZWZhdWx0IHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2tcbiAgICovXG4gIGVxdWFsaXR5Q2hlY2s/OiBFcXVhbGl0eUZuXG5cbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB1c2VkIHRvIGNvbXBhcmUgYSBuZXdseSBnZW5lcmF0ZWQgb3V0cHV0IHZhbHVlIGFnYWluc3RcbiAgICogcHJldmlvdXMgdmFsdWVzIGluIHRoZSBjYWNoZS4gSWYgYSBtYXRjaCBpcyBmb3VuZCxcbiAgICogdGhlIG9sZCB2YWx1ZSBpcyByZXR1cm5lZC4gVGhpcyBhZGRyZXNzZXMgdGhlIGNvbW1vblxuICAgKiBgYGB0c1xuICAgKiB0b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKVxuICAgKiBgYGBcbiAgICogdXNlIGNhc2UsIHdoZXJlIGFuIHVwZGF0ZSB0byBhbm90aGVyIGZpZWxkIGluIHRoZSBvcmlnaW5hbCBkYXRhIGNhdXNlc1xuICAgKiBhIHJlY2FsY3VsYXRpb24gZHVlIHRvIGNoYW5nZWQgcmVmZXJlbmNlcywgYnV0IHRoZSBvdXRwdXQgaXMgc3RpbGxcbiAgICogZWZmZWN0aXZlbHkgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBzaW5jZSA0LjEuMFxuICAgKi9cbiAgcmVzdWx0RXF1YWxpdHlDaGVjaz86IEVxdWFsaXR5Rm48UmVzdWx0PlxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBjYWNoZSB1c2VkIGJ5IHRoZSBzZWxlY3Rvci5cbiAgICogQSBzaXplIGdyZWF0ZXIgdGhhbiAxIG1lYW5zIHRoZSBzZWxlY3RvciB3aWxsIHVzZSBhblxuICAgKiBMUlUgKExlYXN0IFJlY2VudGx5IFVzZWQpIGNhY2hlLCBhbGxvd2luZyBmb3IgdGhlIGNhY2hpbmcgb2YgbXVsdGlwbGVcbiAgICogcmVzdWx0cyBiYXNlZCBvbiBkaWZmZXJlbnQgc2V0cyBvZiBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIG1heFNpemU/OiBudW1iZXJcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uIHdpdGggYW4gb3B0aW9uYWxcbiAqIExSVSAoTGVhc3QgUmVjZW50bHkgVXNlZCkgY2FjaGUuIFRoZSBtZW1vaXplZCBmdW5jdGlvbiB1c2VzIGEgY2FjaGUgdG9cbiAqIHN0b3JlIGNvbXB1dGVkIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBgbWF4U2l6ZWAgb3B0aW9uLCBpdCB3aWxsIHVzZVxuICogZWl0aGVyIGEgc2luZ2xldG9uIGNhY2hlIChmb3IgYSBzaW5nbGUgZW50cnkpIG9yIGFuXG4gKiBMUlUgY2FjaGUgKGZvciBtdWx0aXBsZSBlbnRyaWVzKS5cbiAqXG4gKiAqKk5vdGUqKjogVGhpcyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgZGVmYXVsdE1lbW9pemVgLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIG1lbW9pemVkLlxuICogQHBhcmFtIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgLSBFaXRoZXIgYW4gZXF1YWxpdHkgY2hlY2sgZnVuY3Rpb24gb3IgYW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBBIG1lbW9pemVkIGZ1bmN0aW9uIHdpdGggYSBgLmNsZWFyQ2FjaGUoKWAgbWV0aG9kIGF0dGFjaGVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBGdW5jIC0gVGhlIHR5cGUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgbWVtb2l6ZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2xydU1lbW9pemUgYGxydU1lbW9pemVgfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxydU1lbW9pemU8RnVuYyBleHRlbmRzIEFueUZ1bmN0aW9uPihcbiAgZnVuYzogRnVuYyxcbiAgZXF1YWxpdHlDaGVja09yT3B0aW9ucz86IEVxdWFsaXR5Rm4gfCBMcnVNZW1vaXplT3B0aW9uczxSZXR1cm5UeXBlPEZ1bmM+PlxuKSB7XG4gIGNvbnN0IHByb3ZpZGVkT3B0aW9ucyA9XG4gICAgdHlwZW9mIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgPT09ICdvYmplY3QnXG4gICAgICA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnNcbiAgICAgIDogeyBlcXVhbGl0eUNoZWNrOiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zIH1cblxuICBjb25zdCB7XG4gICAgZXF1YWxpdHlDaGVjayA9IHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXG4gICAgbWF4U2l6ZSA9IDEsXG4gICAgcmVzdWx0RXF1YWxpdHlDaGVja1xuICB9ID0gcHJvdmlkZWRPcHRpb25zXG5cbiAgY29uc3QgY29tcGFyYXRvciA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKVxuXG4gIGxldCByZXN1bHRzQ291bnQgPSAwXG5cbiAgY29uc3QgY2FjaGUgPVxuICAgIG1heFNpemUgPT09IDFcbiAgICAgID8gY3JlYXRlU2luZ2xldG9uQ2FjaGUoY29tcGFyYXRvcilcbiAgICAgIDogY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgY29tcGFyYXRvcilcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKSBhcyBSZXR1cm5UeXBlPEZ1bmM+XG4gICAgaWYgKHZhbHVlID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSBhcyBSZXR1cm5UeXBlPEZ1bmM+XG4gICAgICByZXN1bHRzQ291bnQrK1xuXG4gICAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gY2FjaGUuZ2V0RW50cmllcygpXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRW50cnkgPSBlbnRyaWVzLmZpbmQoZW50cnkgPT5cbiAgICAgICAgICByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlIGFzIFJldHVyblR5cGU8RnVuYz4sIHZhbHVlKVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1hdGNoaW5nRW50cnkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoaW5nRW50cnkudmFsdWUgYXMgUmV0dXJuVHlwZTxGdW5jPlxuICAgICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgY2FjaGUuY2xlYXIoKVxuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KClcbiAgfVxuXG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudFxuXG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xuICAgIHJlc3VsdHNDb3VudCA9IDBcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplZCBhcyBGdW5jICYgU2ltcGxpZnk8RGVmYXVsdE1lbW9pemVGaWVsZHM+XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVOb2RlLCB1cGRhdGVOb2RlIH0gZnJvbSAnLi9wcm94eSdcbmltcG9ydCB0eXBlIHsgTm9kZSB9IGZyb20gJy4vdHJhY2tpbmcnXG5cbmltcG9ydCB7IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvciwgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayB9IGZyb20gJy4uL2xydU1lbW9pemUnXG5pbXBvcnQgdHlwZSB7IEFueUZ1bmN0aW9uLCBEZWZhdWx0TWVtb2l6ZUZpZWxkcywgU2ltcGxpZnkgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGNyZWF0ZUNhY2hlIH0gZnJvbSAnLi9hdXRvdHJhY2tpbmcnXG5cbi8qKlxuICogVXNlcyBhbiBcImF1dG8tdHJhY2tpbmdcIiBhcHByb2FjaCBpbnNwaXJlZCBieSB0aGUgd29yayBvZiB0aGUgRW1iZXIgR2xpbW1lciB0ZWFtLlxuICogSXQgdXNlcyBhIFByb3h5IHRvIHdyYXAgYXJndW1lbnRzIGFuZCB0cmFjayBhY2Nlc3NlcyB0byBuZXN0ZWQgZmllbGRzXG4gKiBpbiB5b3VyIHNlbGVjdG9yIG9uIGZpcnN0IHJlYWQuIExhdGVyLCB3aGVuIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aFxuICogbmV3IGFyZ3VtZW50cywgaXQgaWRlbnRpZmllcyB3aGljaCBhY2Nlc3NlZCBmaWVsZHMgaGF2ZSBjaGFuZ2VkIGFuZFxuICogb25seSByZWNhbGN1bGF0ZXMgdGhlIHJlc3VsdCBpZiBvbmUgb3IgbW9yZSBvZiB0aG9zZSBhY2Nlc3NlZCBmaWVsZHMgaGF2ZSBjaGFuZ2VkLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gYmUgbW9yZSBwcmVjaXNlIHRoYW4gdGhlIHNoYWxsb3cgZXF1YWxpdHkgY2hlY2tzIGluIGBscnVNZW1vaXplYC5cbiAqXG4gKiBfX0Rlc2lnbiBUcmFkZW9mZnMgZm9yIGBhdXRvdHJhY2tNZW1vaXplYDpfX1xuICogLSBQcm9zOlxuICogICAgLSBJdCBpcyBsaWtlbHkgdG8gYXZvaWQgZXhjZXNzIGNhbGN1bGF0aW9ucyBhbmQgcmVjYWxjdWxhdGUgZmV3ZXIgdGltZXMgdGhhbiBgbHJ1TWVtb2l6ZWAgd2lsbCxcbiAqICAgIHdoaWNoIG1heSBhbHNvIHJlc3VsdCBpbiBmZXdlciBjb21wb25lbnQgcmUtcmVuZGVycy5cbiAqIC0gQ29uczpcbiAqICAgIC0gSXQgb25seSBoYXMgYSBjYWNoZSBzaXplIG9mIDEuXG4gKiAgICAtIEl0IGlzIHNsb3dlciB0aGFuIGBscnVNZW1vaXplYCwgYmVjYXVzZSBpdCBoYXMgdG8gZG8gbW9yZSB3b3JrLiAoSG93IG11Y2ggc2xvd2VyIGlzIGRlcGVuZGVudCBvbiB0aGUgbnVtYmVyIG9mIGFjY2Vzc2VkIGZpZWxkcyBpbiBhIHNlbGVjdG9yLCBudW1iZXIgb2YgY2FsbHMsIGZyZXF1ZW5jeSBvZiBpbnB1dCBjaGFuZ2VzLCBldGMpXG4gKiAgICAtIEl0IGNhbiBoYXZlIHNvbWUgdW5leHBlY3RlZCBiZWhhdmlvci4gQmVjYXVzZSBpdCB0cmFja3MgbmVzdGVkIGZpZWxkIGFjY2Vzc2VzLFxuICogICAgY2FzZXMgd2hlcmUgeW91IGRvbid0IGFjY2VzcyBhIGZpZWxkIHdpbGwgbm90IHJlY2FsY3VsYXRlIHByb3Blcmx5LlxuICogICAgRm9yIGV4YW1wbGUsIGEgYmFkbHktd3JpdHRlbiBzZWxlY3RvciBsaWtlOlxuICogICAgICBgYGB0c1xuICogICAgICBjcmVhdGVTZWxlY3Rvcihbc3RhdGUgPT4gc3RhdGUudG9kb3NdLCB0b2RvcyA9PiB0b2RvcylcbiAqICAgICAgYGBgXG4gKiAgICAgIHRoYXQganVzdCBpbW1lZGlhdGVseSByZXR1cm5zIHRoZSBleHRyYWN0ZWQgdmFsdWUgd2lsbCBuZXZlciB1cGRhdGUsIGJlY2F1c2UgaXQgZG9lc24ndCBzZWUgYW55IGZpZWxkIGFjY2Vzc2VzIHRvIGNoZWNrLlxuICpcbiAqIF9fVXNlIENhc2VzIGZvciBgYXV0b3RyYWNrTWVtb2l6ZWA6X19cbiAqIC0gSXQgaXMgbGlrZWx5IGJlc3QgdXNlZCBmb3IgY2FzZXMgd2hlcmUgeW91IG5lZWQgdG8gYWNjZXNzIHNwZWNpZmljIG5lc3RlZCBmaWVsZHNcbiAqIGluIGRhdGEsIGFuZCBhdm9pZCByZWNhbGN1bGF0aW5nIGlmIG90aGVyIGZpZWxkcyBpbiB0aGUgc2FtZSBkYXRhIG9iamVjdHMgYXJlIGltbXV0YWJseSB1cGRhdGVkLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIG1lbW9pemVkLlxuICogQHJldHVybnMgQSBtZW1vaXplZCBmdW5jdGlvbiB3aXRoIGEgYC5jbGVhckNhY2hlKClgIG1ldGhvZCBhdHRhY2hlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNhcHRpb24+VXNpbmcgYGNyZWF0ZVNlbGVjdG9yYDwvY2FwdGlvbj5cbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyB1bnN0YWJsZV9hdXRvdHJhY2tNZW1vaXplIGFzIGF1dG90cmFja01lbW9pemUsIGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnXG4gKlxuICogY29uc3Qgc2VsZWN0VG9kb0lkcyA9IGNyZWF0ZVNlbGVjdG9yKFxuICogICBbKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zXSxcbiAqICAgKHRvZG9zKSA9PiB0b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKSxcbiAqICAgeyBtZW1vaXplOiBhdXRvdHJhY2tNZW1vaXplIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiA8Y2FwdGlvbj5Vc2luZyBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYDwvY2FwdGlvbj5cbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyB1bnN0YWJsZV9hdXRvdHJhY2tNZW1vaXplIGFzIGF1dG90cmFja01lbW9pemUsIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciB9IGZyb20gJ3Jlc2VsZWN0J1xuICpcbiAqIGNvbnN0IGNyZWF0ZVNlbGVjdG9yQXV0b3RyYWNrID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKHsgbWVtb2l6ZTogYXV0b3RyYWNrTWVtb2l6ZSB9KVxuICpcbiAqIGNvbnN0IHNlbGVjdFRvZG9JZHMgPSBjcmVhdGVTZWxlY3RvckF1dG90cmFjayhcbiAqICAgWyhzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS50b2Rvc10sXG4gKiAgICh0b2RvcykgPT4gdG9kb3MubWFwKHRvZG8gPT4gdG9kby5pZClcbiAqIClcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBGdW5jIC0gVGhlIHR5cGUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgbWVtb2l6ZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL3Vuc3RhYmxlX2F1dG90cmFja01lbW9pemUgYXV0b3RyYWNrTWVtb2l6ZX1cbiAqXG4gKiBAc2luY2UgNS4wLjBcbiAqIEBwdWJsaWNcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG90cmFja01lbW9pemU8RnVuYyBleHRlbmRzIEFueUZ1bmN0aW9uPihmdW5jOiBGdW5jKSB7XG4gIC8vIHdlIHJlZmVyZW5jZSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgdGhlbSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuXG4gIGNvbnN0IG5vZGU6IE5vZGU8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0gY3JlYXRlTm9kZShcbiAgICBbXSBhcyB1bmtub3duIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gIClcblxuICBsZXQgbGFzdEFyZ3M6IElBcmd1bWVudHMgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0IHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihyZWZlcmVuY2VFcXVhbGl0eUNoZWNrKVxuXG4gIGNvbnN0IGNhY2hlID0gY3JlYXRlQ2FjaGUoKCkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGZ1bmMuYXBwbHkobnVsbCwgbm9kZS5wcm94eSBhcyB1bmtub3duIGFzIGFueVtdKVxuICAgIHJldHVybiByZXNcbiAgfSlcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChsYXN0QXJncywgYXJndW1lbnRzKSkge1xuICAgICAgdXBkYXRlTm9kZShub2RlLCBhcmd1bWVudHMgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzXG4gICAgfVxuICAgIHJldHVybiBjYWNoZS52YWx1ZVxuICB9XG5cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FjaGUuY2xlYXIoKVxuICB9XG5cbiAgcmV0dXJuIG1lbW9pemVkIGFzIEZ1bmMgJiBTaW1wbGlmeTxEZWZhdWx0TWVtb2l6ZUZpZWxkcz5cbn1cbiIsIi8vIE9yaWdpbmFsIHNvdXJjZTpcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMGI5NzQ0MThjOWE1NmY2YzU2MDI5ODU2MDI2NWRjZjRiNjU3ODRiYy9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RDYWNoZS5qc1xuXG5pbXBvcnQgdHlwZSB7XG4gIEFueUZ1bmN0aW9uLFxuICBEZWZhdWx0TWVtb2l6ZUZpZWxkcyxcbiAgRXF1YWxpdHlGbixcbiAgU2ltcGxpZnlcbn0gZnJvbSAnLi90eXBlcydcblxuY2xhc3MgU3Ryb25nUmVmPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2YWx1ZTogVCkge31cbiAgZGVyZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxufVxuXG5jb25zdCBSZWYgPVxuICB0eXBlb2YgV2Vha1JlZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IFdlYWtSZWZcbiAgICA6IChTdHJvbmdSZWYgYXMgdW5rbm93biBhcyB0eXBlb2YgV2Vha1JlZilcblxuY29uc3QgVU5URVJNSU5BVEVEID0gMFxuY29uc3QgVEVSTUlOQVRFRCA9IDFcblxuaW50ZXJmYWNlIFVudGVybWluYXRlZENhY2hlTm9kZTxUPiB7XG4gIC8qKlxuICAgKiBTdGF0dXMsIHJlcHJlc2VudHMgd2hldGhlciB0aGUgY2FjaGVkIGNvbXB1dGF0aW9uIHJldHVybmVkIGEgdmFsdWUgb3IgdGhyZXcgYW4gZXJyb3IuXG4gICAqL1xuICBzOiAwXG4gIC8qKlxuICAgKiBWYWx1ZSwgZWl0aGVyIHRoZSBjYWNoZWQgcmVzdWx0IG9yIGFuIGVycm9yLCBkZXBlbmRpbmcgb24gc3RhdHVzLlxuICAgKi9cbiAgdjogdm9pZFxuICAvKipcbiAgICogT2JqZWN0IGNhY2hlLCBhIGBXZWFrTWFwYCB3aGVyZSBub24tcHJpbWl0aXZlIGFyZ3VtZW50cyBhcmUgc3RvcmVkLlxuICAgKi9cbiAgbzogbnVsbCB8IFdlYWtNYXA8RnVuY3Rpb24gfCBPYmplY3QsIENhY2hlTm9kZTxUPj5cbiAgLyoqXG4gICAqIFByaW1pdGl2ZSBjYWNoZSwgYSByZWd1bGFyIE1hcCB3aGVyZSBwcmltaXRpdmUgYXJndW1lbnRzIGFyZSBzdG9yZWQuXG4gICAqL1xuICBwOiBudWxsIHwgTWFwPHN0cmluZyB8IG51bWJlciB8IG51bGwgfCB2b2lkIHwgc3ltYm9sIHwgYm9vbGVhbiwgQ2FjaGVOb2RlPFQ+PlxufVxuXG5pbnRlcmZhY2UgVGVybWluYXRlZENhY2hlTm9kZTxUPiB7XG4gIC8qKlxuICAgKiBTdGF0dXMsIHJlcHJlc2VudHMgd2hldGhlciB0aGUgY2FjaGVkIGNvbXB1dGF0aW9uIHJldHVybmVkIGEgdmFsdWUgb3IgdGhyZXcgYW4gZXJyb3IuXG4gICAqL1xuICBzOiAxXG4gIC8qKlxuICAgKiBWYWx1ZSwgZWl0aGVyIHRoZSBjYWNoZWQgcmVzdWx0IG9yIGFuIGVycm9yLCBkZXBlbmRpbmcgb24gc3RhdHVzLlxuICAgKi9cbiAgdjogVFxuICAvKipcbiAgICogT2JqZWN0IGNhY2hlLCBhIGBXZWFrTWFwYCB3aGVyZSBub24tcHJpbWl0aXZlIGFyZ3VtZW50cyBhcmUgc3RvcmVkLlxuICAgKi9cbiAgbzogbnVsbCB8IFdlYWtNYXA8RnVuY3Rpb24gfCBPYmplY3QsIENhY2hlTm9kZTxUPj5cbiAgLyoqXG4gICAqIFByaW1pdGl2ZSBjYWNoZSwgYSByZWd1bGFyIGBNYXBgIHdoZXJlIHByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZC5cbiAgICovXG4gIHA6IG51bGwgfCBNYXA8c3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHZvaWQgfCBzeW1ib2wgfCBib29sZWFuLCBDYWNoZU5vZGU8VD4+XG59XG5cbnR5cGUgQ2FjaGVOb2RlPFQ+ID0gVGVybWluYXRlZENhY2hlTm9kZTxUPiB8IFVudGVybWluYXRlZENhY2hlTm9kZTxUPlxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGU8VD4oKTogQ2FjaGVOb2RlPFQ+IHtcbiAgcmV0dXJuIHtcbiAgICBzOiBVTlRFUk1JTkFURUQsXG4gICAgdjogdW5kZWZpbmVkLFxuICAgIG86IG51bGwsXG4gICAgcDogbnVsbFxuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhIG1lbW9pemF0aW9uIGZ1bmN0aW9uIHV0aWxpemluZyBgV2Vha01hcGAgZm9yXG4gKiBpdHMgY2FjaGluZyBtZWNoYW5pc20uXG4gKlxuICogQHRlbXBsYXRlIFJlc3VsdCAtIFRoZSB0eXBlIG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqIEBzaW5jZSA1LjAuMFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlYWtNYXBNZW1vaXplT3B0aW9uczxSZXN1bHQgPSBhbnk+IHtcbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB1c2VkIHRvIGNvbXBhcmUgYSBuZXdseSBnZW5lcmF0ZWQgb3V0cHV0IHZhbHVlIGFnYWluc3QgcHJldmlvdXMgdmFsdWVzIGluIHRoZSBjYWNoZS5cbiAgICogSWYgYSBtYXRjaCBpcyBmb3VuZCwgdGhlIG9sZCB2YWx1ZSBpcyByZXR1cm5lZC4gVGhpcyBhZGRyZXNzZXMgdGhlIGNvbW1vblxuICAgKiBgYGB0c1xuICAgKiB0b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKVxuICAgKiBgYGBcbiAgICogdXNlIGNhc2UsIHdoZXJlIGFuIHVwZGF0ZSB0byBhbm90aGVyIGZpZWxkIGluIHRoZSBvcmlnaW5hbCBkYXRhIGNhdXNlcyBhIHJlY2FsY3VsYXRpb25cbiAgICogZHVlIHRvIGNoYW5nZWQgcmVmZXJlbmNlcywgYnV0IHRoZSBvdXRwdXQgaXMgc3RpbGwgZWZmZWN0aXZlbHkgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBzaW5jZSA1LjAuMFxuICAgKi9cbiAgcmVzdWx0RXF1YWxpdHlDaGVjaz86IEVxdWFsaXR5Rm48UmVzdWx0PlxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmVlIG9mIGBXZWFrTWFwYC1iYXNlZCBjYWNoZSBub2RlcyBiYXNlZCBvbiB0aGUgaWRlbnRpdHkgb2YgdGhlXG4gKiBhcmd1bWVudHMgaXQncyBiZWVuIGNhbGxlZCB3aXRoIChpbiB0aGlzIGNhc2UsIHRoZSBleHRyYWN0ZWQgdmFsdWVzIGZyb20geW91ciBpbnB1dCBzZWxlY3RvcnMpLlxuICogVGhpcyBhbGxvd3MgYHdlYWtNYXBNZW1vaXplYCB0byBoYXZlIGFuIGVmZmVjdGl2ZWx5IGluZmluaXRlIGNhY2hlIHNpemUuXG4gKiBDYWNoZSByZXN1bHRzIHdpbGwgYmUga2VwdCBpbiBtZW1vcnkgYXMgbG9uZyBhcyByZWZlcmVuY2VzIHRvIHRoZSBhcmd1bWVudHMgc3RpbGwgZXhpc3QsXG4gKiBhbmQgdGhlbiBjbGVhcmVkIG91dCBhcyB0aGUgYXJndW1lbnRzIGFyZSBnYXJiYWdlLWNvbGxlY3RlZC5cbiAqXG4gKiBfX0Rlc2lnbiBUcmFkZW9mZnMgZm9yIGB3ZWFrTWFwTWVtb2l6ZWA6X19cbiAqIC0gUHJvczpcbiAqICAgLSBJdCBoYXMgYW4gZWZmZWN0aXZlbHkgaW5maW5pdGUgY2FjaGUgc2l6ZSwgYnV0IHlvdSBoYXZlIG5vIGNvbnRyb2wgb3ZlclxuICogICBob3cgbG9uZyB2YWx1ZXMgYXJlIGtlcHQgaW4gY2FjaGUgYXMgaXQncyBiYXNlZCBvbiBnYXJiYWdlIGNvbGxlY3Rpb24gYW5kIGBXZWFrTWFwYHMuXG4gKiAtIENvbnM6XG4gKiAgIC0gVGhlcmUncyBjdXJyZW50bHkgbm8gd2F5IHRvIGFsdGVyIHRoZSBhcmd1bWVudCBjb21wYXJpc29ucy5cbiAqICAgVGhleSdyZSBiYXNlZCBvbiBzdHJpY3QgcmVmZXJlbmNlIGVxdWFsaXR5LlxuICogICAtIEl0J3Mgcm91Z2hseSB0aGUgc2FtZSBzcGVlZCBhcyBgbHJ1TWVtb2l6ZWAsIGFsdGhvdWdoIGxpa2VseSBhIGZyYWN0aW9uIHNsb3dlci5cbiAqXG4gKiBfX1VzZSBDYXNlcyBmb3IgYHdlYWtNYXBNZW1vaXplYDpfX1xuICogLSBUaGlzIG1lbW9pemVyIGlzIGxpa2VseSBiZXN0IHVzZWQgZm9yIGNhc2VzIHdoZXJlIHlvdSBuZWVkIHRvIGNhbGwgdGhlXG4gKiBzYW1lIHNlbGVjdG9yIGluc3RhbmNlIHdpdGggbWFueSBkaWZmZXJlbnQgYXJndW1lbnRzLCBzdWNoIGFzIGEgc2luZ2xlXG4gKiBzZWxlY3RvciBpbnN0YW5jZSB0aGF0IGlzIHVzZWQgaW4gYSBsaXN0IGl0ZW0gY29tcG9uZW50IGFuZCBjYWxsZWQgd2l0aFxuICogaXRlbSBJRHMgbGlrZTpcbiAqICAgYGBgdHNcbiAqICAgdXNlU2VsZWN0b3Ioc3RhdGUgPT4gc2VsZWN0U29tZURhdGEoc3RhdGUsIHByb3BzLmNhdGVnb3J5KSlcbiAqICAgYGBgXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBiZSBtZW1vaXplZC5cbiAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgZnVuY3Rpb24gd2l0aCBhIGAuY2xlYXJDYWNoZSgpYCBtZXRob2QgYXR0YWNoZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxjYXB0aW9uPlVzaW5nIGBjcmVhdGVTZWxlY3RvcmA8L2NhcHRpb24+XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IsIHdlYWtNYXBNZW1vaXplIH0gZnJvbSAncmVzZWxlY3QnXG4gKlxuICogaW50ZXJmYWNlIFJvb3RTdGF0ZSB7XG4gKiAgIGl0ZW1zOiB7IGlkOiBudW1iZXI7IGNhdGVnb3J5OiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9W11cbiAqIH1cbiAqXG4gKiBjb25zdCBzZWxlY3RJdGVtc0J5Q2F0ZWdvcnkgPSBjcmVhdGVTZWxlY3RvcihcbiAqICAgW1xuICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5pdGVtcyxcbiAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSwgY2F0ZWdvcnk6IHN0cmluZykgPT4gY2F0ZWdvcnlcbiAqICAgXSxcbiAqICAgKGl0ZW1zLCBjYXRlZ29yeSkgPT4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpLFxuICogICB7XG4gKiAgICAgbWVtb2l6ZTogd2Vha01hcE1lbW9pemUsXG4gKiAgICAgYXJnc01lbW9pemU6IHdlYWtNYXBNZW1vaXplXG4gKiAgIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiA8Y2FwdGlvbj5Vc2luZyBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYDwvY2FwdGlvbj5cbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsIHdlYWtNYXBNZW1vaXplIH0gZnJvbSAncmVzZWxlY3QnXG4gKlxuICogY29uc3QgY3JlYXRlU2VsZWN0b3JXZWFrTWFwID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKHsgbWVtb2l6ZTogd2Vha01hcE1lbW9pemUsIGFyZ3NNZW1vaXplOiB3ZWFrTWFwTWVtb2l6ZSB9KVxuICpcbiAqIGNvbnN0IHNlbGVjdEl0ZW1zQnlDYXRlZ29yeSA9IGNyZWF0ZVNlbGVjdG9yV2Vha01hcChcbiAqICAgW1xuICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5pdGVtcyxcbiAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSwgY2F0ZWdvcnk6IHN0cmluZykgPT4gY2F0ZWdvcnlcbiAqICAgXSxcbiAqICAgKGl0ZW1zLCBjYXRlZ29yeSkgPT4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUgRnVuYyAtIFRoZSB0eXBlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGlzIG1lbW9pemVkLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS93ZWFrTWFwTWVtb2l6ZSBgd2Vha01hcE1lbW9pemVgfVxuICpcbiAqIEBzaW5jZSA1LjAuMFxuICogQHB1YmxpY1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2Vha01hcE1lbW9pemU8RnVuYyBleHRlbmRzIEFueUZ1bmN0aW9uPihcbiAgZnVuYzogRnVuYyxcbiAgb3B0aW9uczogV2Vha01hcE1lbW9pemVPcHRpb25zPFJldHVyblR5cGU8RnVuYz4+ID0ge31cbikge1xuICBsZXQgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKClcbiAgY29uc3QgeyByZXN1bHRFcXVhbGl0eUNoZWNrIH0gPSBvcHRpb25zXG5cbiAgbGV0IGxhc3RSZXN1bHQ6IFdlYWtSZWY8b2JqZWN0PiB8IHVuZGVmaW5lZFxuXG4gIGxldCByZXN1bHRzQ291bnQgPSAwXG5cbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgbGV0IGNhY2hlTm9kZSA9IGZuTm9kZVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhcmd1bWVudHNcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJndW1lbnRzW2ldXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbClcbiAgICAgICkge1xuICAgICAgICAvLyBPYmplY3RzIGdvIGludG8gYSBXZWFrTWFwXG4gICAgICAgIGxldCBvYmplY3RDYWNoZSA9IGNhY2hlTm9kZS5vXG4gICAgICAgIGlmIChvYmplY3RDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5vID0gb2JqZWN0Q2FjaGUgPSBuZXcgV2Vha01hcCgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0Tm9kZSA9IG9iamVjdENhY2hlLmdldChhcmcpXG4gICAgICAgIGlmIChvYmplY3ROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKVxuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBvYmplY3ROb2RlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgZ28gaW50byBhIHJlZ3VsYXIgTWFwXG4gICAgICAgIGxldCBwcmltaXRpdmVDYWNoZSA9IGNhY2hlTm9kZS5wXG4gICAgICAgIGlmIChwcmltaXRpdmVDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5wID0gcHJpbWl0aXZlQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmltaXRpdmVOb2RlID0gcHJpbWl0aXZlQ2FjaGUuZ2V0KGFyZylcbiAgICAgICAgaWYgKHByaW1pdGl2ZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpXG4gICAgICAgICAgcHJpbWl0aXZlQ2FjaGUuc2V0KGFyZywgY2FjaGVOb2RlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IHByaW1pdGl2ZU5vZGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRlcm1pbmF0ZWROb2RlID0gY2FjaGVOb2RlIGFzIHVua25vd24gYXMgVGVybWluYXRlZENhY2hlTm9kZTxhbnk+XG5cbiAgICBsZXQgcmVzdWx0XG5cbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IFRFUk1JTkFURUQpIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlTm9kZS52XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFsbG93IGVycm9ycyB0byBwcm9wYWdhdGVcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzIGFzIHVua25vd24gYXMgYW55W10pXG4gICAgICByZXN1bHRzQ291bnQrK1xuICAgIH1cblxuICAgIHRlcm1pbmF0ZWROb2RlLnMgPSBURVJNSU5BVEVEXG5cbiAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xuICAgICAgY29uc3QgbGFzdFJlc3VsdFZhbHVlID0gbGFzdFJlc3VsdD8uZGVyZWY/LigpID8/IGxhc3RSZXN1bHRcbiAgICAgIGlmIChcbiAgICAgICAgbGFzdFJlc3VsdFZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgcmVzdWx0RXF1YWxpdHlDaGVjayhsYXN0UmVzdWx0VmFsdWUgYXMgUmV0dXJuVHlwZTxGdW5jPiwgcmVzdWx0KVxuICAgICAgKSB7XG4gICAgICAgIHJlc3VsdCA9IGxhc3RSZXN1bHRWYWx1ZVxuICAgICAgICByZXN1bHRzQ291bnQgIT09IDAgJiYgcmVzdWx0c0NvdW50LS1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbmVlZHNXZWFrUmVmID1cbiAgICAgICAgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkgfHxcbiAgICAgICAgdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgbGFzdFJlc3VsdCA9IG5lZWRzV2Vha1JlZiA/IG5ldyBSZWYocmVzdWx0KSA6IHJlc3VsdFxuICAgIH1cbiAgICB0ZXJtaW5hdGVkTm9kZS52ID0gcmVzdWx0XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICBmbk5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKVxuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KClcbiAgfVxuXG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudFxuXG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xuICAgIHJlc3VsdHNDb3VudCA9IDBcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplZCBhcyBGdW5jICYgU2ltcGxpZnk8RGVmYXVsdE1lbW9pemVGaWVsZHM+XG59XG4iLCJpbXBvcnQgeyB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gJy4vd2Vha01hcE1lbW9pemUnXG5cbmltcG9ydCB0eXBlIHtcbiAgQ29tYmluZXIsXG4gIENyZWF0ZVNlbGVjdG9yT3B0aW9ucyxcbiAgRHJvcEZpcnN0UGFyYW1ldGVyLFxuICBFeHRyYWN0TWVtb2l6ZXJGaWVsZHMsXG4gIEdldFBhcmFtc0Zyb21TZWxlY3RvcnMsXG4gIEdldFN0YXRlRnJvbVNlbGVjdG9ycyxcbiAgSW50ZXJydXB0UmVjdXJzaW9uLFxuICBPdXRwdXRTZWxlY3RvcixcbiAgU2VsZWN0b3IsXG4gIFNlbGVjdG9yQXJyYXksXG4gIFNldFJlcXVpcmVkLFxuICBTaW1wbGlmeSxcbiAgVW5rbm93bk1lbW9pemVyXG59IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7XG4gIGFzc2VydElzRnVuY3Rpb24sXG4gIGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgZW5zdXJlSXNBcnJheSxcbiAgZ2V0RGVwZW5kZW5jaWVzLFxuICBnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mb1xufSBmcm9tICcuL3V0aWxzJ1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIGBjcmVhdGVTZWxlY3RvcmAsIGN1c3RvbWl6ZWQgd2l0aCBhIGdpdmVuIG1lbW9pemUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIE1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBtZW1vaXplIHRoZSBgcmVzdWx0RnVuY2AgaW5zaWRlIGBjcmVhdGVTZWxlY3RvcmAgKGUuZy4sIGBscnVNZW1vaXplYCBvciBgd2Vha01hcE1lbW9pemVgKS5cbiAqIEB0ZW1wbGF0ZSBBcmdzTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgb3V0cHV0IHNlbGVjdG9yIGdlbmVyYXRlZCBieSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuIElmIG5vbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCwgYHdlYWtNYXBNZW1vaXplYCB3aWxsIGJlIHVzZWQuXG4gKiBAdGVtcGxhdGUgU3RhdGVUeXBlIC0gVGhlIHR5cGUgb2Ygc3RhdGUgdGhhdCB0aGUgc2VsZWN0b3JzIGNyZWF0ZWQgd2l0aCB0aGlzIHNlbGVjdG9yIGNyZWF0b3Igd2lsbCBvcGVyYXRlIG9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uPFxuICBNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSB0eXBlb2Ygd2Vha01hcE1lbW9pemUsXG4gIEFyZ3NNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSB0eXBlb2Ygd2Vha01hcE1lbW9pemUsXG4gIFN0YXRlVHlwZSA9IGFueVxuPiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWVtb2l6ZWQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjcmVhdGVTZWxlY3RvckFyZ3MgLSBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGlucHV0IHNlbGVjdG9ycyBhcyBzZXBhcmF0ZSBpbmxpbmUgYXJndW1lbnRzIGFuZCBhIGBjb21iaW5lcmAgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgb3V0cHV0IHNlbGVjdG9yLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgSW5wdXRTZWxlY3RvcnMgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzIGFzIGFuIGFycmF5LlxuICAgKiBAdGVtcGxhdGUgUmVzdWx0IC0gVGhlIHJldHVybiB0eXBlIG9mIHRoZSBgY29tYmluZXJgIGFzIHdlbGwgYXMgdGhlIG91dHB1dCBzZWxlY3Rvci5cbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIGBtZW1vaXplYCBmdW5jdGlvbiB0aGF0IGNvdWxkIGJlIHBhc3NlZCBpbnRvIHRoZSBvcHRpb25zIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb3JpZ2luYWwgYG1lbW9pemVgIGZ1bmN0aW9uIHRoYXQgd2FzIGluaXRpYWxseSBwYXNzZWQgaW50byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgY291bGQgYmUgcGFzc2VkIGludG8gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgd2FzIGluaXRpYWxseSBwYXNzZWQgaW50byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZXNlbGVjdG9yIGBjcmVhdGVTZWxlY3RvcmB9XG4gICAqL1xuICA8SW5wdXRTZWxlY3RvcnMgZXh0ZW5kcyBTZWxlY3RvckFycmF5PFN0YXRlVHlwZT4sIFJlc3VsdD4oXG4gICAgLi4uY3JlYXRlU2VsZWN0b3JBcmdzOiBbXG4gICAgICAuLi5pbnB1dFNlbGVjdG9yczogSW5wdXRTZWxlY3RvcnMsXG4gICAgICBjb21iaW5lcjogQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD5cbiAgICBdXG4gICk6IE91dHB1dFNlbGVjdG9yPFxuICAgIElucHV0U2VsZWN0b3JzLFxuICAgIFJlc3VsdCxcbiAgICBNZW1vaXplRnVuY3Rpb24sXG4gICAgQXJnc01lbW9pemVGdW5jdGlvblxuICA+ICZcbiAgICBJbnRlcnJ1cHRSZWN1cnNpb25cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1lbW9pemVkIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY3JlYXRlU2VsZWN0b3JBcmdzIC0gQW4gYXJiaXRyYXJ5IG51bWJlciBvZiBpbnB1dCBzZWxlY3RvcnMgYXMgc2VwYXJhdGUgaW5saW5lIGFyZ3VtZW50cywgYSBgY29tYmluZXJgIGZ1bmN0aW9uIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxuICAgKiBAcmV0dXJucyBBIG1lbW9pemVkIG91dHB1dCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHRlbXBsYXRlIElucHV0U2VsZWN0b3JzIC0gVGhlIHR5cGUgb2YgdGhlIGlucHV0IHNlbGVjdG9ycyBhcyBhbiBhcnJheS5cbiAgICogQHRlbXBsYXRlIFJlc3VsdCAtIFRoZSByZXR1cm4gdHlwZSBvZiB0aGUgYGNvbWJpbmVyYCBhcyB3ZWxsIGFzIHRoZSBvdXRwdXQgc2VsZWN0b3IuXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZU1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgbWVtb2l6ZWAgZnVuY3Rpb24gdGhhdCBjb3VsZCBiZSBwYXNzZWQgaW50byB0aGUgb3B0aW9ucyBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9yaWdpbmFsIGBtZW1vaXplYCBmdW5jdGlvbiB0aGF0IHdhcyBpbml0aWFsbHkgcGFzc2VkIGludG8gYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmAuXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgb3B0aW9uYWwgYGFyZ3NNZW1vaXplYCBmdW5jdGlvbiB0aGF0IGNvdWxkIGJlIHBhc3NlZCBpbnRvIHRoZSBvcHRpb25zIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb3JpZ2luYWwgYGFyZ3NNZW1vaXplYCBmdW5jdGlvbiB0aGF0IHdhcyBpbml0aWFsbHkgcGFzc2VkIGludG8gYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmAuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVzZWxlY3RvciBgY3JlYXRlU2VsZWN0b3JgfVxuICAgKi9cbiAgPFxuICAgIElucHV0U2VsZWN0b3JzIGV4dGVuZHMgU2VsZWN0b3JBcnJheTxTdGF0ZVR5cGU+LFxuICAgIFJlc3VsdCxcbiAgICBPdmVycmlkZU1lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IE1lbW9pemVGdW5jdGlvbixcbiAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSBBcmdzTWVtb2l6ZUZ1bmN0aW9uXG4gID4oXG4gICAgLi4uY3JlYXRlU2VsZWN0b3JBcmdzOiBbXG4gICAgICAuLi5pbnB1dFNlbGVjdG9yczogSW5wdXRTZWxlY3RvcnMsXG4gICAgICBjb21iaW5lcjogQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4sXG4gICAgICBjcmVhdGVTZWxlY3Rvck9wdGlvbnM6IFNpbXBsaWZ5PFxuICAgICAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8XG4gICAgICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxuICAgICAgICAgIEFyZ3NNZW1vaXplRnVuY3Rpb24sXG4gICAgICAgICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24sXG4gICAgICAgICAgT3ZlcnJpZGVBcmdzTWVtb2l6ZUZ1bmN0aW9uXG4gICAgICAgID5cbiAgICAgID5cbiAgICBdXG4gICk6IE91dHB1dFNlbGVjdG9yPFxuICAgIElucHV0U2VsZWN0b3JzLFxuICAgIFJlc3VsdCxcbiAgICBPdmVycmlkZU1lbW9pemVGdW5jdGlvbixcbiAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb25cbiAgPiAmXG4gICAgSW50ZXJydXB0UmVjdXJzaW9uXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtZW1vaXplZCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0U2VsZWN0b3JzIC0gQW4gYXJyYXkgb2YgaW5wdXQgc2VsZWN0b3JzLlxuICAgKiBAcGFyYW0gY29tYmluZXIgLSBBIGZ1bmN0aW9uIHRoYXQgQ29tYmluZXMgdGhlIGlucHV0IHNlbGVjdG9ycyBhbmQgcmV0dXJucyBhbiBvdXRwdXQgc2VsZWN0b3IuIE90aGVyd2lzZSBrbm93biBhcyB0aGUgcmVzdWx0IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gY3JlYXRlU2VsZWN0b3JPcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIGZ1cnRoZXIgY3VzdG9taXphdGlvbiBwZXIgc2VsZWN0b3IuXG4gICAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgb3V0cHV0IHNlbGVjdG9yLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgSW5wdXRTZWxlY3RvcnMgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzIGFycmF5LlxuICAgKiBAdGVtcGxhdGUgUmVzdWx0IC0gVGhlIHJldHVybiB0eXBlIG9mIHRoZSBgY29tYmluZXJgIGFzIHdlbGwgYXMgdGhlIG91dHB1dCBzZWxlY3Rvci5cbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIGBtZW1vaXplYCBmdW5jdGlvbiB0aGF0IGNvdWxkIGJlIHBhc3NlZCBpbnRvIHRoZSBvcHRpb25zIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb3JpZ2luYWwgYG1lbW9pemVgIGZ1bmN0aW9uIHRoYXQgd2FzIGluaXRpYWxseSBwYXNzZWQgaW50byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgY291bGQgYmUgcGFzc2VkIGludG8gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgd2FzIGluaXRpYWxseSBwYXNzZWQgaW50byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZXNlbGVjdG9yIGBjcmVhdGVTZWxlY3RvcmB9XG4gICAqL1xuICA8XG4gICAgSW5wdXRTZWxlY3RvcnMgZXh0ZW5kcyBTZWxlY3RvckFycmF5PFN0YXRlVHlwZT4sXG4gICAgUmVzdWx0LFxuICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gTWVtb2l6ZUZ1bmN0aW9uLFxuICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IEFyZ3NNZW1vaXplRnVuY3Rpb25cbiAgPihcbiAgICBpbnB1dFNlbGVjdG9yczogWy4uLklucHV0U2VsZWN0b3JzXSxcbiAgICBjb21iaW5lcjogQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4sXG4gICAgY3JlYXRlU2VsZWN0b3JPcHRpb25zPzogU2ltcGxpZnk8XG4gICAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8XG4gICAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvbixcbiAgICAgICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24sXG4gICAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxuICAgICAgPlxuICAgID5cbiAgKTogT3V0cHV0U2VsZWN0b3I8XG4gICAgSW5wdXRTZWxlY3RvcnMsXG4gICAgUmVzdWx0LFxuICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uLFxuICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxuICA+ICZcbiAgICBJbnRlcnJ1cHRSZWN1cnNpb25cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFwicHJlLXR5cGVkXCIgdmVyc2lvbiBvZiB7QGxpbmtjb2RlIGNyZWF0ZVNlbGVjdG9yIGNyZWF0ZVNlbGVjdG9yfVxuICAgKiB3aGVyZSB0aGUgYHN0YXRlYCB0eXBlIGlzIHByZWRlZmluZWQuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIGBzdGF0ZWAgdHlwZSBvbmNlLCBlbGltaW5hdGluZyB0aGUgbmVlZCB0b1xuICAgKiBzcGVjaWZ5IGl0IHdpdGggZXZlcnkge0BsaW5rY29kZSBjcmVhdGVTZWxlY3RvciBjcmVhdGVTZWxlY3Rvcn0gY2FsbC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcmUtdHlwZWQgYGNyZWF0ZVNlbGVjdG9yYCB3aXRoIHRoZSBzdGF0ZSB0eXBlIGFscmVhZHkgZGVmaW5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCdcbiAgICpcbiAgICogZXhwb3J0IGludGVyZmFjZSBSb290U3RhdGUge1xuICAgKiAgIHRvZG9zOiB7IGlkOiBudW1iZXI7IGNvbXBsZXRlZDogYm9vbGVhbiB9W11cbiAgICogICBhbGVydHM6IHsgaWQ6IG51bWJlcjsgcmVhZDogYm9vbGVhbiB9W11cbiAgICogfVxuICAgKlxuICAgKiBleHBvcnQgY29uc3QgY3JlYXRlQXBwU2VsZWN0b3IgPSBjcmVhdGVTZWxlY3Rvci53aXRoVHlwZXM8Um9vdFN0YXRlPigpXG4gICAqXG4gICAqIGNvbnN0IHNlbGVjdFRvZG9JZHMgPSBjcmVhdGVBcHBTZWxlY3RvcihcbiAgICogICBbXG4gICAqICAgICAvLyBUeXBlIG9mIGBzdGF0ZWAgaXMgc2V0IHRvIGBSb290U3RhdGVgLCBubyBuZWVkIHRvIG1hbnVhbGx5IHNldCB0aGUgdHlwZVxuICAgKiAgICAgc3RhdGUgPT4gc3RhdGUudG9kb3NcbiAgICogICBdLFxuICAgKiAgIHRvZG9zID0+IHRvZG9zLm1hcCgoeyBpZCB9KSA9PiBpZClcbiAgICogKVxuICAgKiBgYGBcbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlU3RhdGVUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2Ygc3RhdGUgdXNlZCBieSBhbGwgc2VsZWN0b3JzIGNyZWF0ZWQgd2l0aCB0aGlzIHNlbGVjdG9yIGNyZWF0b3IuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVzZWxlY3RvciNkZWZpbmluZy1hLXByZS10eXBlZC1jcmVhdGVzZWxlY3RvciBgY3JlYXRlU2VsZWN0b3Iud2l0aFR5cGVzYH1cbiAgICpcbiAgICogQHNpbmNlIDUuMS4wXG4gICAqL1xuICB3aXRoVHlwZXM6IDxPdmVycmlkZVN0YXRlVHlwZSBleHRlbmRzIFN0YXRlVHlwZT4oKSA9PiBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uPFxuICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uLFxuICAgIE92ZXJyaWRlU3RhdGVUeXBlXG4gID5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VsZWN0b3IgY3JlYXRvciBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbWVtb2l6YXRpb24gZnVuY3Rpb25cbiAqIGFuZCBvcHRpb25zIGZvciBjdXN0b21pemluZyBtZW1vaXphdGlvbiBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBtZW1vaXplYCBmdW5jdGlvbiByZXNwb25zaWJsZSBmb3IgbWVtb2l6aW5nIHRoZSBgcmVzdWx0RnVuY2AgaW5zaWRlIGBjcmVhdGVTZWxlY3RvcmAgKGUuZy4sIGBscnVNZW1vaXplYCBvciBgd2Vha01hcE1lbW9pemVgKS4gSXQgYWxzbyBwcm92aWRlcyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIG1lbW9pemF0aW9uLiBXaGlsZSB0aGUgYG1lbW9pemVgIHByb3BlcnR5IGlzIG1hbmRhdG9yeSwgdGhlIHJlc3QgYXJlIG9wdGlvbmFsLlxuICogQHJldHVybnMgQSBjdXN0b21pemVkIGBjcmVhdGVTZWxlY3RvcmAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjdXN0b21DcmVhdGVTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih7XG4gKiAgIG1lbW9pemU6IGN1c3RvbU1lbW9pemUsIC8vIEZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gbWVtb2l6ZSBgcmVzdWx0RnVuY2BcbiAqICAgbWVtb2l6ZU9wdGlvbnM6IFttZW1vaXplT3B0aW9uMSwgbWVtb2l6ZU9wdGlvbjJdLCAvLyBPcHRpb25zIHBhc3NlZCB0byBgY3VzdG9tTWVtb2l6ZWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvbndhcmRzXG4gKiAgIGFyZ3NNZW1vaXplOiBjdXN0b21BcmdzTWVtb2l6ZSwgLy8gRnVuY3Rpb24gdG8gYmUgdXNlZCB0byBtZW1vaXplIHRoZSBzZWxlY3RvcidzIGFyZ3VtZW50c1xuICogICBhcmdzTWVtb2l6ZU9wdGlvbnM6IFthcmdzTWVtb2l6ZU9wdGlvbjEsIGFyZ3NNZW1vaXplT3B0aW9uMl0gLy8gT3B0aW9ucyBwYXNzZWQgdG8gYGN1c3RvbUFyZ3NNZW1vaXplYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9ud2FyZHNcbiAqIH0pXG4gKlxuICogY29uc3QgY3VzdG9tU2VsZWN0b3IgPSBjdXN0b21DcmVhdGVTZWxlY3RvcihcbiAqICAgW2lucHV0U2VsZWN0b3IxLCBpbnB1dFNlbGVjdG9yMl0sXG4gKiAgIHJlc3VsdEZ1bmMgLy8gYHJlc3VsdEZ1bmNgIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgY3VzdG9tTWVtb2l6ZWBcbiAqIClcbiAqXG4gKiBjdXN0b21TZWxlY3RvcihcbiAqICAgLi4uc2VsZWN0b3JBcmdzIC8vIFdpbGwgYmUgbWVtb2l6ZWQgYnkgYGN1c3RvbUFyZ3NNZW1vaXplYFxuICogKVxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIE1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBtZW1vaXplIHRoZSBgcmVzdWx0RnVuY2AgaW5zaWRlIGBjcmVhdGVTZWxlY3RvcmAgKGUuZy4sIGBscnVNZW1vaXplYCBvciBgd2Vha01hcE1lbW9pemVgKS5cbiAqIEB0ZW1wbGF0ZSBBcmdzTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgb3V0cHV0IHNlbGVjdG9yIGdlbmVyYXRlZCBieSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuIElmIG5vbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCwgYHdlYWtNYXBNZW1vaXplYCB3aWxsIGJlIHVzZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvciN1c2luZy1vcHRpb25zLXNpbmNlLTUwMCBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYH1cbiAqXG4gKiBAc2luY2UgNS4wLjBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjxcbiAgTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyLFxuICBBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gdHlwZW9mIHdlYWtNYXBNZW1vaXplXG4+KFxuICBvcHRpb25zOiBTaW1wbGlmeTxcbiAgICBTZXRSZXF1aXJlZDxcbiAgICAgIENyZWF0ZVNlbGVjdG9yT3B0aW9uczxcbiAgICAgICAgdHlwZW9mIHdlYWtNYXBNZW1vaXplLFxuICAgICAgICB0eXBlb2Ygd2Vha01hcE1lbW9pemUsXG4gICAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxuICAgICAgPixcbiAgICAgICdtZW1vaXplJ1xuICAgID5cbiAgPlxuKTogQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxNZW1vaXplRnVuY3Rpb24sIEFyZ3NNZW1vaXplRnVuY3Rpb24+XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlbGVjdG9yIGNyZWF0b3IgZnVuY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG1lbW9pemF0aW9uIGZ1bmN0aW9uXG4gKiBhbmQgb3B0aW9ucyBmb3IgY3VzdG9taXppbmcgbWVtb2l6YXRpb24gYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIG1lbW9pemUgLSBUaGUgYG1lbW9pemVgIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciBtZW1vaXppbmcgdGhlIGByZXN1bHRGdW5jYCBpbnNpZGUgYGNyZWF0ZVNlbGVjdG9yYCAoZS5nLiwgYGxydU1lbW9pemVgIG9yIGB3ZWFrTWFwTWVtb2l6ZWApLlxuICogQHBhcmFtIG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBtZW1vaXphdGlvbiBmdW5jdGlvbi4gVGhlc2Ugb3B0aW9ucyBhcmUgdGhlbiBwYXNzZWQgdG8gdGhlIG1lbW9pemUgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvbndhcmRzLlxuICogQHJldHVybnMgQSBjdXN0b21pemVkIGBjcmVhdGVTZWxlY3RvcmAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjdXN0b21DcmVhdGVTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcihjdXN0b21NZW1vaXplLCAvLyBGdW5jdGlvbiB0byBiZSB1c2VkIHRvIG1lbW9pemUgYHJlc3VsdEZ1bmNgXG4gKiAgIG9wdGlvbjEsIC8vIFdpbGwgYmUgcGFzc2VkIGFzIHNlY29uZCBhcmd1bWVudCB0byBgY3VzdG9tTWVtb2l6ZWBcbiAqICAgb3B0aW9uMiwgLy8gV2lsbCBiZSBwYXNzZWQgYXMgdGhpcmQgYXJndW1lbnQgdG8gYGN1c3RvbU1lbW9pemVgXG4gKiAgIG9wdGlvbjMgLy8gV2lsbCBiZSBwYXNzZWQgYXMgZm91cnRoIGFyZ3VtZW50IHRvIGBjdXN0b21NZW1vaXplYFxuICogKVxuICpcbiAqIGNvbnN0IGN1c3RvbVNlbGVjdG9yID0gY3VzdG9tQ3JlYXRlU2VsZWN0b3IoXG4gKiAgIFtpbnB1dFNlbGVjdG9yMSwgaW5wdXRTZWxlY3RvcjJdLFxuICogICByZXN1bHRGdW5jIC8vIGByZXN1bHRGdW5jYCB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYGN1c3RvbU1lbW9pemVgXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUgTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGByZXN1bHRGdW5jYCBpbnNpZGUgYGNyZWF0ZVNlbGVjdG9yYCAoZS5nLiwgYGxydU1lbW9pemVgIG9yIGB3ZWFrTWFwTWVtb2l6ZWApLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVTZWxlY3RvckNyZWF0b3IjdXNpbmctbWVtb2l6ZS1hbmQtbWVtb2l6ZW9wdGlvbnMgYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmB9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yPE1lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplcj4oXG4gIG1lbW9pemU6IE1lbW9pemVGdW5jdGlvbixcbiAgLi4ubWVtb2l6ZU9wdGlvbnNGcm9tQXJnczogRHJvcEZpcnN0UGFyYW1ldGVyPE1lbW9pemVGdW5jdGlvbj5cbik6IENyZWF0ZVNlbGVjdG9yRnVuY3Rpb248TWVtb2l6ZUZ1bmN0aW9uPlxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZWxlY3RvciBjcmVhdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBtZW1vaXphdGlvblxuICogZnVuY3Rpb24gYW5kIG9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIG1lbW9pemF0aW9uIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSBtZW1vaXplT3JPcHRpb25zIC0gRWl0aGVyIEEgYG1lbW9pemVgIGZ1bmN0aW9uIG9yIGFuIGBvcHRpb25zYCBvYmplY3QgY29udGFpbmluZyB0aGUgYG1lbW9pemVgIGZ1bmN0aW9uLlxuICogQHBhcmFtIG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBtZW1vaXphdGlvbiBmdW5jdGlvbi4gVGhlc2Ugb3B0aW9ucyBhcmUgdGhlbiBwYXNzZWQgdG8gdGhlIG1lbW9pemUgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvbndhcmRzLlxuICogQHJldHVybnMgQSBjdXN0b21pemVkIGBjcmVhdGVTZWxlY3RvcmAgZnVuY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIE1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBtZW1vaXplIHRoZSBgcmVzdWx0RnVuY2AgaW5zaWRlIGBjcmVhdGVTZWxlY3RvcmAgKGUuZy4sIGBscnVNZW1vaXplYCBvciBgd2Vha01hcE1lbW9pemVgKS5cbiAqIEB0ZW1wbGF0ZSBBcmdzTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgb3V0cHV0IHNlbGVjdG9yIGdlbmVyYXRlZCBieSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuIElmIG5vbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCwgYHdlYWtNYXBNZW1vaXplYCB3aWxsIGJlIHVzZWQuXG4gKiBAdGVtcGxhdGUgTWVtb2l6ZU9yT3B0aW9ucyAtIFRoZSB0eXBlIG9mIHRoZSBmaXJzdCBhcmd1bWVudC4gSXQgY2FuIGVpdGhlciBiZSBhIGBtZW1vaXplYCBmdW5jdGlvbiBvciBhbiBgb3B0aW9uc2Agb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBtZW1vaXplYCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjxcbiAgTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyLFxuICBBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyLFxuICBNZW1vaXplT3JPcHRpb25zIGV4dGVuZHNcbiAgICB8IE1lbW9pemVGdW5jdGlvblxuICAgIHwgU2V0UmVxdWlyZWQ8XG4gICAgICAgIENyZWF0ZVNlbGVjdG9yT3B0aW9uczxNZW1vaXplRnVuY3Rpb24sIEFyZ3NNZW1vaXplRnVuY3Rpb24+LFxuICAgICAgICAnbWVtb2l6ZSdcbiAgICAgID5cbj4oXG4gIG1lbW9pemVPck9wdGlvbnM6IE1lbW9pemVPck9wdGlvbnMsXG4gIC4uLm1lbW9pemVPcHRpb25zRnJvbUFyZ3M6IE1lbW9pemVPck9wdGlvbnMgZXh0ZW5kcyBTZXRSZXF1aXJlZDxcbiAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8TWVtb2l6ZUZ1bmN0aW9uLCBBcmdzTWVtb2l6ZUZ1bmN0aW9uPixcbiAgICAnbWVtb2l6ZSdcbiAgPlxuICAgID8gbmV2ZXJcbiAgICA6IERyb3BGaXJzdFBhcmFtZXRlcjxNZW1vaXplRnVuY3Rpb24+XG4pIHtcbiAgLyoqIG9wdGlvbnMgaW5pdGlhbGx5IHBhc3NlZCBpbnRvIGBjcmVhdGVTZWxlY3RvckNyZWF0b3JgLiAqL1xuICBjb25zdCBjcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zOiBTZXRSZXF1aXJlZDxcbiAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8TWVtb2l6ZUZ1bmN0aW9uLCBBcmdzTWVtb2l6ZUZ1bmN0aW9uPixcbiAgICAnbWVtb2l6ZSdcbiAgPiA9IHR5cGVvZiBtZW1vaXplT3JPcHRpb25zID09PSAnZnVuY3Rpb24nXG4gICAgPyB7XG4gICAgICAgIG1lbW9pemU6IG1lbW9pemVPck9wdGlvbnMgYXMgTWVtb2l6ZUZ1bmN0aW9uLFxuICAgICAgICBtZW1vaXplT3B0aW9uczogbWVtb2l6ZU9wdGlvbnNGcm9tQXJnc1xuICAgICAgfVxuICAgIDogbWVtb2l6ZU9yT3B0aW9uc1xuXG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yID0gPFxuICAgIElucHV0U2VsZWN0b3JzIGV4dGVuZHMgU2VsZWN0b3JBcnJheSxcbiAgICBSZXN1bHQsXG4gICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSBNZW1vaXplRnVuY3Rpb24sXG4gICAgT3ZlcnJpZGVBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gQXJnc01lbW9pemVGdW5jdGlvblxuICA+KFxuICAgIC4uLmNyZWF0ZVNlbGVjdG9yQXJnczogW1xuICAgICAgLi4uaW5wdXRTZWxlY3RvcnM6IFsuLi5JbnB1dFNlbGVjdG9yc10sXG4gICAgICBjb21iaW5lcjogQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4sXG4gICAgICBjcmVhdGVTZWxlY3Rvck9wdGlvbnM/OiBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8XG4gICAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvbixcbiAgICAgICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24sXG4gICAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxuICAgICAgPlxuICAgIF1cbiAgKSA9PiB7XG4gICAgbGV0IHJlY29tcHV0YXRpb25zID0gMFxuICAgIGxldCBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwXG4gICAgbGV0IGxhc3RSZXN1bHQ6IFJlc3VsdFxuXG4gICAgLy8gRHVlIHRvIHRoZSBpbnRyaWNhY2llcyBvZiByZXN0IHBhcmFtcywgd2UgY2FuJ3QgZG8gYW4gb3B0aW9uYWwgYXJnIGFmdGVyIGAuLi5jcmVhdGVTZWxlY3RvckFyZ3NgLlxuICAgIC8vIFNvLCBzdGFydCBieSBkZWNsYXJpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaGVyZS5cbiAgICAvLyAoQW5kIHllcywgdGhlIHdvcmRzICdtZW1vaXplJyBhbmQgJ29wdGlvbnMnIGFwcGVhciB0b28gbWFueSB0aW1lcyBpbiB0aGlzIG5leHQgc2VxdWVuY2UuKVxuICAgIGxldCBkaXJlY3RseVBhc3NlZE9wdGlvbnM6IENyZWF0ZVNlbGVjdG9yT3B0aW9uczxcbiAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgIEFyZ3NNZW1vaXplRnVuY3Rpb24sXG4gICAgICBPdmVycmlkZU1lbW9pemVGdW5jdGlvbixcbiAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxuICAgID4gPSB7fVxuXG4gICAgLy8gTm9ybWFsbHksIHRoZSByZXN1bHQgZnVuYyBvciBcImNvbWJpbmVyXCIgaXMgdGhlIGxhc3QgYXJnXG4gICAgbGV0IHJlc3VsdEZ1bmMgPSBjcmVhdGVTZWxlY3RvckFyZ3MucG9wKCkgYXNcbiAgICAgIHwgQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD5cbiAgICAgIHwgQ3JlYXRlU2VsZWN0b3JPcHRpb25zPFxuICAgICAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgICAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uLFxuICAgICAgICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uLFxuICAgICAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxuICAgICAgICA+XG5cbiAgICAvLyBJZiB0aGUgcmVzdWx0IGZ1bmMgaXMgYWN0dWFsbHkgYW4gX29iamVjdF8sIGFzc3VtZSBpdCdzIG91ciBvcHRpb25zIG9iamVjdFxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmNcbiAgICAgIC8vIGFuZCBwb3AgdGhlIHJlYWwgcmVzdWx0IGZ1bmMgb2ZmXG4gICAgICByZXN1bHRGdW5jID0gY3JlYXRlU2VsZWN0b3JBcmdzLnBvcCgpIGFzIENvbWJpbmVyPElucHV0U2VsZWN0b3JzLCBSZXN1bHQ+XG4gICAgfVxuXG4gICAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICBgY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbiBvdXRwdXQgZnVuY3Rpb24gYWZ0ZXIgdGhlIGlucHV0cywgYnV0IHJlY2VpdmVkOiBbJHt0eXBlb2YgcmVzdWx0RnVuY31dYFxuICAgIClcblxuICAgIC8vIERldGVybWluZSB3aGljaCBzZXQgb2Ygb3B0aW9ucyB3ZSdyZSB1c2luZy4gUHJlZmVyIG9wdGlvbnMgcGFzc2VkIGRpcmVjdGx5LFxuICAgIC8vIGJ1dCBmYWxsIGJhY2sgdG8gb3B0aW9ucyBnaXZlbiB0byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cbiAgICBjb25zdCBjb21iaW5lZE9wdGlvbnMgPSB7XG4gICAgICAuLi5jcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zLFxuICAgICAgLi4uZGlyZWN0bHlQYXNzZWRPcHRpb25zXG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgbWVtb2l6ZSxcbiAgICAgIG1lbW9pemVPcHRpb25zID0gW10sXG4gICAgICBhcmdzTWVtb2l6ZSA9IHdlYWtNYXBNZW1vaXplLFxuICAgICAgYXJnc01lbW9pemVPcHRpb25zID0gW10sXG4gICAgICBkZXZNb2RlQ2hlY2tzID0ge31cbiAgICB9ID0gY29tYmluZWRPcHRpb25zXG5cbiAgICAvLyBTaW1wbGlmeWluZyBhc3N1bXB0aW9uOiBpdCdzIHVubGlrZWx5IHRoYXQgdGhlIGZpcnN0IG9wdGlvbnMgYXJnIG9mIHRoZSBwcm92aWRlZCBtZW1vaXplclxuICAgIC8vIGlzIGFuIGFycmF5LiBJbiBtb3N0IGxpYnMgSSd2ZSBsb29rZWQgYXQsIGl0J3MgYW4gZXF1YWxpdHkgZnVuY3Rpb24gb3Igb3B0aW9ucyBvYmplY3QuXG4gICAgLy8gQmFzZWQgb24gdGhhdCwgaWYgYG1lbW9pemVPcHRpb25zYCBfaXNfIGFuIGFycmF5LCB3ZSBhc3N1bWUgaXQncyBhIGZ1bGxcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGFycmF5IG9mIG9wdGlvbnMuIE90aGVyd2lzZSwgaXQgbXVzdCBiZSBqdXN0IHRoZSBfZmlyc3RfIGFyZywgYW5kIHNvXG4gICAgLy8gd2Ugd3JhcCBpdCBpbiBhbiBhcnJheSBzbyB3ZSBjYW4gYXBwbHkgaXQuXG4gICAgY29uc3QgZmluYWxNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpXG4gICAgY29uc3QgZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMgPSBlbnN1cmVJc0FycmF5KGFyZ3NNZW1vaXplT3B0aW9ucylcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoY3JlYXRlU2VsZWN0b3JBcmdzKSBhcyBJbnB1dFNlbGVjdG9yc1xuXG4gICAgY29uc3QgbWVtb2l6ZWRSZXN1bHRGdW5jID0gbWVtb2l6ZShmdW5jdGlvbiByZWNvbXB1dGF0aW9uV3JhcHBlcigpIHtcbiAgICAgIHJlY29tcHV0YXRpb25zKytcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gKHJlc3VsdEZ1bmMgYXMgQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4pLmFwcGx5KFxuICAgICAgICBudWxsLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgIClcbiAgICB9LCAuLi5maW5hbE1lbW9pemVPcHRpb25zKSBhcyBDb21iaW5lcjxJbnB1dFNlbGVjdG9ycywgUmVzdWx0PiAmXG4gICAgICBFeHRyYWN0TWVtb2l6ZXJGaWVsZHM8T3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24+XG5cbiAgICBsZXQgZmlyc3RSdW4gPSB0cnVlXG5cbiAgICAvLyBJZiBhIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBleGFjdCBzYW1lIGFyZ3VtZW50cyB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIG91ciBkZXBlbmRlbmNpZXMgYWdhaW4uXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBhcmdzTWVtb2l6ZShmdW5jdGlvbiBkZXBlbmRlbmNpZXNDaGVja2VyKCkge1xuICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zKytcbiAgICAgIC8qKiBSZXR1cm4gdmFsdWVzIG9mIGlucHV0IHNlbGVjdG9ycyB3aGljaCB0aGUgYHJlc3VsdEZ1bmNgIHRha2VzIGFzIGFyZ3VtZW50cy4gKi9cbiAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKFxuICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKVxuXG4gICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGFzdFJlc3VsdCA9IG1lbW9pemVkUmVzdWx0RnVuYy5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIGlucHV0U3RhYmlsaXR5Q2hlY2sgfSA9XG4gICAgICAgICAgZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8oZmlyc3RSdW4sIGRldk1vZGVDaGVja3MpXG4gICAgICAgIGlmIChpZGVudGl0eUZ1bmN0aW9uQ2hlY2suc2hvdWxkUnVuKSB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnJ1bihcbiAgICAgICAgICAgIHJlc3VsdEZ1bmMgYXMgQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4sXG4gICAgICAgICAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRTdGFiaWxpdHlDaGVjay5zaG91bGRSdW4pIHtcbiAgICAgICAgICAvLyBtYWtlIGEgc2Vjb25kIGNvcHkgb2YgdGhlIHBhcmFtcywgdG8gY2hlY2sgaWYgd2UgZ290IHRoZSBzYW1lIHJlc3VsdHNcbiAgICAgICAgICBjb25zdCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpbnB1dFN0YWJpbGl0eUNoZWNrLnJ1bihcbiAgICAgICAgICAgIHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9LFxuICAgICAgICAgICAgeyBtZW1vaXplLCBtZW1vaXplT3B0aW9uczogZmluYWxNZW1vaXplT3B0aW9ucyB9LFxuICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0UnVuKSBmaXJzdFJ1biA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0UmVzdWx0XG4gICAgfSwgLi4uZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMpIGFzIHVua25vd24gYXMgU2VsZWN0b3I8XG4gICAgICBHZXRTdGF0ZUZyb21TZWxlY3RvcnM8SW5wdXRTZWxlY3RvcnM+LFxuICAgICAgUmVzdWx0LFxuICAgICAgR2V0UGFyYW1zRnJvbVNlbGVjdG9yczxJbnB1dFNlbGVjdG9ycz5cbiAgICA+ICZcbiAgICAgIEV4dHJhY3RNZW1vaXplckZpZWxkczxPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb24+XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzZWxlY3Rvciwge1xuICAgICAgcmVzdWx0RnVuYyxcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYyxcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9uczogKCkgPT4gZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zLFxuICAgICAgcmVzZXREZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcbiAgICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zID0gMFxuICAgICAgfSxcbiAgICAgIGxhc3RSZXN1bHQ6ICgpID0+IGxhc3RSZXN1bHQsXG4gICAgICByZWNvbXB1dGF0aW9uczogKCkgPT4gcmVjb21wdXRhdGlvbnMsXG4gICAgICByZXNldFJlY29tcHV0YXRpb25zOiAoKSA9PiB7XG4gICAgICAgIHJlY29tcHV0YXRpb25zID0gMFxuICAgICAgfSxcbiAgICAgIG1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZVxuICAgIH0pIGFzIE91dHB1dFNlbGVjdG9yPFxuICAgICAgSW5wdXRTZWxlY3RvcnMsXG4gICAgICBSZXN1bHQsXG4gICAgICBPdmVycmlkZU1lbW9pemVGdW5jdGlvbixcbiAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxuICAgID5cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oY3JlYXRlU2VsZWN0b3IsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVNlbGVjdG9yXG4gIH0pXG5cbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yIGFzIENyZWF0ZVNlbGVjdG9yRnVuY3Rpb248XG4gICAgTWVtb2l6ZUZ1bmN0aW9uLFxuICAgIEFyZ3NNZW1vaXplRnVuY3Rpb25cbiAgPlxufVxuXG4vKipcbiAqIEFjY2VwdHMgb25lIG9yIG1vcmUgXCJpbnB1dCBzZWxlY3RvcnNcIiAoZWl0aGVyIGFzIHNlcGFyYXRlIGFyZ3VtZW50cyBvciBhIHNpbmdsZSBhcnJheSksXG4gKiBhIHNpbmdsZSBcInJlc3VsdCBmdW5jdGlvblwiIC8gXCJjb21iaW5lclwiLCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QsIGFuZFxuICogZ2VuZXJhdGVzIGEgbWVtb2l6ZWQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZVNlbGVjdG9yIGBjcmVhdGVTZWxlY3RvcmB9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2VsZWN0b3IgPVxuICAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKHdlYWtNYXBNZW1vaXplKVxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvcidcblxuaW1wb3J0IHR5cGUgeyBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uIH0gZnJvbSAnLi9jcmVhdGVTZWxlY3RvckNyZWF0b3InXG5pbXBvcnQgdHlwZSB7XG4gIEludGVycnVwdFJlY3Vyc2lvbixcbiAgT2JqZWN0VmFsdWVzVG9UdXBsZSxcbiAgT3V0cHV0U2VsZWN0b3IsXG4gIFNlbGVjdG9yLFxuICBTaW1wbGlmeSxcbiAgVW5rbm93bk1lbW9pemVyXG59IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBhc3NlcnRJc09iamVjdCB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgdHlwZSB7IHdlYWtNYXBNZW1vaXplIH0gZnJvbSAnLi93ZWFrTWFwTWVtb2l6ZSdcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWFwcGluZyBvZiBzZWxlY3RvcnMgdG8gdGhlaXIgcmV0dXJuIHR5cGVzLlxuICpcbiAqIEB0ZW1wbGF0ZSBUT2JqZWN0IC0gQW4gb2JqZWN0IHR5cGUgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgU2VsZWN0b3JSZXN1bHRzTWFwPFRPYmplY3QgZXh0ZW5kcyBTZWxlY3RvcnNPYmplY3Q+ID0ge1xuICBbS2V5IGluIGtleW9mIFRPYmplY3RdOiBSZXR1cm5UeXBlPFRPYmplY3RbS2V5XT5cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWFwcGluZyBvZiBzZWxlY3RvcnMgZm9yIGVhY2gga2V5IGluIGEgZ2l2ZW4gcm9vdCBzdGF0ZS5cbiAqXG4gKiBUaGlzIHR5cGUgaXMgYSB1dGlsaXR5IHRoYXQgdGFrZXMgYSByb290IHN0YXRlIG9iamVjdCB0eXBlIGFuZFxuICogZ2VuZXJhdGVzIGEgY29ycmVzcG9uZGluZyBzZXQgb2Ygc2VsZWN0b3JzLiBFYWNoIHNlbGVjdG9yIGlzIGFzc29jaWF0ZWRcbiAqIHdpdGggYSBrZXkgaW4gdGhlIHJvb3Qgc3RhdGUsIGFsbG93aW5nIGZvciB0aGUgc2VsZWN0aW9uXG4gKiBvZiBzcGVjaWZpYyBwYXJ0cyBvZiB0aGUgc3RhdGUuXG4gKlxuICogQHRlbXBsYXRlIFJvb3RTdGF0ZSAtIFRoZSB0eXBlIG9mIHRoZSByb290IHN0YXRlIG9iamVjdC5cbiAqXG4gKiBAc2luY2UgNS4wLjBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUm9vdFN0YXRlU2VsZWN0b3JzPFJvb3RTdGF0ZSA9IGFueT4gPSB7XG4gIFtLZXkgaW4ga2V5b2YgUm9vdFN0YXRlXTogU2VsZWN0b3I8Um9vdFN0YXRlLCBSb290U3RhdGVbS2V5XSwgW10+XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSB7QGxpbmtjb2RlIFN0cnVjdHVyZWRTZWxlY3RvckNyZWF0b3Iud2l0aFR5cGVzIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci53aXRoVHlwZXM8Um9vdFN0YXRlPigpfSBpbnN0ZWFkLiBUaGlzIHR5cGUgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gKiBAdGVtcGxhdGUgUm9vdFN0YXRlIC0gVGhlIHR5cGUgb2YgdGhlIHJvb3Qgc3RhdGUgb2JqZWN0LlxuICpcbiAqIEBzaW5jZSA1LjAuMFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBUeXBlZFN0cnVjdHVyZWRTZWxlY3RvckNyZWF0b3I8Um9vdFN0YXRlID0gYW55PiA9XG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXQgc2ltcGxpZmllcyByZXR1cm5pbmcgYW4gb2JqZWN0XG4gICAqIG1hZGUgdXAgb2Ygc2VsZWN0b3IgcmVzdWx0cy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0U2VsZWN0b3JzT2JqZWN0IC0gQSBrZXkgdmFsdWUgcGFpciBjb25zaXN0aW5nIG9mIGlucHV0IHNlbGVjdG9ycy5cbiAgICogQHBhcmFtIHNlbGVjdG9yQ3JlYXRvciAtIEEgY3VzdG9tIHNlbGVjdG9yIGNyZWF0b3IgZnVuY3Rpb24uIEl0IGRlZmF1bHRzIHRvIGBjcmVhdGVTZWxlY3RvcmAuXG4gICAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgc3RydWN0dXJlZCBzZWxlY3Rvci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPGNhcHRpb24+TW9kZXJuIFVzZSBDYXNlPC9jYXB0aW9uPlxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnXG4gICAqXG4gICAqIGludGVyZmFjZSBSb290U3RhdGUge1xuICAgKiAgIHRvZG9zOiB7XG4gICAqICAgICBpZDogbnVtYmVyXG4gICAqICAgICBjb21wbGV0ZWQ6IGJvb2xlYW5cbiAgICogICAgIHRpdGxlOiBzdHJpbmdcbiAgICogICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICogICB9W11cbiAgICogICBhbGVydHM6IHsgaWQ6IG51bWJlcjsgcmVhZDogYm9vbGVhbiB9W11cbiAgICogfVxuICAgKlxuICAgKiAvLyBUaGlzOlxuICAgKiBjb25zdCBzdHJ1Y3R1cmVkU2VsZWN0b3IgPSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IoXG4gICAqICAge1xuICAgKiAgICAgdG9kb3M6IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS50b2RvcyxcbiAgICogICAgIGFsZXJ0czogKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFsZXJ0cyxcbiAgICogICAgIHRvZG9CeUlkOiAoc3RhdGU6IFJvb3RTdGF0ZSwgaWQ6IG51bWJlcikgPT4gc3RhdGUudG9kb3NbaWRdXG4gICAqICAgfSxcbiAgICogICBjcmVhdGVTZWxlY3RvclxuICAgKiApXG4gICAqXG4gICAqIC8vIElzIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzIHRoaXM6XG4gICAqIGNvbnN0IHNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAqICAgW1xuICAgKiAgICAgKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zLFxuICAgKiAgICAgKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFsZXJ0cyxcbiAgICogICAgIChzdGF0ZTogUm9vdFN0YXRlLCBpZDogbnVtYmVyKSA9PiBzdGF0ZS50b2Rvc1tpZF1cbiAgICogICBdLFxuICAgKiAgICh0b2RvcywgYWxlcnRzLCB0b2RvQnlJZCkgPT4ge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgdG9kb3MsXG4gICAqICAgICAgIGFsZXJ0cyxcbiAgICogICAgICAgdG9kb0J5SWRcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxjYXB0aW9uPkluIHlvdXIgY29tcG9uZW50OjwvY2FwdGlvbj5cbiAgICogYGBgdHN4XG4gICAqIGltcG9ydCB0eXBlIHsgUm9vdFN0YXRlIH0gZnJvbSAnY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yL21vZGVyblVzZUNhc2UnXG4gICAqIGltcG9ydCB7IHN0cnVjdHVyZWRTZWxlY3RvciB9IGZyb20gJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci9tb2Rlcm5Vc2VDYXNlJ1xuICAgKiBpbXBvcnQgdHlwZSB7IEZDIH0gZnJvbSAncmVhY3QnXG4gICAqIGltcG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAncmVhY3QtcmVkdXgnXG4gICAqXG4gICAqIGludGVyZmFjZSBQcm9wcyB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IE15Q29tcG9uZW50OiBGQzxQcm9wcz4gPSAoeyBpZCB9KSA9PiB7XG4gICAqICAgY29uc3QgeyB0b2RvcywgYWxlcnRzLCB0b2RvQnlJZCB9ID0gdXNlU2VsZWN0b3IoKHN0YXRlOiBSb290U3RhdGUpID0+XG4gICAqICAgICBzdHJ1Y3R1cmVkU2VsZWN0b3Ioc3RhdGUsIGlkKVxuICAgKiAgIClcbiAgICpcbiAgICogICByZXR1cm4gKFxuICAgKiAgICAgPGRpdj5cbiAgICogICAgICAgTmV4dCB0byBkbyBpczpcbiAgICogICAgICAgPGgyPnt0b2RvQnlJZC50aXRsZX08L2gyPlxuICAgKiAgICAgICA8cD5EZXNjcmlwdGlvbjoge3RvZG9CeUlkLmRlc2NyaXB0aW9ufTwvcD5cbiAgICogICAgICAgPHVsPlxuICAgKiAgICAgICAgIDxoMz5BbGwgb3RoZXIgdG8gZG9zOjwvaDM+XG4gICAqICAgICAgICAge3RvZG9zLm1hcCh0b2RvID0+IChcbiAgICogICAgICAgICAgIDxsaSBrZXk9e3RvZG8uaWR9Pnt0b2RvLnRpdGxlfTwvbGk+XG4gICAqICAgICAgICAgKSl9XG4gICAqICAgICAgIDwvdWw+XG4gICAqICAgICA8L2Rpdj5cbiAgICogICApXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxjYXB0aW9uPlNpbXBsZSBVc2UgQ2FzZTwvY2FwdGlvbj5cbiAgICogYGBgdHNcbiAgICogY29uc3Qgc2VsZWN0QSA9IHN0YXRlID0+IHN0YXRlLmFcbiAgICogY29uc3Qgc2VsZWN0QiA9IHN0YXRlID0+IHN0YXRlLmJcbiAgICpcbiAgICogLy8gVGhlIHJlc3VsdCBmdW5jdGlvbiBpbiB0aGUgZm9sbG93aW5nIHNlbGVjdG9yXG4gICAqIC8vIGlzIHNpbXBseSBidWlsZGluZyBhbiBvYmplY3QgZnJvbSB0aGUgaW5wdXQgc2VsZWN0b3JzXG4gICAqIGNvbnN0IHN0cnVjdHVyZWRTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdEEsIHNlbGVjdEIsIChhLCBiKSA9PiAoe1xuICAgKiAgIGEsXG4gICAqICAgYlxuICAgKiB9KSlcbiAgICpcbiAgICogY29uc3QgcmVzdWx0ID0gc3RydWN0dXJlZFNlbGVjdG9yKHsgYTogMSwgYjogMiB9KSAvLyB3aWxsIHByb2R1Y2UgeyB4OiAxLCB5OiAyIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBJbnB1dFNlbGVjdG9yc09iamVjdCAtIFRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzIG9iamVjdC5cbiAgICogQHRlbXBsYXRlIE1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHN0cnVjdHVyZWQgc2VsZWN0b3IuIEl0IGRlZmF1bHRzIHRvIGB3ZWFrTWFwTWVtb2l6ZWAuXG4gICAqIEB0ZW1wbGF0ZSBBcmdzTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBtZW1vaXplIHRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGdlbmVyYXRlZCBzdHJ1Y3R1cmVkIHNlbGVjdG9yLiBJdCBkZWZhdWx0cyB0byBgd2Vha01hcE1lbW9pemVgLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3Jlc2VsZWN0LmpzLm9yZy9hcGkvY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3JgfVxuICAgKi9cbiAgPFxuICAgIElucHV0U2VsZWN0b3JzT2JqZWN0IGV4dGVuZHMgUm9vdFN0YXRlU2VsZWN0b3JzPFJvb3RTdGF0ZT4gPSBSb290U3RhdGVTZWxlY3RvcnM8Um9vdFN0YXRlPixcbiAgICBNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSB0eXBlb2Ygd2Vha01hcE1lbW9pemUsXG4gICAgQXJnc01lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZVxuICA+KFxuICAgIGlucHV0U2VsZWN0b3JzT2JqZWN0OiBJbnB1dFNlbGVjdG9yc09iamVjdCxcbiAgICBzZWxlY3RvckNyZWF0b3I/OiBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uPFxuICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxuICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxuICAgID5cbiAgKSA9PiBPdXRwdXRTZWxlY3RvcjxcbiAgICBPYmplY3RWYWx1ZXNUb1R1cGxlPElucHV0U2VsZWN0b3JzT2JqZWN0PixcbiAgICBTaW1wbGlmeTxTZWxlY3RvclJlc3VsdHNNYXA8SW5wdXRTZWxlY3RvcnNPYmplY3Q+PixcbiAgICBNZW1vaXplRnVuY3Rpb24sXG4gICAgQXJnc01lbW9pemVGdW5jdGlvblxuICA+ICZcbiAgICBJbnRlcnJ1cHRSZWN1cnNpb25cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIFN0YXRlVHlwZSAtIFRoZSB0eXBlIG9mIHN0YXRlIHRoYXQgYWxsIHRoZSBzZWxlY3RvcnMgb3BlcmF0ZSBvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFNlbGVjdG9yc09iamVjdDxTdGF0ZVR5cGUgPSBhbnk+ID0gUmVjb3JkPFxuICBzdHJpbmcsXG4gIFNlbGVjdG9yPFN0YXRlVHlwZT5cbj5cblxuLyoqXG4gKiBJdCBwcm92aWRlcyBhIHdheSB0byBjcmVhdGUgc3RydWN0dXJlZCBzZWxlY3RvcnMuXG4gKiBUaGUgc3RydWN0dXJlZCBzZWxlY3RvciBjYW4gdGFrZSBtdWx0aXBsZSBpbnB1dCBzZWxlY3RvcnNcbiAqIGFuZCBtYXAgdGhlaXIgb3V0cHV0IHRvIGFuIG9iamVjdCB3aXRoIHNwZWNpZmljIGtleXMuXG4gKlxuICogQHRlbXBsYXRlIFN0YXRlVHlwZSAtIFRoZSB0eXBlIG9mIHN0YXRlIHRoYXQgdGhlIHN0cnVjdHVyZWQgc2VsZWN0b3JzIGNyZWF0ZWQgd2l0aCB0aGlzIHN0cnVjdHVyZWQgc2VsZWN0b3IgY3JlYXRvciB3aWxsIG9wZXJhdGUgb24uXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yYH1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RydWN0dXJlZFNlbGVjdG9yQ3JlYXRvcjxTdGF0ZVR5cGUgPSBhbnk+IHtcbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBzaW1wbGlmaWVzIHJldHVybmluZyBhbiBvYmplY3RcbiAgICogbWFkZSB1cCBvZiBzZWxlY3RvciByZXN1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRTZWxlY3RvcnNPYmplY3QgLSBBIGtleSB2YWx1ZSBwYWlyIGNvbnNpc3Rpbmcgb2YgaW5wdXQgc2VsZWN0b3JzLlxuICAgKiBAcGFyYW0gc2VsZWN0b3JDcmVhdG9yIC0gQSBjdXN0b20gc2VsZWN0b3IgY3JlYXRvciBmdW5jdGlvbi4gSXQgZGVmYXVsdHMgdG8gYGNyZWF0ZVNlbGVjdG9yYC5cbiAgICogQHJldHVybnMgQSBtZW1vaXplZCBzdHJ1Y3R1cmVkIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8Y2FwdGlvbj5Nb2Rlcm4gVXNlIENhc2U8L2NhcHRpb24+XG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCdcbiAgICpcbiAgICogaW50ZXJmYWNlIFJvb3RTdGF0ZSB7XG4gICAqICAgdG9kb3M6IHtcbiAgICogICAgIGlkOiBudW1iZXJcbiAgICogICAgIGNvbXBsZXRlZDogYm9vbGVhblxuICAgKiAgICAgdGl0bGU6IHN0cmluZ1xuICAgKiAgICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgKiAgIH1bXVxuICAgKiAgIGFsZXJ0czogeyBpZDogbnVtYmVyOyByZWFkOiBib29sZWFuIH1bXVxuICAgKiB9XG4gICAqXG4gICAqIC8vIFRoaXM6XG4gICAqIGNvbnN0IHN0cnVjdHVyZWRTZWxlY3RvciA9IGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcihcbiAgICogICB7XG4gICAqICAgICB0b2RvczogKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zLFxuICAgKiAgICAgYWxlcnRzOiAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuYWxlcnRzLFxuICAgKiAgICAgdG9kb0J5SWQ6IChzdGF0ZTogUm9vdFN0YXRlLCBpZDogbnVtYmVyKSA9PiBzdGF0ZS50b2Rvc1tpZF1cbiAgICogICB9LFxuICAgKiAgIGNyZWF0ZVNlbGVjdG9yXG4gICAqIClcbiAgICpcbiAgICogLy8gSXMgZXNzZW50aWFsbHkgdGhlIHNhbWUgYXMgdGhpczpcbiAgICogY29uc3Qgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihcbiAgICogICBbXG4gICAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUudG9kb3MsXG4gICAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuYWxlcnRzLFxuICAgKiAgICAgKHN0YXRlOiBSb290U3RhdGUsIGlkOiBudW1iZXIpID0+IHN0YXRlLnRvZG9zW2lkXVxuICAgKiAgIF0sXG4gICAqICAgKHRvZG9zLCBhbGVydHMsIHRvZG9CeUlkKSA9PiB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICB0b2RvcyxcbiAgICogICAgICAgYWxlcnRzLFxuICAgKiAgICAgICB0b2RvQnlJZFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPGNhcHRpb24+SW4geW91ciBjb21wb25lbnQ6PC9jYXB0aW9uPlxuICAgKiBgYGB0c3hcbiAgICogaW1wb3J0IHR5cGUgeyBSb290U3RhdGUgfSBmcm9tICdjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IvbW9kZXJuVXNlQ2FzZSdcbiAgICogaW1wb3J0IHsgc3RydWN0dXJlZFNlbGVjdG9yIH0gZnJvbSAnY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yL21vZGVyblVzZUNhc2UnXG4gICAqIGltcG9ydCB0eXBlIHsgRkMgfSBmcm9tICdyZWFjdCdcbiAgICogaW1wb3J0IHsgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCdcbiAgICpcbiAgICogaW50ZXJmYWNlIFByb3BzIHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgTXlDb21wb25lbnQ6IEZDPFByb3BzPiA9ICh7IGlkIH0pID0+IHtcbiAgICogICBjb25zdCB7IHRvZG9zLCBhbGVydHMsIHRvZG9CeUlkIH0gPSB1c2VTZWxlY3Rvcigoc3RhdGU6IFJvb3RTdGF0ZSkgPT5cbiAgICogICAgIHN0cnVjdHVyZWRTZWxlY3RvcihzdGF0ZSwgaWQpXG4gICAqICAgKVxuICAgKlxuICAgKiAgIHJldHVybiAoXG4gICAqICAgICA8ZGl2PlxuICAgKiAgICAgICBOZXh0IHRvIGRvIGlzOlxuICAgKiAgICAgICA8aDI+e3RvZG9CeUlkLnRpdGxlfTwvaDI+XG4gICAqICAgICAgIDxwPkRlc2NyaXB0aW9uOiB7dG9kb0J5SWQuZGVzY3JpcHRpb259PC9wPlxuICAgKiAgICAgICA8dWw+XG4gICAqICAgICAgICAgPGgzPkFsbCBvdGhlciB0byBkb3M6PC9oMz5cbiAgICogICAgICAgICB7dG9kb3MubWFwKHRvZG8gPT4gKFxuICAgKiAgICAgICAgICAgPGxpIGtleT17dG9kby5pZH0+e3RvZG8udGl0bGV9PC9saT5cbiAgICogICAgICAgICApKX1cbiAgICogICAgICAgPC91bD5cbiAgICogICAgIDwvZGl2PlxuICAgKiAgIClcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPGNhcHRpb24+U2ltcGxlIFVzZSBDYXNlPC9jYXB0aW9uPlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzZWxlY3RBID0gc3RhdGUgPT4gc3RhdGUuYVxuICAgKiBjb25zdCBzZWxlY3RCID0gc3RhdGUgPT4gc3RhdGUuYlxuICAgKlxuICAgKiAvLyBUaGUgcmVzdWx0IGZ1bmN0aW9uIGluIHRoZSBmb2xsb3dpbmcgc2VsZWN0b3JcbiAgICogLy8gaXMgc2ltcGx5IGJ1aWxkaW5nIGFuIG9iamVjdCBmcm9tIHRoZSBpbnB1dCBzZWxlY3RvcnNcbiAgICogY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0QSwgc2VsZWN0QiwgKGEsIGIpID0+ICh7XG4gICAqICAgYSxcbiAgICogICBiXG4gICAqIH0pKVxuICAgKlxuICAgKiBjb25zdCByZXN1bHQgPSBzdHJ1Y3R1cmVkU2VsZWN0b3IoeyBhOiAxLCBiOiAyIH0pIC8vIHdpbGwgcHJvZHVjZSB7IHg6IDEsIHk6IDIgfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIElucHV0U2VsZWN0b3JzT2JqZWN0IC0gVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCBzZWxlY3RvcnMgb2JqZWN0LlxuICAgKiBAdGVtcGxhdGUgTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RydWN0dXJlZCBzZWxlY3Rvci4gSXQgZGVmYXVsdHMgdG8gYHdlYWtNYXBNZW1vaXplYC5cbiAgICogQHRlbXBsYXRlIEFyZ3NNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgb2YgdGhlIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZ2VuZXJhdGVkIHN0cnVjdHVyZWQgc2VsZWN0b3IuIEl0IGRlZmF1bHRzIHRvIGB3ZWFrTWFwTWVtb2l6ZWAuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcmB9XG4gICAqL1xuICA8XG4gICAgSW5wdXRTZWxlY3RvcnNPYmplY3QgZXh0ZW5kcyBTZWxlY3RvcnNPYmplY3Q8U3RhdGVUeXBlPixcbiAgICBNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSB0eXBlb2Ygd2Vha01hcE1lbW9pemUsXG4gICAgQXJnc01lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZVxuICA+KFxuICAgIGlucHV0U2VsZWN0b3JzT2JqZWN0OiBJbnB1dFNlbGVjdG9yc09iamVjdCxcbiAgICBzZWxlY3RvckNyZWF0b3I/OiBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uPFxuICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxuICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxuICAgID5cbiAgKTogT3V0cHV0U2VsZWN0b3I8XG4gICAgT2JqZWN0VmFsdWVzVG9UdXBsZTxJbnB1dFNlbGVjdG9yc09iamVjdD4sXG4gICAgU2ltcGxpZnk8U2VsZWN0b3JSZXN1bHRzTWFwPElucHV0U2VsZWN0b3JzT2JqZWN0Pj4sXG4gICAgTWVtb2l6ZUZ1bmN0aW9uLFxuICAgIEFyZ3NNZW1vaXplRnVuY3Rpb25cbiAgPiAmXG4gICAgSW50ZXJydXB0UmVjdXJzaW9uXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBcInByZS10eXBlZFwiIHZlcnNpb24gb2ZcbiAgICoge0BsaW5rY29kZSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yfVxuICAgKiB3aGVyZSB0aGUgYHN0YXRlYCB0eXBlIGlzIHByZWRlZmluZWQuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIGBzdGF0ZWAgdHlwZSBvbmNlLCBlbGltaW5hdGluZyB0aGUgbmVlZCB0b1xuICAgKiBzcGVjaWZ5IGl0IHdpdGggZXZlcnlcbiAgICoge0BsaW5rY29kZSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yfSBjYWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByZS10eXBlZCBgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yYCB3aXRoIHRoZSBzdGF0ZSB0eXBlIGFscmVhZHkgZGVmaW5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnXG4gICAqXG4gICAqIGV4cG9ydCBpbnRlcmZhY2UgUm9vdFN0YXRlIHtcbiAgICogICB0b2RvczogeyBpZDogbnVtYmVyOyBjb21wbGV0ZWQ6IGJvb2xlYW4gfVtdXG4gICAqICAgYWxlcnRzOiB7IGlkOiBudW1iZXI7IHJlYWQ6IGJvb2xlYW4gfVtdXG4gICAqIH1cbiAgICpcbiAgICogZXhwb3J0IGNvbnN0IGNyZWF0ZVN0cnVjdHVyZWRBcHBTZWxlY3RvciA9XG4gICAqICAgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLndpdGhUeXBlczxSb290U3RhdGU+KClcbiAgICpcbiAgICogY29uc3Qgc3RydWN0dXJlZEFwcFNlbGVjdG9yID0gY3JlYXRlU3RydWN0dXJlZEFwcFNlbGVjdG9yKHtcbiAgICogICAvLyBUeXBlIG9mIGBzdGF0ZWAgaXMgc2V0IHRvIGBSb290U3RhdGVgLCBubyBuZWVkIHRvIG1hbnVhbGx5IHNldCB0aGUgdHlwZVxuICAgKiAgIHRvZG9zOiBzdGF0ZSA9PiBzdGF0ZS50b2RvcyxcbiAgICogICBhbGVydHM6IHN0YXRlID0+IHN0YXRlLmFsZXJ0cyxcbiAgICogICB0b2RvQnlJZDogKHN0YXRlLCBpZDogbnVtYmVyKSA9PiBzdGF0ZS50b2Rvc1tpZF1cbiAgICogfSlcbiAgICpcbiAgICogYGBgXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZVN0YXRlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHN0YXRlIHVzZWQgYnkgYWxsIHN0cnVjdHVyZWQgc2VsZWN0b3JzIGNyZWF0ZWQgd2l0aCB0aGlzIHN0cnVjdHVyZWQgc2VsZWN0b3IgY3JlYXRvci5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZXN0cnVjdHVyZWRzZWxlY3RvciNkZWZpbmluZy1hLXByZS10eXBlZC1jcmVhdGVzdHJ1Y3R1cmVkc2VsZWN0b3IgYGNyZWF0ZVNlbGVjdG9yLndpdGhUeXBlc2B9XG4gICAqXG4gICAqIEBzaW5jZSA1LjEuMFxuICAgKi9cbiAgd2l0aFR5cGVzOiA8XG4gICAgT3ZlcnJpZGVTdGF0ZVR5cGUgZXh0ZW5kcyBTdGF0ZVR5cGVcbiAgPigpID0+IFN0cnVjdHVyZWRTZWxlY3RvckNyZWF0b3I8T3ZlcnJpZGVTdGF0ZVR5cGU+XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0IHNpbXBsaWZpZXMgcmV0dXJuaW5nIGFuIG9iamVjdFxuICogbWFkZSB1cCBvZiBzZWxlY3RvciByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSBpbnB1dFNlbGVjdG9yc09iamVjdCAtIEEga2V5IHZhbHVlIHBhaXIgY29uc2lzdGluZyBvZiBpbnB1dCBzZWxlY3RvcnMuXG4gKiBAcGFyYW0gc2VsZWN0b3JDcmVhdG9yIC0gQSBjdXN0b20gc2VsZWN0b3IgY3JlYXRvciBmdW5jdGlvbi4gSXQgZGVmYXVsdHMgdG8gYGNyZWF0ZVNlbGVjdG9yYC5cbiAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgc3RydWN0dXJlZCBzZWxlY3Rvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNhcHRpb24+TW9kZXJuIFVzZSBDYXNlPC9jYXB0aW9uPlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCdcbiAqXG4gKiBpbnRlcmZhY2UgUm9vdFN0YXRlIHtcbiAqICAgdG9kb3M6IHtcbiAqICAgICBpZDogbnVtYmVyXG4gKiAgICAgY29tcGxldGVkOiBib29sZWFuXG4gKiAgICAgdGl0bGU6IHN0cmluZ1xuICogICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAqICAgfVtdXG4gKiAgIGFsZXJ0czogeyBpZDogbnVtYmVyOyByZWFkOiBib29sZWFuIH1bXVxuICogfVxuICpcbiAqIC8vIFRoaXM6XG4gKiBjb25zdCBzdHJ1Y3R1cmVkU2VsZWN0b3IgPSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IoXG4gKiAgIHtcbiAqICAgICB0b2RvczogKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zLFxuICogICAgIGFsZXJ0czogKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFsZXJ0cyxcbiAqICAgICB0b2RvQnlJZDogKHN0YXRlOiBSb290U3RhdGUsIGlkOiBudW1iZXIpID0+IHN0YXRlLnRvZG9zW2lkXVxuICogICB9LFxuICogICBjcmVhdGVTZWxlY3RvclxuICogKVxuICpcbiAqIC8vIElzIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzIHRoaXM6XG4gKiBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKFxuICogICBbXG4gKiAgICAgKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zLFxuICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5hbGVydHMsXG4gKiAgICAgKHN0YXRlOiBSb290U3RhdGUsIGlkOiBudW1iZXIpID0+IHN0YXRlLnRvZG9zW2lkXVxuICogICBdLFxuICogICAodG9kb3MsIGFsZXJ0cywgdG9kb0J5SWQpID0+IHtcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgdG9kb3MsXG4gKiAgICAgICBhbGVydHMsXG4gKiAgICAgICB0b2RvQnlJZFxuICogICAgIH1cbiAqICAgfVxuICogKVxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yYH1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3I6IFN0cnVjdHVyZWRTZWxlY3RvckNyZWF0b3IgPVxuICBPYmplY3QuYXNzaWduKFxuICAgIDxcbiAgICAgIElucHV0U2VsZWN0b3JzT2JqZWN0IGV4dGVuZHMgU2VsZWN0b3JzT2JqZWN0LFxuICAgICAgTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gdHlwZW9mIHdlYWtNYXBNZW1vaXplLFxuICAgICAgQXJnc01lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZVxuICAgID4oXG4gICAgICBpbnB1dFNlbGVjdG9yc09iamVjdDogSW5wdXRTZWxlY3RvcnNPYmplY3QsXG4gICAgICBzZWxlY3RvckNyZWF0b3I6IENyZWF0ZVNlbGVjdG9yRnVuY3Rpb248XG4gICAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxuICAgICAgPiA9IGNyZWF0ZVNlbGVjdG9yIGFzIENyZWF0ZVNlbGVjdG9yRnVuY3Rpb248XG4gICAgICAgIE1lbW9pemVGdW5jdGlvbixcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxuICAgICAgPlxuICAgICkgPT4ge1xuICAgICAgYXNzZXJ0SXNPYmplY3QoXG4gICAgICAgIGlucHV0U2VsZWN0b3JzT2JqZWN0LFxuICAgICAgICAnY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGV4cGVjdHMgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0ICcgK1xuICAgICAgICAgIGB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAke3R5cGVvZiBpbnB1dFNlbGVjdG9yc09iamVjdH1gXG4gICAgICApXG4gICAgICBjb25zdCBpbnB1dFNlbGVjdG9yS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U2VsZWN0b3JzT2JqZWN0KVxuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gaW5wdXRTZWxlY3RvcktleXMubWFwKFxuICAgICAgICBrZXkgPT4gaW5wdXRTZWxlY3RvcnNPYmplY3Rba2V5XVxuICAgICAgKVxuICAgICAgY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKFxuICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgICguLi5pbnB1dFNlbGVjdG9yUmVzdWx0czogYW55W10pID0+IHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHMucmVkdWNlKChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb21wb3NpdGlvbltpbnB1dFNlbGVjdG9yS2V5c1tpbmRleF1dID0gdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGlvblxuICAgICAgICAgIH0sIHt9KVxuICAgICAgICB9XG4gICAgICApXG4gICAgICByZXR1cm4gc3RydWN0dXJlZFNlbGVjdG9yXG4gICAgfSxcbiAgICB7IHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH1cbiAgKSBhcyBTdHJ1Y3R1cmVkU2VsZWN0b3JDcmVhdG9yXG4iLCIvLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoeyBkaXNwYXRjaCwgZ2V0U3RhdGUgfSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG4gIHJldHVybiBtaWRkbGV3YXJlO1xufVxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG52YXIgd2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5leHBvcnQge1xuICB0aHVuayxcbiAgd2l0aEV4dHJhQXJndW1lbnRcbn07XG4iLCJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3RPcmlnaW5hbCBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdCA9IChcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEB0cy1pZ25vcmVcbiAgXCJkZWZhdWx0XCIgaW4gUmVhY3RPcmlnaW5hbCA/IFJlYWN0T3JpZ2luYWxbXCJkZWZhdWx0XCJdIDogUmVhY3RPcmlnaW5hbFxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xudmFyIENvbnRleHRLZXkgPSBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHZhciBfYTtcbiAgaWYgKCFSZWFjdC5jcmVhdGVDb250ZXh0KVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgY29udGV4dE1hcCA9IChfYSA9IGdUW0NvbnRleHRLZXldKSAhPSBudWxsID8gX2EgOiBnVFtDb250ZXh0S2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJlYWN0UmVkdXhcIjtcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpO1xuICB9XG4gIHJldHVybiByZWFsQ29udGV4dDtcbn1cbnZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRDb250ZXh0KCk7XG5cbi8vIHNyYy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS50c1xudmFyIG5vdEluaXRpYWxpemVkID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1U0VTIG5vdCBpbml0aWFsaXplZCFcIik7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlUmVkdXhDb250ZXh0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0MigpIHtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImNvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxudmFyIHVzZVJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVSZWR1eENvbnRleHRIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTZWxlY3Rvci50c1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZm47XG59O1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZVNlbGVjdG9yMiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHksIGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYW4gZXF1YWxpdHkgZnVuY3Rpb24gdG8gdXNlU2VsZWN0b3JgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGUsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgY29uc3QgZmlyc3RSdW4gPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICB7XG4gICAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2s6IGZpbmFsU3RhYmlsaXR5Q2hlY2tcbiAgICAgICAgICAgIH0gPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICAgICAgICAgIH0sIGRldk1vZGVDaGVja3MpO1xuICAgICAgICAgICAgaWYgKGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB0b0NvbXBhcmUgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgICAgIGlmICghZXF1YWxpdHlGbihzZWxlY3RlZCwgdG9Db21wYXJlKSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIGEgbmV3IHJlZmVyZW5jZSAoc3VjaCBhcyBhbiBvYmplY3Qgb3IgYW4gYXJyYXkpIHNob3VsZCBiZSBtZW1vaXplZDogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdXNhZ2UvZGVyaXZpbmctZGF0YS1zZWxlY3RvcnMjb3B0aW1pemluZy1zZWxlY3RvcnMtd2l0aC1tZW1vaXphdGlvblwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkMjogdG9Db21wYXJlLFxuICAgICAgICAgICAgICAgICAgICBzdGFja1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCB0aGUgcm9vdCBzdGF0ZSB3aGVuIGNhbGxlZC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUgYXJlIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlLCBhcyB0aGV5IHdpbGwgY2F1c2UgYSByZXJlbmRlciB3aGVuZXZlciAqYW55dGhpbmcqIGluIHN0YXRlIGNoYW5nZXMuXCIsXG4gICAgICAgICAgICAgICAgICB7IHN0YWNrIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RSdW4uY3VycmVudClcbiAgICAgICAgICAgICAgZmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1bc2VsZWN0b3IubmFtZV0sXG4gICAgICBbc2VsZWN0b3IsIHN0YWJpbGl0eUNoZWNrLCBkZXZNb2RlQ2hlY2tzLnN0YWJpbGl0eUNoZWNrXVxuICAgICk7XG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1YixcbiAgICAgIHN0b3JlLmdldFN0YXRlLFxuICAgICAgZ2V0U2VydmVyU3RhdGUgfHwgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBlcXVhbGl0eUZuXG4gICAgKTtcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVNlbGVjdG9yMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gdXNlU2VsZWN0b3IyO1xufVxudmFyIHVzZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9ySG9vaygpO1xuXG4vLyBzcmMvdXRpbHMvcmVhY3QtaXMudHNcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnNlcnZlcl9jb250ZXh0XCIpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0ICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6IHtcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cblxuLy8gc3JjL3V0aWxzL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMudHNcbmZ1bmN0aW9uIHZlcmlmeShzZWxlY3RvciwgbWV0aG9kTmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYCk7XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gXCJtYXBTdGF0ZVRvUHJvcHNcIiB8fCBtZXRob2ROYW1lID09PSBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZWN0b3IsIFwiZGVwZW5kc09uT3duUHJvcHNcIikpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGBUaGUgc2VsZWN0b3IgZm9yICR7bWV0aG9kTmFtZX0gb2YgY29ubmVjdCBkaWQgbm90IHNwZWNpZnkgYSB2YWx1ZSBmb3IgZGVwZW5kc09uT3duUHJvcHMuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICB2ZXJpZnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG4gIHZlcmlmeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS50c1xuZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCB7XG4gIGFyZVN0YXRlc0VxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWxcbn0pIHtcbiAgbGV0IGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIGxldCBzdGF0ZTtcbiAgbGV0IG93blByb3BzO1xuICBsZXQgc3RhdGVQcm9wcztcbiAgbGV0IGRpc3BhdGNoUHJvcHM7XG4gIGxldCBtZXJnZWRQcm9wcztcbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIGNvbnN0IG5leHRTdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgaWYgKHN0YXRlUHJvcHNDaGFuZ2VkKVxuICAgICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VkID0gIWFyZVN0YXRlc0VxdWFsKFxuICAgICAgbmV4dFN0YXRlLFxuICAgICAgc3RhdGUsXG4gICAgICBuZXh0T3duUHJvcHMsXG4gICAgICBvd25Qcm9wc1xuICAgICk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpXG4gICAgICByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpXG4gICAgICByZXR1cm4gaGFuZGxlTmV3UHJvcHMoKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KGRpc3BhdGNoLCBfYSkge1xuICB2YXIgX2IgPSBfYSwge1xuICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICBpbml0TWVyZ2VQcm9wc1xuICB9ID0gX2IsIG9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcbiAgICBcImluaXRNYXBTdGF0ZVRvUHJvcHNcIixcbiAgICBcImluaXRNYXBEaXNwYXRjaFRvUHJvcHNcIixcbiAgICBcImluaXRNZXJnZVByb3BzXCJcbiAgXSk7XG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMudHNcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSAoLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvciguLi5hcmdzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgaWYgKHByb3RvID09PSBudWxsKVxuICAgIHJldHVybiB0cnVlO1xuICBsZXQgYmFzZVByb3RvID0gcHJvdG87XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKSAhPT0gbnVsbCkge1xuICAgIGJhc2VQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pO1xuICB9XG4gIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xufVxuXG4vLyBzcmMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KHZhbHVlLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGAke21ldGhvZE5hbWV9KCkgaW4gJHtkaXNwbGF5TmFtZX0gbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHt2YWx1ZX0uYFxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMudHNcbmZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCk7XG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn1cbmZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSB9KSB7XG4gICAgY29uc3QgcHJveHkgPSBmdW5jdGlvbiBtYXBUb1Byb3BzUHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCB2b2lkIDApO1xuICAgIH07XG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBmdW5jdGlvbiBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBtYXBUb1Byb3BzO1xuICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKTtcbiAgICAgIGxldCBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBwcm9wcztcbiAgICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhwcm9wcyk7XG4gICAgICAgIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChwcm9wcywgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufVxuXG4vLyBzcmMvY29ubmVjdC9pbnZhbGlkQXJnRmFjdG9yeS50c1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkoYXJnLCBuYW1lKSB7XG4gIHJldHVybiAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFyZ30gZm9yICR7bmFtZX0gYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAke29wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWV9LmBcbiAgICApO1xuICB9O1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gXCJvYmplY3RcIiA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoXG4gICAgKGRpc3BhdGNoKSA9PiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaClcbiAgICApXG4gICkgOiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoZGlzcGF0Y2gpID0+ICh7XG4gICAgZGlzcGF0Y2hcbiAgfSkpIDogdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcFN0YXRlVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSkgOiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tZXJnZVByb3BzLnRzXG5mdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG93blByb3BzKSwgc3RhdGVQcm9wcyksIGRpc3BhdGNoUHJvcHMpO1xufVxuZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUsIGFyZU1lcmdlZFByb3BzRXF1YWwgfSkge1xuICAgIGxldCBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgbGV0IG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIGNvbnN0IG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKVxuICAgICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgXCJtZXJnZVByb3BzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKSB7XG4gIHJldHVybiAhbWVyZ2VQcm9wcyA/ICgpID0+IGRlZmF1bHRNZXJnZVByb3BzIDogdHlwZW9mIG1lcmdlUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JhdGNoLnRzXG5mdW5jdGlvbiBkZWZhdWx0Tm9vcEJhdGNoKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbi8vIHNyYy91dGlscy9TdWJzY3JpcHRpb24udHNcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpIHtcbiAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgbGV0IGxhc3QgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGNsZWFyKCkge1xuICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgbGFzdCA9IG51bGw7XG4gICAgfSxcbiAgICBub3RpZnkoKSB7XG4gICAgICBkZWZhdWx0Tm9vcEJhdGNoKCgpID0+IHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG4gICAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrKCk7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gbGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHByZXY6IGxhc3RcbiAgICAgIH07XG4gICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0ID0gbGlzdGVuZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGZpcnN0ID09PSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChsaXN0ZW5lci5uZXh0KSB7XG4gICAgICAgICAgbGlzdGVuZXIubmV4dC5wcmV2ID0gbGlzdGVuZXIucHJldjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0ID0gbGlzdGVuZXIucHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnkoKSB7XG4gIH0sXG4gIGdldDogKCkgPT4gW11cbn07XG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xuICBsZXQgdW5zdWJzY3JpYmU7XG4gIGxldCBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICBsZXQgc3Vic2NyaXB0aW9uc0Ftb3VudCA9IDA7XG4gIGxldCBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBhZGROZXN0ZWRTdWIobGlzdGVuZXIpIHtcbiAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICBjb25zdCBjbGVhbnVwTGlzdGVuZXIgPSBsaXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJlbW92ZWQpIHtcbiAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lcigpO1xuICAgICAgICB0cnlVbnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICBsaXN0ZW5lcnMubm90aWZ5KCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlV3JhcHBlcigpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gc2VsZlN1YnNjcmliZWQ7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQrKztcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICB1bnN1YnNjcmliZSA9IHBhcmVudFN1YiA/IHBhcmVudFN1Yi5hZGROZXN0ZWRTdWIoaGFuZGxlQ2hhbmdlV3JhcHBlcikgOiBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlQ2hhbmdlV3JhcHBlcik7XG4gICAgICBsaXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudC0tO1xuICAgIGlmICh1bnN1YnNjcmliZSAmJiBzdWJzY3JpcHRpb25zQW1vdW50ID09PSAwKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgdW5zdWJzY3JpYmUgPSB2b2lkIDA7XG4gICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKCFzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB0cnlVbnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgYWRkTmVzdGVkU3ViLFxuICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgaGFuZGxlQ2hhbmdlV3JhcHBlcixcbiAgICBpc1N1YnNjcmliZWQsXG4gICAgdHJ5U3Vic2NyaWJlOiB0cnlTdWJzY3JpYmVTZWxmLFxuICAgIHRyeVVuc3Vic2NyaWJlOiB0cnlVbnN1YnNjcmliZVNlbGYsXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QudHNcbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4vLyBzcmMvdXRpbHMvc2hhbGxvd0VxdWFsLnRzXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9ob2lzdFN0YXRpY3MudHNcbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge1xuICBbRm9yd2FyZFJlZl06IEZPUldBUkRfUkVGX1NUQVRJQ1MsXG4gIFtNZW1vXTogTUVNT19TVEFUSUNTXG59O1xuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgaWYgKGlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfVxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFtcIiQkdHlwZW9mXCJdXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgY29uc3QgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvY29ubmVjdC50c3hcbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IG5vdEluaXRpYWxpemVkO1xudmFyIGluaXRpYWxpemVDb25uZWN0ID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZm47XG59O1xudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcbnZhciBzdHJpbmdpZnlDb21wb25lbnQgPSAoQ29tcCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhlZmZlY3RGdW5jLCBlZmZlY3RBcmdzLCBkZXBlbmRlbmNpZXMpIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBlZmZlY3RGdW5jKC4uLmVmZmVjdEFyZ3MpLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vicykge1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHM7XG4gIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGlzTW91bnRlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKSB7XG4gIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IoXG4gICAgICAgIGxhdGVzdFN0b3JlU3RhdGUsXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcbiAgICB9XG4gIH07XG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufVxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCB7XG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBwdXJlLFxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIC8vIHVzZSBSZWFjdCdzIGZvcndhcmRSZWYgdG8gZXhwb3NlIGEgcmVmIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudFxuICBmb3J3YXJkUmVmID0gZmFsc2UsXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxuICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHRcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHB1cmUgIT09IHZvaWQgMCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSAoV3JhcHBlZENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIjtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBfYSA9IHByb3BzLCB7IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyIH0gPSBfYSwgd3JhcHBlclByb3BzMiA9IF9fb2JqUmVzdChfYSwgW1wicmVhY3RSZWR1eEZvcndhcmRlZFJlZlwiXSk7XG4gICAgICAgIHJldHVybiBbcHJvcHMuY29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIHdyYXBwZXJQcm9wczJdO1xuICAgICAgfSwgW3Byb3BzXSk7XG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IFJlc3VsdENvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICBpZiAocHJvcHNDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwcm9wc0NvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcylcbiAgICAgICAgICByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb250ZXh0VmFsdWUpLCB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmdEaXNwYXRjaCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZigpO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhY3R1YWxDaGlsZFByb3BzKSwge1xuICAgICAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHsgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG4gICAgY29uc3QgX0Nvbm5lY3QgPSBSZWFjdC5tZW1vKENvbm5lY3RGdW5jdGlvbik7XG4gICAgY29uc3QgQ29ubmVjdCA9IF9Db25uZWN0O1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHsgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHNlcnZlclN0YXRlLFxuICBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiLFxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSBcIm9uY2VcIlxufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdm9pZCAwLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9O1xuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlLCBzdGFiaWxpdHlDaGVjaywgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn1cbnZhciBQcm92aWRlcl9kZWZhdWx0ID0gUHJvdmlkZXI7XG5cbi8vIHNyYy9ob29rcy91c2VTdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dClcbiAgKTtcbiAgY29uc3QgdXNlU3RvcmUyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTdG9yZTJcbiAgfSk7XG4gIHJldHVybiB1c2VTdG9yZTI7XG59XG52YXIgdXNlU3RvcmUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU3RvcmVIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VEaXNwYXRjaC50c1xuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZTIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VEaXNwYXRjaDIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZTIoKTtcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlRGlzcGF0Y2gyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VEaXNwYXRjaDJcbiAgfSk7XG4gIHJldHVybiB1c2VEaXNwYXRjaDI7XG59XG52YXIgdXNlRGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGlzcGF0Y2hIb29rKCk7XG5cbi8vIHNyYy9leHBvcnRzLnRzXG52YXIgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoO1xuXG4vLyBzcmMvaW5kZXgudHNcbmluaXRpYWxpemVVc2VTZWxlY3Rvcih1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIpO1xuaW5pdGlhbGl6ZUNvbm5lY3QoUmVhY3QyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKTtcbmV4cG9ydCB7XG4gIFByb3ZpZGVyX2RlZmF1bHQgYXMgUHJvdmlkZXIsXG4gIFJlYWN0UmVkdXhDb250ZXh0LFxuICBiYXRjaCxcbiAgY29ubmVjdF9kZWZhdWx0IGFzIGNvbm5lY3QsXG4gIGNyZWF0ZURpc3BhdGNoSG9vayxcbiAgY3JlYXRlU2VsZWN0b3JIb29rLFxuICBjcmVhdGVTdG9yZUhvb2ssXG4gIHNoYWxsb3dFcXVhbCxcbiAgdXNlRGlzcGF0Y2gsXG4gIHVzZVNlbGVjdG9yLFxuICB1c2VTdG9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlZHV4LmxlZ2FjeS1lc20uanMubWFwIiwiLy8gVGhlIHByaW1hcnkgZW50cnkgcG9pbnQgYXNzdW1lcyB3ZSBhcmUgd29ya2luZyB3aXRoIFJlYWN0IDE4LCBhbmQgdGh1cyBoYXZlXG4vLyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhdmFpbGFibGUuIFdlIGNhbiBpbXBvcnQgdGhhdCBkaXJlY3RseSBmcm9tIFJlYWN0IGl0c2VsZi5cbi8vIFRoZSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBoYXMgdG8gYmUgaW1wb3J0ZWQsIGJ1dCB3ZSBjYW4gdXNlIHRoZVxuLy8gbm9uLXNoaW0gdmVyc2lvbi4gVGhpcyBzaGF2ZXMgb2ZmIHRoZSBieXRlIHNpemUgb2YgdGhlIHNoaW0uXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzJ1xuXG5pbXBvcnQgeyBpbml0aWFsaXplVXNlU2VsZWN0b3IgfSBmcm9tICcuL2hvb2tzL3VzZVNlbGVjdG9yJ1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUNvbm5lY3QgfSBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdCdcblxuaW5pdGlhbGl6ZVVzZVNlbGVjdG9yKHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKVxuaW5pdGlhbGl6ZUNvbm5lY3QoUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUpXG5cbmV4cG9ydCAqIGZyb20gJy4vZXhwb3J0cydcbiIsImltcG9ydCAqIGFzIFJlYWN0T3JpZ2luYWwgZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSAqIGFzIFJlYWN0TmFtZXNwYWNlIGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgUmVhY3Q6IHR5cGVvZiBSZWFjdE5hbWVzcGFjZSA9XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICAvLyBAdHMtaWdub3JlXG4gICdkZWZhdWx0JyBpbiBSZWFjdE9yaWdpbmFsID8gUmVhY3RPcmlnaW5hbFsnZGVmYXVsdCddIDogUmVhY3RPcmlnaW5hbCBhcyBhbnlcbiIsImltcG9ydCB0eXBlIHsgQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgUmVhY3QgfSBmcm9tICcuLi91dGlscy9yZWFjdCdcbmltcG9ydCB0eXBlIHsgQWN0aW9uLCBTdG9yZSwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHR5cGUgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nXG5pbXBvcnQgdHlwZSB7IFByb3ZpZGVyUHJvcHMgfSBmcm9tICcuL1Byb3ZpZGVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWN0UmVkdXhDb250ZXh0VmFsdWU8XG4gIFNTID0gYW55LFxuICBBIGV4dGVuZHMgQWN0aW9uPHN0cmluZz4gPSBVbmtub3duQWN0aW9uXG4+IGV4dGVuZHMgUGljazxQcm92aWRlclByb3BzLCAnc3RhYmlsaXR5Q2hlY2snIHwgJ2lkZW50aXR5RnVuY3Rpb25DaGVjayc+IHtcbiAgc3RvcmU6IFN0b3JlPFNTLCBBPlxuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICBnZXRTZXJ2ZXJTdGF0ZT86ICgpID0+IFNTXG59XG5cbmNvbnN0IENvbnRleHRLZXkgPSBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YClcbmNvbnN0IGdUOiB7XG4gIFtDb250ZXh0S2V5XT86IE1hcDxcbiAgICB0eXBlb2YgUmVhY3QuY3JlYXRlQ29udGV4dCxcbiAgICBDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfCBudWxsPlxuICA+XG59ID0gKFxuICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGdsb2JhbFRoaXNcbiAgICA6IC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqLyB7fVxuKSBhcyBhbnlcblxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpOiBDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfCBudWxsPiB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dCkgcmV0dXJuIHt9IGFzIGFueVxuXG4gIGNvbnN0IGNvbnRleHRNYXAgPSAoZ1RbQ29udGV4dEtleV0gPz89IG5ldyBNYXA8XG4gICAgdHlwZW9mIFJlYWN0LmNyZWF0ZUNvbnRleHQsXG4gICAgQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlIHwgbnVsbD5cbiAgPigpKVxuICBsZXQgcmVhbENvbnRleHQgPSBjb250ZXh0TWFwLmdldChSZWFjdC5jcmVhdGVDb250ZXh0KVxuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfCBudWxsPihcbiAgICAgIG51bGwgYXMgYW55LFxuICAgIClcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSAnUmVhY3RSZWR1eCdcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpXG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0XG59XG5cbmV4cG9ydCBjb25zdCBSZWFjdFJlZHV4Q29udGV4dCA9IC8qI19fUFVSRV9fKi8gZ2V0Q29udGV4dCgpXG5cbmV4cG9ydCB0eXBlIFJlYWN0UmVkdXhDb250ZXh0SW5zdGFuY2UgPSB0eXBlb2YgUmVhY3RSZWR1eENvbnRleHRcblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RSZWR1eENvbnRleHRcbiIsImltcG9ydCB0eXBlIHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZSdcbmltcG9ydCB0eXBlIHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yJ1xuXG5leHBvcnQgY29uc3Qgbm90SW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigndVNFUyBub3QgaW5pdGlhbGl6ZWQhJylcbn1cblxuZXhwb3J0IHR5cGUgdVNFUyA9IHR5cGVvZiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVxuZXhwb3J0IHR5cGUgdVNFU1dTID0gdHlwZW9mIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yXG4iLCJpbXBvcnQgeyBSZWFjdCB9IGZyb20gJy4uL3V0aWxzL3JlYWN0J1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnXG5pbXBvcnQgdHlwZSB7IFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnXG5cbi8qKlxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZVJlZHV4Q29udGV4dGAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuIFRoaXMgaXMgYSBsb3ctbGV2ZWxcbiAqIGhvb2sgdGhhdCB5b3Ugc2hvdWxkIHVzdWFsbHkgbm90IG5lZWQgdG8gY2FsbCBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0LkNvbnRleHR9IFtjb250ZXh0PVJlYWN0UmVkdXhDb250ZXh0XSBDb250ZXh0IHBhc3NlZCB0byB5b3VyIGA8UHJvdmlkZXI+YC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlUmVkdXhDb250ZXh0YCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQoKTogUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+JyxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFZhbHVlIVxuICB9XG59XG5cbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgdmFsdWUgb2YgdGhlIGBSZWFjdFJlZHV4Q29udGV4dGAuIFRoaXMgaXMgYSBsb3ctbGV2ZWxcbiAqIGhvb2sgdGhhdCB5b3Ugc2hvdWxkIHVzdWFsbHkgbm90IG5lZWQgdG8gY2FsbCBkaXJlY3RseS5cbiAqXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgdmFsdWUgb2YgdGhlIGBSZWFjdFJlZHV4Q29udGV4dGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQoKVxuICogICByZXR1cm4gPGRpdj57c3RvcmUuZ2V0U3RhdGUoKX08L2Rpdj5cbiAqIH1cbiAqL1xuZXhwb3J0IGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlUmVkdXhDb250ZXh0SG9vaygpXG4iLCIvL2ltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgUmVhY3QgfSBmcm9tICcuLi91dGlscy9yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBSZWFjdFJlZHV4Q29udGV4dFZhbHVlIH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnXG5pbXBvcnQgdHlwZSB7IEVxdWFsaXR5Rm4sIE5vSW5mZXIgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB0eXBlIHsgdVNFU1dTIH0gZnJvbSAnLi4vdXRpbHMvdXNlU3luY0V4dGVybmFsU3RvcmUnXG5pbXBvcnQgeyBub3RJbml0aWFsaXplZCB9IGZyb20gJy4uL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlJ1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayxcbiAgdXNlUmVkdXhDb250ZXh0IGFzIHVzZURlZmF1bHRSZWR1eENvbnRleHQsXG59IGZyb20gJy4vdXNlUmVkdXhDb250ZXh0J1xuXG4vKipcbiAqIFRoZSBmcmVxdWVuY3kgb2YgZGV2ZWxvcG1lbnQgbW9kZSBjaGVja3MuXG4gKlxuICogQHNpbmNlIDguMS4wXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgRGV2TW9kZUNoZWNrRnJlcXVlbmN5ID0gJ25ldmVyJyB8ICdvbmNlJyB8ICdhbHdheXMnXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29uZmlndXJhdGlvbiBmb3IgZGV2ZWxvcG1lbnQgbW9kZSBjaGVja3MuXG4gKlxuICogQHNpbmNlIDkuMC4wXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXZNb2RlQ2hlY2tzIHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZ2xvYmFsIHN0YWJpbGl0eSBjaGVjayBmb3IgdGhlIHNlbGVjdG9yLlxuICAgKiAtIGBvbmNlYCAtIFJ1biBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQuXG4gICAqIC0gYGFsd2F5c2AgLSBSdW4gZXZlcnkgdGltZSB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkLlxuICAgKiAtIGBuZXZlcmAgLSBOZXZlciBydW4gdGhlIHN0YWJpbGl0eSBjaGVjay5cbiAgICpcbiAgICogQGRlZmF1bHQgJ29uY2UnXG4gICAqXG4gICAqIEBzaW5jZSA4LjEuMFxuICAgKi9cbiAgc3RhYmlsaXR5Q2hlY2s6IERldk1vZGVDaGVja0ZyZXF1ZW5jeVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGdsb2JhbCBpZGVudGl0eSBmdW5jdGlvbiBjaGVjayBmb3IgdGhlIHNlbGVjdG9yLlxuICAgKiAtIGBvbmNlYCAtIFJ1biBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQuXG4gICAqIC0gYGFsd2F5c2AgLSBSdW4gZXZlcnkgdGltZSB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkLlxuICAgKiAtIGBuZXZlcmAgLSBOZXZlciBydW4gdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGNoZWNrLlxuICAgKlxuICAgKiAqKk5vdGUqKjogUHJldmlvdXNseSByZWZlcnJlZCB0byBhcyBgbm9vcENoZWNrYC5cbiAgICpcbiAgICogQGRlZmF1bHQgJ29uY2UnXG4gICAqXG4gICAqIEBzaW5jZSA5LjAuMFxuICAgKi9cbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBEZXZNb2RlQ2hlY2tGcmVxdWVuY3lcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTZWxlY3Rvck9wdGlvbnM8U2VsZWN0ZWQgPSB1bmtub3duPiB7XG4gIGVxdWFsaXR5Rm4/OiBFcXVhbGl0eUZuPFNlbGVjdGVkPlxuXG4gIC8qKlxuICAgKiBgdXNlU2VsZWN0b3JgIHBlcmZvcm1zIGFkZGl0aW9uYWwgY2hlY2tzIGluIGRldmVsb3BtZW50IG1vZGUgdG8gaGVscFxuICAgKiBpZGVudGlmeSBhbmQgd2FybiBhYm91dCBwb3RlbnRpYWwgaXNzdWVzIGluIHNlbGVjdG9yIGJlaGF2aW9yLiBUaGlzXG4gICAqIG9wdGlvbiBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2YgdGhlc2UgY2hlY2tzIHBlciBzZWxlY3Rvci5cbiAgICpcbiAgICogQHNpbmNlIDkuMC4wXG4gICAqL1xuICBkZXZNb2RlQ2hlY2tzPzogUGFydGlhbDxEZXZNb2RlQ2hlY2tzPlxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjdXN0b20gaG9vayB0aGF0IGFsbG93cyB5b3UgdG8gZXh0cmFjdCBkYXRhIGZyb20gdGhlXG4gKiBSZWR1eCBzdG9yZSBzdGF0ZSwgdXNpbmcgYSBzZWxlY3RvciBmdW5jdGlvbi4gVGhlIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiB0YWtlcyB0aGUgY3VycmVudCBzdGF0ZSBhcyBhbiBhcmd1bWVudCBhbmQgcmV0dXJucyBhIHBhcnQgb2YgdGhlIHN0YXRlXG4gKiBvciBzb21lIGRlcml2ZWQgZGF0YS4gVGhlIGhvb2sgYWxzbyBzdXBwb3J0cyBhbiBvcHRpb25hbCBlcXVhbGl0eVxuICogZnVuY3Rpb24gb3Igb3B0aW9ucyBvYmplY3QgdG8gY3VzdG9taXplIGl0cyBiZWhhdmlvci5cbiAqXG4gKiBAdGVtcGxhdGUgU3RhdGVUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2Ygc3RhdGUgdGhpcyBob29rIG9wZXJhdGVzIG9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VTZWxlY3RvcjxTdGF0ZVR5cGUgPSB1bmtub3duPiB7XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzZWxlY3RvciBmdW5jdGlvbiBhcyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICAqIFRoZSBzZWxlY3RvciBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3Igc2VsZWN0aW5nIGEgcGFydCBvZlxuICAgKiB0aGUgUmVkdXggc3RvcmUncyBzdGF0ZSBvciBjb21wdXRpbmcgZGVyaXZlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHJldHVybnMgYSBwYXJ0IG9mIHRoZSBzdGF0ZSBvciBzb21lIGRlcml2ZWQgZGF0YS5cbiAgICogQHBhcmFtIGVxdWFsaXR5Rm5Pck9wdGlvbnMgLSBBbiBvcHRpb25hbCBlcXVhbGl0eSBmdW5jdGlvbiBvciBvcHRpb25zIG9iamVjdCBmb3IgY3VzdG9taXppbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBzZWxlY3Rvci5cbiAgICogQHJldHVybnMgVGhlIHNlbGVjdGVkIHBhcnQgb2YgdGhlIHN0YXRlIG9yIGRlcml2ZWQgZGF0YS5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRTdGF0ZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHN0YXRlIHRoaXMgaG9vayBvcGVyYXRlcyBvbi5cbiAgICogQHRlbXBsYXRlIFNlbGVjdGVkIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRoYXQgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgcmV0dXJuLlxuICAgKi9cbiAgPFRTdGF0ZSBleHRlbmRzIFN0YXRlVHlwZSA9IFN0YXRlVHlwZSwgU2VsZWN0ZWQgPSB1bmtub3duPihcbiAgICBzZWxlY3RvcjogKHN0YXRlOiBUU3RhdGUpID0+IFNlbGVjdGVkLFxuICAgIGVxdWFsaXR5Rm5Pck9wdGlvbnM/OiBFcXVhbGl0eUZuPFNlbGVjdGVkPiB8IFVzZVNlbGVjdG9yT3B0aW9uczxTZWxlY3RlZD5cbiAgKTogU2VsZWN0ZWRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFwicHJlLXR5cGVkXCIgdmVyc2lvbiBvZiB7QGxpbmtjb2RlIHVzZVNlbGVjdG9yIHVzZVNlbGVjdG9yfVxuICAgKiB3aGVyZSB0aGUgYHN0YXRlYCB0eXBlIGlzIHByZWRlZmluZWQuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIGBzdGF0ZWAgdHlwZSBvbmNlLCBlbGltaW5hdGluZyB0aGUgbmVlZCB0b1xuICAgKiBzcGVjaWZ5IGl0IHdpdGggZXZlcnkge0BsaW5rY29kZSB1c2VTZWxlY3RvciB1c2VTZWxlY3Rvcn0gY2FsbC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcmUtdHlwZWQgYHVzZVNlbGVjdG9yYCB3aXRoIHRoZSBzdGF0ZSB0eXBlIGFscmVhZHkgZGVmaW5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogZXhwb3J0IGNvbnN0IHVzZUFwcFNlbGVjdG9yID0gdXNlU2VsZWN0b3Iud2l0aFR5cGVzPFJvb3RTdGF0ZT4oKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlU3RhdGVUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2Ygc3RhdGUgdGhpcyBob29rIG9wZXJhdGVzIG9uLlxuICAgKlxuICAgKiBAc2luY2UgOS4xLjBcbiAgICovXG4gIHdpdGhUeXBlczogPFxuICAgIE92ZXJyaWRlU3RhdGVUeXBlIGV4dGVuZHMgU3RhdGVUeXBlXG4gID4oKSA9PiBVc2VTZWxlY3RvcjxPdmVycmlkZVN0YXRlVHlwZT5cbn1cblxubGV0IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gbm90SW5pdGlhbGl6ZWQgYXMgdVNFU1dTXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yID0gKGZuOiB1U0VTV1MpID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmblxufVxuXG5jb25zdCByZWZFcXVhbGl0eTogRXF1YWxpdHlGbjxhbnk+ID0gKGEsIGIpID0+IGEgPT09IGJcblxuLyoqXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlU2VsZWN0b3JgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VTZWxlY3RvcmAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soXG4gIGNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8UmVhY3RSZWR1eENvbnRleHRWYWx1ZTxcbiAgICBhbnksXG4gICAgYW55XG4gID4gfCBudWxsPiA9IFJlYWN0UmVkdXhDb250ZXh0LFxuKTogVXNlU2VsZWN0b3Ige1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQgPVxuICAgIGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0XG4gICAgICA/IHVzZURlZmF1bHRSZWR1eENvbnRleHRcbiAgICAgIDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuXG4gIGNvbnN0IHVzZVNlbGVjdG9yID0gPFRTdGF0ZSwgU2VsZWN0ZWQgZXh0ZW5kcyB1bmtub3duPihcbiAgICBzZWxlY3RvcjogKHN0YXRlOiBUU3RhdGUpID0+IFNlbGVjdGVkLFxuICAgIGVxdWFsaXR5Rm5Pck9wdGlvbnM6XG4gICAgICB8IEVxdWFsaXR5Rm48Tm9JbmZlcjxTZWxlY3RlZD4+XG4gICAgICB8IFVzZVNlbGVjdG9yT3B0aW9uczxOb0luZmVyPFNlbGVjdGVkPj4gPSB7fVxuICApOiBTZWxlY3RlZCA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHksIGRldk1vZGVDaGVja3MgPSB7fSB9ID1cbiAgICAgIHR5cGVvZiBlcXVhbGl0eUZuT3JPcHRpb25zID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH1cbiAgICAgICAgOiBlcXVhbGl0eUZuT3JPcHRpb25zXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYClcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZXF1YWxpdHlGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dCgpXG5cbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKVxuXG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2s8dHlwZW9mIHNlbGVjdG9yPihcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlOiBUU3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdG9yKHN0YXRlKVxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjazogZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrOiBmaW5hbFN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrcyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgICAgICAgKGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09ICdvbmNlJyAmJiBmaXJzdFJ1bi5jdXJyZW50KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKVxuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2s6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1zZW1pXG4gICAgICAgICAgICAgICAgICA7KHsgc3RhY2sgfSA9IGUgYXMgRXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdTZWxlY3RvciAnICtcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdG9yLm5hbWUgfHwgJ3Vua25vd24nKSArXG4gICAgICAgICAgICAgICAgICAgICcgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuJyArXG4gICAgICAgICAgICAgICAgICAgICdcXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uJyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgICAgICAgKGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSAnb25jZScgJiYgZmlyc3RSdW4uY3VycmVudClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2s6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1zZW1pXG4gICAgICAgICAgICAgICAgICA7KHsgc3RhY2sgfSA9IGUgYXMgRXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdTZWxlY3RvciAnICtcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdG9yLm5hbWUgfHwgJ3Vua25vd24nKSArXG4gICAgICAgICAgICAgICAgICAgICcgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLicgK1xuICAgICAgICAgICAgICAgICAgICAnXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUgYXJlIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlLCBhcyB0aGV5IHdpbGwgY2F1c2UgYSByZXJlbmRlciB3aGVuZXZlciAqYW55dGhpbmcqIGluIHN0YXRlIGNoYW5nZXMuJyxcbiAgICAgICAgICAgICAgICAgIHsgc3RhY2sgfSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KSBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkXG4gICAgICAgIH0sXG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yLCBzdGFiaWxpdHlDaGVjaywgZGV2TW9kZUNoZWNrcy5zdGFiaWxpdHlDaGVja10sXG4gICAgKVxuXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1YixcbiAgICAgIHN0b3JlLmdldFN0YXRlLFxuICAgICAgZ2V0U2VydmVyU3RhdGUgfHwgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBlcXVhbGl0eUZuLFxuICAgIClcblxuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSlcblxuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlXG4gIH1cblxuICBPYmplY3QuYXNzaWduKHVzZVNlbGVjdG9yLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcixcbiAgfSlcblxuICByZXR1cm4gdXNlU2VsZWN0b3IgYXMgVXNlU2VsZWN0b3Jcbn1cblxuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZSdzIHN0YXRlLiBUaGlzIGhvb2sgdGFrZXMgYSBzZWxlY3RvciBmdW5jdGlvblxuICogYXMgYW4gYXJndW1lbnQuIFRoZSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgc3RvcmUgc3RhdGUuXG4gKlxuICogVGhpcyBob29rIHRha2VzIGFuIG9wdGlvbmFsIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAqIHRoYXQgYWxsb3dzIHlvdSB0byBjdXN0b21pemUgdGhlIHdheSB0aGUgc2VsZWN0ZWQgc3RhdGUgaXMgY29tcGFyZWQgdG8gZGV0ZXJtaW5lXG4gKiB3aGV0aGVyIHRoZSBjb21wb25lbnQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZXF1YWxpdHlGbiB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5XG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHNlbGVjdGVkIHN0YXRlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBjb3VudGVyID0gdXNlU2VsZWN0b3Ioc3RhdGUgPT4gc3RhdGUuY291bnRlcilcbiAqICAgcmV0dXJuIDxkaXY+e2NvdW50ZXJ9PC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTZWxlY3RvciA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2VsZWN0b3JIb29rKClcbiIsImltcG9ydCB0eXBlIHsgRWxlbWVudFR5cGUsIE1lbW9FeG90aWNDb21wb25lbnQsIFJlYWN0RWxlbWVudCB9IGZyb20gJ3JlYWN0J1xuXG4vLyBEaXJlY3RseSBwb3J0ZWQgZnJvbTpcbi8vIGh0dHBzOi8vdW5wa2cuY29tL2Jyb3dzZS9yZWFjdC1pc0AxOC4zLjAtY2FuYXJ5LWVlNjg0NDZmZi0yMDIzMTExNS9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5qc1xuLy8gSXQncyB2ZXJ5IHBvc3NpYmxlIHRoaXMgY291bGQgY2hhbmdlIGluIHRoZSBmdXR1cmUsIGJ1dCBnaXZlbiB0aGF0XG4vLyB3ZSBvbmx5IHVzZSB0aGVzZSBpbiBgY29ubmVjdGAsIHRoaXMgaXMgYSBsb3cgcHJpb3JpdHkuXG5cbmNvbnN0IFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKVxuY29uc3QgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKVxuY29uc3QgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JylcbmNvbnN0IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpXG5jb25zdCBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKVxuY29uc3QgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJylcbmNvbnN0IFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKVxuY29uc3QgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0JylcbmNvbnN0IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpXG5jb25zdCBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKVxuY29uc3QgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpXG5jb25zdCBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJylcbmNvbnN0IFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKVxuY29uc3QgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKVxuY29uc3QgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKVxuXG5leHBvcnQgY29uc3QgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEVcbmV4cG9ydCBjb25zdCBNZW1vID0gUkVBQ1RfTUVNT19UWVBFXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZTogYW55KTogdHlwZSBpcyBFbGVtZW50VHlwZSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cbiAgaWYgKFxuICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG4gICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHxcbiAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgIC8vIHdpdGguXG4gICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFIHx8XG4gICAgICB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3Q6IGFueSk6IHN5bWJvbCB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZlxuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9iamVjdC50eXBlXG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVcblxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZlxuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGVcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgIHJldHVybiAkJHR5cGVvZlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdDogYW55KTogb2JqZWN0IGlzIFJlYWN0RWxlbWVudCB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01lbW8ob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgTWVtb0V4b3RpY0NvbXBvbmVudDxhbnk+IHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEVcbn1cbiIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2U6IHN0cmluZykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG4iLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJ1xuXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3I6IHVua25vd24sIG1ldGhvZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYClcbiAgfSBlbHNlIGlmIChcbiAgICBtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fFxuICAgIG1ldGhvZE5hbWUgPT09ICdtYXBEaXNwYXRjaFRvUHJvcHMnXG4gICkge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCAnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gLFxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMoXG4gIG1hcFN0YXRlVG9Qcm9wczogdW5rbm93bixcbiAgbWFwRGlzcGF0Y2hUb1Byb3BzOiB1bmtub3duLFxuICBtZXJnZVByb3BzOiB1bmtub3duLFxuKTogdm9pZCB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKVxuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJylcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJylcbn1cbiIsImltcG9ydCB0eXBlIHsgRGlzcGF0Y2gsIEFjdGlvbiB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJ1xuaW1wb3J0IHR5cGUgeyBFcXVhbGl0eUZuLCBFeHRlbmRlZEVxdWFsaXR5Rm4gfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IHR5cGUgU2VsZWN0b3JGYWN0b3J5PFMsIFRQcm9wcywgVE93blByb3BzLCBURmFjdG9yeU9wdGlvbnM+ID0gKFxuICBkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+LFxuICBmYWN0b3J5T3B0aW9uczogVEZhY3RvcnlPcHRpb25zXG4pID0+IFNlbGVjdG9yPFMsIFRQcm9wcywgVE93blByb3BzPlxuXG5leHBvcnQgdHlwZSBTZWxlY3RvcjxTLCBUUHJvcHMsIFRPd25Qcm9wcyA9IG51bGw+ID0gVE93blByb3BzIGV4dGVuZHNcbiAgfCBudWxsXG4gIHwgdW5kZWZpbmVkXG4gID8gKHN0YXRlOiBTKSA9PiBUUHJvcHNcbiAgOiAoc3RhdGU6IFMsIG93blByb3BzOiBUT3duUHJvcHMpID0+IFRQcm9wc1xuXG5leHBvcnQgdHlwZSBNYXBTdGF0ZVRvUHJvcHM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+ID0gKFxuICBzdGF0ZTogU3RhdGUsXG4gIG93blByb3BzOiBUT3duUHJvcHNcbikgPT4gVFN0YXRlUHJvcHNcblxuZXhwb3J0IHR5cGUgTWFwU3RhdGVUb1Byb3BzRmFjdG9yeTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4gPSAoXG4gIGluaXRpYWxTdGF0ZTogU3RhdGUsXG4gIG93blByb3BzOiBUT3duUHJvcHNcbikgPT4gTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPlxuXG5leHBvcnQgdHlwZSBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4gPVxuICB8IE1hcFN0YXRlVG9Qcm9wc0ZhY3Rvcnk8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+XG4gIHwgTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPlxuICB8IG51bGxcbiAgfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgTWFwRGlzcGF0Y2hUb1Byb3BzRnVuY3Rpb248VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4gPSAoXG4gIGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4sXG4gIG93blByb3BzOiBUT3duUHJvcHNcbikgPT4gVERpc3BhdGNoUHJvcHNcblxuZXhwb3J0IHR5cGUgTWFwRGlzcGF0Y2hUb1Byb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+ID1cbiAgfCBNYXBEaXNwYXRjaFRvUHJvcHNGdW5jdGlvbjxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuICB8IFREaXNwYXRjaFByb3BzXG5cbmV4cG9ydCB0eXBlIE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3Rvcnk8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4gPSAoXG4gIGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4sXG4gIG93blByb3BzOiBUT3duUHJvcHNcbikgPT4gTWFwRGlzcGF0Y2hUb1Byb3BzRnVuY3Rpb248VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cblxuZXhwb3J0IHR5cGUgTWFwRGlzcGF0Y2hUb1Byb3BzUGFyYW08VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4gPVxuICB8IE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3Rvcnk8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cbiAgfCBNYXBEaXNwYXRjaFRvUHJvcHM8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cblxuZXhwb3J0IHR5cGUgTWFwRGlzcGF0Y2hUb1Byb3BzTm9uT2JqZWN0PFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+ID1cbiAgfCBNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5PFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG4gIHwgTWFwRGlzcGF0Y2hUb1Byb3BzRnVuY3Rpb248VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cblxuZXhwb3J0IHR5cGUgTWVyZ2VQcm9wczxUU3RhdGVQcm9wcywgVERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPiA9IChcbiAgc3RhdGVQcm9wczogVFN0YXRlUHJvcHMsXG4gIGRpc3BhdGNoUHJvcHM6IFREaXNwYXRjaFByb3BzLFxuICBvd25Qcm9wczogVE93blByb3BzXG4pID0+IFRNZXJnZWRQcm9wc1xuXG5pbnRlcmZhY2UgUHVyZVNlbGVjdG9yRmFjdG9yeUNvbXBhcmlzb25PcHRpb25zPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPiB7XG4gIHJlYWRvbmx5IGFyZVN0YXRlc0VxdWFsOiBFeHRlbmRlZEVxdWFsaXR5Rm48U3RhdGUsIFRPd25Qcm9wcz5cbiAgcmVhZG9ubHkgYXJlU3RhdGVQcm9wc0VxdWFsOiBFcXVhbGl0eUZuPFRTdGF0ZVByb3BzPlxuICByZWFkb25seSBhcmVPd25Qcm9wc0VxdWFsOiBFcXVhbGl0eUZuPFRPd25Qcm9wcz5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5PFxuICBUU3RhdGVQcm9wcyxcbiAgVE93blByb3BzLFxuICBURGlzcGF0Y2hQcm9wcyxcbiAgVE1lcmdlZFByb3BzLFxuICBTdGF0ZVxuPihcbiAgbWFwU3RhdGVUb1Byb3BzOiBXcmFwcGVkTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBXcmFwcGVkTWFwRGlzcGF0Y2hUb1Byb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICBtZXJnZVByb3BzOiBNZXJnZVByb3BzPFRTdGF0ZVByb3BzLCBURGlzcGF0Y2hQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+LFxuICBkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+LFxuICB7XG4gICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gIH06IFB1cmVTZWxlY3RvckZhY3RvcnlDb21wYXJpc29uT3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4pIHtcbiAgbGV0IGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2VcbiAgbGV0IHN0YXRlOiBTdGF0ZVxuICBsZXQgb3duUHJvcHM6IFRPd25Qcm9wc1xuICBsZXQgc3RhdGVQcm9wczogVFN0YXRlUHJvcHNcbiAgbGV0IGRpc3BhdGNoUHJvcHM6IFREaXNwYXRjaFByb3BzXG4gIGxldCBtZXJnZWRQcm9wczogVE1lcmdlZFByb3BzXG5cbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGU6IFN0YXRlLCBmaXJzdE93blByb3BzOiBUT3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGVcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHNcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcylcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcylcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpXG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlXG4gICAgcmV0dXJuIG1lcmdlZFByb3BzXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKVxuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKVxuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKVxuICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKVxuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKVxuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKVxuICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKVxuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcylcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHNcblxuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcylcblxuICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZTogU3RhdGUsIG5leHRPd25Qcm9wczogVE93blByb3BzKSB7XG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcylcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzLFxuICAgIClcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZVxuICAgIG93blByb3BzID0gbmV4dE93blByb3BzXG5cbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKVxuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpXG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKClcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHNcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKFxuICAgIG5leHRTdGF0ZTogU3RhdGUsXG4gICAgbmV4dE93blByb3BzOiBUT3duUHJvcHMsXG4gICkge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZVxuICAgICAgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpXG4gICAgICA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcylcbiAgfVxufVxuXG5pbnRlcmZhY2UgV3JhcHBlZE1hcFN0YXRlVG9Qcm9wczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4ge1xuICAoc3RhdGU6IFN0YXRlLCBvd25Qcm9wczogVE93blByb3BzKTogVFN0YXRlUHJvcHNcbiAgcmVhZG9ubHkgZGVwZW5kc09uT3duUHJvcHM6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFdyYXBwZWRNYXBEaXNwYXRjaFRvUHJvcHM8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4ge1xuICAoZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+Piwgb3duUHJvcHM6IFRPd25Qcm9wcyk6IFREaXNwYXRjaFByb3BzXG4gIHJlYWRvbmx5IGRlcGVuZHNPbk93blByb3BzOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdE9wdGlvbnM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzLCBTdGF0ZT5cbiAgZXh0ZW5kcyBQdXJlU2VsZWN0b3JGYWN0b3J5Q29tcGFyaXNvbk9wdGlvbnM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+IHtcbiAgcmVhZG9ubHkgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBib29sZWFuXG4gIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmdcbiAgcmVhZG9ubHkgd3JhcHBlZENvbXBvbmVudE5hbWU6IHN0cmluZ1xuICByZWFkb25seSBXcmFwcGVkQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFRPd25Qcm9wcz5cbiAgcmVhZG9ubHkgYXJlTWVyZ2VkUHJvcHNFcXVhbDogRXF1YWxpdHlGbjxUTWVyZ2VkUHJvcHM+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0b3JGYWN0b3J5T3B0aW9uczxcbiAgVFN0YXRlUHJvcHMsXG4gIFRPd25Qcm9wcyxcbiAgVERpc3BhdGNoUHJvcHMsXG4gIFRNZXJnZWRQcm9wcyxcbiAgU3RhdGVcbj4gZXh0ZW5kcyBJbml0T3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHMsIFN0YXRlPiB7XG4gIHJlYWRvbmx5IGluaXRNYXBTdGF0ZVRvUHJvcHM6IChcbiAgICBkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+LFxuICAgIG9wdGlvbnM6IEluaXRPcHRpb25zPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFRNZXJnZWRQcm9wcywgU3RhdGU+XG4gICkgPT4gV3JhcHBlZE1hcFN0YXRlVG9Qcm9wczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT5cbiAgcmVhZG9ubHkgaW5pdE1hcERpc3BhdGNoVG9Qcm9wczogKFxuICAgIGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4sXG4gICAgb3B0aW9uczogSW5pdE9wdGlvbnM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzLCBTdGF0ZT5cbiAgKSA9PiBXcmFwcGVkTWFwRGlzcGF0Y2hUb1Byb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG4gIHJlYWRvbmx5IGluaXRNZXJnZVByb3BzOiAoXG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgICBvcHRpb25zOiBJbml0T3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHMsIFN0YXRlPlxuICApID0+IE1lcmdlUHJvcHM8VFN0YXRlUHJvcHMsIFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHMsIFRNZXJnZWRQcm9wcz5cbn1cblxuLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcblxuLy8gVGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0J3Mgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHRvIHJldHVybiBmYWxzZSBpZiBmaW5hbFxuLy8gcHJvcHMgaGF2ZSBub3QgY2hhbmdlZC5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeTxcbiAgVFN0YXRlUHJvcHMsXG4gIFRPd25Qcm9wcyxcbiAgVERpc3BhdGNoUHJvcHMsXG4gIFRNZXJnZWRQcm9wcyxcbiAgU3RhdGVcbj4oXG4gIGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4sXG4gIHtcbiAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgLi4ub3B0aW9uc1xuICB9OiBTZWxlY3RvckZhY3RvcnlPcHRpb25zPFxuICAgIFRTdGF0ZVByb3BzLFxuICAgIFRPd25Qcm9wcyxcbiAgICBURGlzcGF0Y2hQcm9wcyxcbiAgICBUTWVyZ2VkUHJvcHMsXG4gICAgU3RhdGVcbiAgPixcbikge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKVxuICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKVxuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpXG4gIH1cblxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk8XG4gICAgVFN0YXRlUHJvcHMsXG4gICAgVE93blByb3BzLFxuICAgIFREaXNwYXRjaFByb3BzLFxuICAgIFRNZXJnZWRQcm9wcyxcbiAgICBTdGF0ZVxuICA+KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgb3B0aW9ucylcbn1cbiIsImltcG9ydCB0eXBlIHsgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIERpc3BhdGNoIH0gZnJvbSAncmVkdXgnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhcbiAgYWN0aW9uQ3JlYXRvcnM6IEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0LFxuICBkaXNwYXRjaDogRGlzcGF0Y2gsXG4pOiBBY3Rpb25DcmVhdG9yc01hcE9iamVjdCB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnM6IEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0ID0ge31cblxuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldXG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSAoLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvciguLi5hcmdzKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnNcbn1cbiIsIi8qKlxuICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhIHBsYWluIG9iamVjdC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmo6IHVua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKVxuICBpZiAocHJvdG8gPT09IG51bGwpIHJldHVybiB0cnVlXG5cbiAgbGV0IGJhc2VQcm90byA9IHByb3RvXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKSAhPT0gbnVsbCkge1xuICAgIGJhc2VQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pXG4gIH1cblxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90b1xufVxuIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0J1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdChcbiAgdmFsdWU6IHVua25vd24sXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcsXG4gIG1ldGhvZE5hbWU6IHN0cmluZyxcbikge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGAke21ldGhvZE5hbWV9KCkgaW4gJHtkaXNwbGF5TmFtZX0gbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHt2YWx1ZX0uYCxcbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIERpc3BhdGNoLCBBY3Rpb25DcmVhdG9yIH0gZnJvbSAncmVkdXgnXG5cbmltcG9ydCB0eXBlIHsgRml4VHlwZUxhdGVyIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnXG5cbnR5cGUgQW55U3RhdGUgPSB7IFtrZXk6IHN0cmluZ106IGFueSB9XG50eXBlIFN0YXRlT3JEaXNwYXRjaDxTIGV4dGVuZHMgQW55U3RhdGUgPSBBbnlTdGF0ZT4gPSBTIHwgRGlzcGF0Y2hcblxudHlwZSBBbnlQcm9wcyA9IHsgW2tleTogc3RyaW5nXTogYW55IH1cblxuZXhwb3J0IHR5cGUgTWFwVG9Qcm9wczxQIGV4dGVuZHMgQW55UHJvcHMgPSBBbnlQcm9wcz4gPSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAoc3RhdGVPckRpc3BhdGNoOiBTdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzPzogUCk6IEZpeFR5cGVMYXRlclxuICBkZXBlbmRzT25Pd25Qcm9wcz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoXG4gIC8vICogTm90ZTpcbiAgLy8gIEl0IHNlZW1zIHRoYXQgdGhlIGRpc3BhdGNoIGFyZ3VtZW50XG4gIC8vICBjb3VsZCBiZSBhIGRpc3BhdGNoIGZ1bmN0aW9uIGluIHNvbWUgY2FzZXMgKGV4OiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKVxuICAvLyAgYW5kIGEgc3RhdGUgb2JqZWN0IGluIHNvbWUgb3RoZXJzIChleDogd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZylcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGdldENvbnN0YW50OiAoZGlzcGF0Y2g6IERpc3BhdGNoKSA9PlxuICAgIHwge1xuICAgICAgICBkaXNwYXRjaD86IERpc3BhdGNoXG4gICAgICAgIGRlcGVuZHNPbk93blByb3BzPzogYm9vbGVhblxuICAgICAgfVxuICAgIHwgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3RcbiAgICB8IEFjdGlvbkNyZWF0b3I8YW55Pixcbikge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2g6IERpc3BhdGNoKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaClcblxuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnRcbiAgICB9XG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlXG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3JcbiAgfVxufVxuXG4vLyBkZXBlbmRzT25Pd25Qcm9wcyBpcyB1c2VkIGJ5IGNyZWF0ZU1hcFRvUHJvcHNQcm94eSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBwYXNzIHByb3BzIGFzIGFyZ3Ncbi8vIHRvIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIHdyYXBwZWQuIEl0IGlzIGFsc28gdXNlZCBieSBtYWtlUHVyZVByb3BzU2VsZWN0b3IgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIG1hcFRvUHJvcHMgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIHByb3BzIGhhdmUgY2hhbmdlZC5cbi8vXG4vLyBBIGxlbmd0aCBvZiBvbmUgc2lnbmFscyB0aGF0IG1hcFRvUHJvcHMgZG9lcyBub3QgZGVwZW5kIG9uIHByb3BzIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4vLyBBIGxlbmd0aCBvZiB6ZXJvIGlzIGFzc3VtZWQgdG8gbWVhbiBtYXBUb1Byb3BzIGlzIGdldHRpbmcgYXJncyB2aWEgYXJndW1lbnRzIG9yIC4uLmFyZ3MgYW5kXG4vLyB0aGVyZWZvcmUgbm90IHJlcG9ydGluZyBpdHMgbGVuZ3RoIGFjY3VyYXRlbHkuLlxuLy8gVE9ETyBDYW4gdGhpcyBnZXQgcHVsbGVkIG91dCBzbyB0aGF0IHdlIGNhbiBzdWJzY3JpYmUgZGlyZWN0bHkgdG8gdGhlIHN0b3JlIGlmIHdlIGRvbid0IG5lZWQgb3duUHJvcHM/XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wczogTWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wc1xuICAgID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDFcbn1cblxuLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy9cbi8vICAqIERldGVjdHMgd2hldGhlciB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZGVwZW5kcyBvbiBwcm9wcywgd2hpY2hcbi8vICAgIGlzIHVzZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHRvIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVpbnZva2Ugb24gcHJvcHMgY2hhbmdlcy5cbi8vXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCBoYW5kbGVzIG1hcFRvUHJvcHMgaWYgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLCBhbmQgdHJlYXRzIHRoYXRcbi8vICAgIG5ldyBmdW5jdGlvbiBhcyB0aGUgdHJ1ZSBtYXBUb1Byb3BzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuLy9cbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYzxQIGV4dGVuZHMgQW55UHJvcHMgPSBBbnlQcm9wcz4oXG4gIG1hcFRvUHJvcHM6IE1hcFRvUHJvcHMsXG4gIG1ldGhvZE5hbWU6IHN0cmluZyxcbikge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoXG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoLFxuICAgIHsgZGlzcGxheU5hbWUgfTogeyBkaXNwbGF5TmFtZTogc3RyaW5nIH0sXG4gICkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KFxuICAgICAgc3RhdGVPckRpc3BhdGNoOiBTdGF0ZU9yRGlzcGF0Y2gsXG4gICAgICBvd25Qcm9wcz86IFAsXG4gICAgKTogTWFwVG9Qcm9wcyB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHNcbiAgICAgICAgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpXG4gICAgICAgIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHVuZGVmaW5lZClcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IHRvIGdldCBvd25Qcm9wc1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZVxuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoXG4gICAgICBzdGF0ZU9yRGlzcGF0Y2g6IFN0YXRlT3JEaXNwYXRjaCxcbiAgICAgIG93blByb3BzPzogUCxcbiAgICApOiBNYXBUb1Byb3BzIHtcbiAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBtYXBUb1Byb3BzXG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpXG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKVxuXG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBwcm9wc1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKVxuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChwcm9wcywgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpXG5cbiAgICAgIHJldHVybiBwcm9wc1xuICAgIH1cblxuICAgIHJldHVybiBwcm94eVxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEFjdGlvbiwgRGlzcGF0Y2ggfSBmcm9tICdyZWR1eCdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZzogdW5rbm93biwgbmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgICBvcHRpb25zOiB7IHJlYWRvbmx5IHdyYXBwZWRDb21wb25lbnROYW1lOiBzdHJpbmcgfSxcbiAgKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtcbiAgICAgICAgb3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZVxuICAgICAgfS5gLFxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBBY3Rpb24sIERpc3BhdGNoIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgYmluZEFjdGlvbkNyZWF0b3JzIGZyb20gJy4uL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycydcbmltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnXG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSB9IGZyb20gJy4vaW52YWxpZEFyZ0ZhY3RvcnknXG5pbXBvcnQgdHlwZSB7IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtIH0gZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5PFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+KFxuICBtYXBEaXNwYXRjaFRvUHJvcHM6XG4gICAgfCBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuICAgIHwgdW5kZWZpbmVkLFxuKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ29iamVjdCdcbiAgICA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4pID0+XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpLFxuICAgICAgKVxuICAgIDogIW1hcERpc3BhdGNoVG9Qcm9wc1xuICAgID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PikgPT4gKHtcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICB9KSlcbiAgICA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICA/IC8vIEB0cy1pZ25vcmVcbiAgICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKVxuICAgIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJylcbn1cbiIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnXG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSB9IGZyb20gJy4vaW52YWxpZEFyZ0ZhY3RvcnknXG5pbXBvcnQgdHlwZSB7IE1hcFN0YXRlVG9Qcm9wc1BhcmFtIH0gZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5PFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPihcbiAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4pIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHNcbiAgICA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSlcbiAgICA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICA/IC8vIEB0cy1pZ25vcmVcbiAgICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKVxuICAgIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJylcbn1cbiIsImltcG9ydCB0eXBlIHsgQWN0aW9uLCBEaXNwYXRjaCB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0J1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5J1xuaW1wb3J0IHR5cGUgeyBNZXJnZVByb3BzIH0gZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknXG5pbXBvcnQgdHlwZSB7IEVxdWFsaXR5Rm4gfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzPFxuICBUU3RhdGVQcm9wcyxcbiAgVERpc3BhdGNoUHJvcHMsXG4gIFRPd25Qcm9wcyxcbiAgVE1lcmdlZFByb3BzXG4+KFxuICBzdGF0ZVByb3BzOiBUU3RhdGVQcm9wcyxcbiAgZGlzcGF0Y2hQcm9wczogVERpc3BhdGNoUHJvcHMsXG4gIG93blByb3BzOiBUT3duUHJvcHMsXG4pOiBUTWVyZ2VkUHJvcHMge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYzxcbiAgVFN0YXRlUHJvcHMsXG4gIFREaXNwYXRjaFByb3BzLFxuICBUT3duUHJvcHMsXG4gIFRNZXJnZWRQcm9wc1xuPihcbiAgbWVyZ2VQcm9wczogTWVyZ2VQcm9wczxUU3RhdGVQcm9wcywgVERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPixcbik6IChcbiAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgb3B0aW9uczoge1xuICAgIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmdcbiAgICByZWFkb25seSBhcmVNZXJnZWRQcm9wc0VxdWFsOiBFcXVhbGl0eUZuPFRNZXJnZWRQcm9wcz5cbiAgfVxuKSA9PiBNZXJnZVByb3BzPFRTdGF0ZVByb3BzLCBURGlzcGF0Y2hQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoXG4gICAgZGlzcGF0Y2gsXG4gICAgeyBkaXNwbGF5TmFtZSwgYXJlTWVyZ2VkUHJvcHNFcXVhbCB9LFxuICApIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlXG4gICAgbGV0IG1lcmdlZFByb3BzOiBUTWVyZ2VkUHJvcHNcblxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoXG4gICAgICBzdGF0ZVByb3BzOiBUU3RhdGVQcm9wcyxcbiAgICAgIGRpc3BhdGNoUHJvcHM6IFREaXNwYXRjaFByb3BzLFxuICAgICAgb3duUHJvcHM6IFRPd25Qcm9wcyxcbiAgICApIHtcbiAgICAgIGNvbnN0IG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpXG5cbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWVcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHNcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsICdtZXJnZVByb3BzJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVByb3BzRmFjdG9yeTxcbiAgVFN0YXRlUHJvcHMsXG4gIFREaXNwYXRjaFByb3BzLFxuICBUT3duUHJvcHMsXG4gIFRNZXJnZWRQcm9wc1xuPihcbiAgbWVyZ2VQcm9wcz86IE1lcmdlUHJvcHM8VFN0YXRlUHJvcHMsIFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHMsIFRNZXJnZWRQcm9wcz4sXG4pIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzXG4gICAgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wc1xuICAgIDogdHlwZW9mIG1lcmdlUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKVxuICAgIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgJ21lcmdlUHJvcHMnKVxufVxuIiwiLy8gRGVmYXVsdCB0byBhIGR1bW15IFwiYmF0Y2hcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGp1c3QgcnVucyB0aGUgY2FsbGJhY2tcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Tm9vcEJhdGNoKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gIGNhbGxiYWNrKClcbn1cbiIsImltcG9ydCB7IGRlZmF1bHROb29wQmF0Y2ggYXMgYmF0Y2ggfSBmcm9tICcuL2JhdGNoJ1xuXG4vLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG50eXBlIFZvaWRGdW5jID0gKCkgPT4gdm9pZFxuXG50eXBlIExpc3RlbmVyID0ge1xuICBjYWxsYmFjazogVm9pZEZ1bmNcbiAgbmV4dDogTGlzdGVuZXIgfCBudWxsXG4gIHByZXY6IExpc3RlbmVyIHwgbnVsbFxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdDogTGlzdGVuZXIgfCBudWxsID0gbnVsbFxuICBsZXQgbGFzdDogTGlzdGVuZXIgfCBudWxsID0gbnVsbFxuXG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGxcbiAgICAgIGxhc3QgPSBudWxsXG4gICAgfSxcblxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3RcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKVxuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnM6IExpc3RlbmVyW10gPSBbXVxuICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3RcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcilcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXJzXG4gICAgfSxcblxuICAgIHN1YnNjcmliZShjYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWVcblxuICAgICAgY29uc3QgbGlzdGVuZXI6IExpc3RlbmVyID0gKGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0LFxuICAgICAgfSlcblxuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0ID0gbGlzdGVuZXJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlXG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXZcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH1cbn1cblxudHlwZSBMaXN0ZW5lckNvbGxlY3Rpb24gPSBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24+XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcbiAgYWRkTmVzdGVkU3ViOiAobGlzdGVuZXI6IFZvaWRGdW5jKSA9PiBWb2lkRnVuY1xuICBub3RpZnlOZXN0ZWRTdWJzOiBWb2lkRnVuY1xuICBoYW5kbGVDaGFuZ2VXcmFwcGVyOiBWb2lkRnVuY1xuICBpc1N1YnNjcmliZWQ6ICgpID0+IGJvb2xlYW5cbiAgb25TdGF0ZUNoYW5nZT86IFZvaWRGdW5jIHwgbnVsbFxuICB0cnlTdWJzY3JpYmU6IFZvaWRGdW5jXG4gIHRyeVVuc3Vic2NyaWJlOiBWb2lkRnVuY1xuICBnZXRMaXN0ZW5lcnM6ICgpID0+IExpc3RlbmVyQ29sbGVjdGlvblxufVxuXG5jb25zdCBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnkoKSB7fSxcbiAgZ2V0OiAoKSA9PiBbXSxcbn0gYXMgdW5rbm93biBhcyBMaXN0ZW5lckNvbGxlY3Rpb25cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZTogYW55LCBwYXJlbnRTdWI/OiBTdWJzY3JpcHRpb24pIHtcbiAgbGV0IHVuc3Vic2NyaWJlOiBWb2lkRnVuYyB8IHVuZGVmaW5lZFxuICBsZXQgbGlzdGVuZXJzOiBMaXN0ZW5lckNvbGxlY3Rpb24gPSBudWxsTGlzdGVuZXJzXG5cbiAgLy8gUmVhc29ucyB0byBrZWVwIHRoZSBzdWJzY3JpcHRpb24gYWN0aXZlXG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMFxuXG4gIC8vIElzIHRoaXMgc3BlY2lmaWMgc3Vic2NyaXB0aW9uIHN1YnNjcmliZWQgKG9yIG9ubHkgbmVzdGVkIG9uZXM/KVxuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcjogKCkgPT4gdm9pZCkge1xuICAgIHRyeVN1YnNjcmliZSgpXG5cbiAgICBjb25zdCBjbGVhbnVwTGlzdGVuZXIgPSBsaXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKVxuXG4gICAgLy8gY2xlYW51cCBuZXN0ZWQgc3ViXG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJlbW92ZWQpIHtcbiAgICAgICAgcmVtb3ZlZCA9IHRydWVcbiAgICAgICAgY2xlYW51cExpc3RlbmVyKClcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gc2VsZlN1YnNjcmliZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50KytcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICB1bnN1YnNjcmliZSA9IHBhcmVudFN1YlxuICAgICAgICA/IHBhcmVudFN1Yi5hZGROZXN0ZWRTdWIoaGFuZGxlQ2hhbmdlV3JhcHBlcilcbiAgICAgICAgOiBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlQ2hhbmdlV3JhcHBlcilcblxuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50LS1cbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKVxuICAgICAgdW5zdWJzY3JpYmUgPSB1bmRlZmluZWRcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpXG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWVcbiAgICAgIHRyeVN1YnNjcmliZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmIChzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZVxuICAgICAgdHJ5VW5zdWJzY3JpYmUoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzLFxuICB9XG5cbiAgcmV0dXJuIHN1YnNjcmlwdGlvblxufVxuIiwiaW1wb3J0IHsgUmVhY3QgfSBmcm9tICcuLi91dGlscy9yZWFjdCdcblxuLy8gUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbi8vIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuIFdlIG5lZWQgdXNlTGF5b3V0RWZmZWN0IHRvIGVuc3VyZSB0aGUgc3RvcmVcbi8vIHN1YnNjcmlwdGlvbiBjYWxsYmFjayBhbHdheXMgaGFzIHRoZSBzZWxlY3RvciBmcm9tIHRoZSBsYXRlc3QgcmVuZGVyIGNvbW1pdFxuLy8gYXZhaWxhYmxlLCBvdGhlcndpc2UgYSBzdG9yZSB1cGRhdGUgbWF5IGhhcHBlbiBiZXR3ZWVuIHJlbmRlciBhbmQgdGhlIGVmZmVjdCxcbi8vIHdoaWNoIG1heSBjYXVzZSBtaXNzZWQgdXBkYXRlczsgd2UgYWxzbyBtdXN0IGVuc3VyZSB0aGUgc3RvcmUgc3Vic2NyaXB0aW9uXG4vLyBpcyBjcmVhdGVkIHN5bmNocm9ub3VzbHksIG90aGVyd2lzZSBhIHN0b3JlIHVwZGF0ZSBtYXkgb2NjdXIgYmVmb3JlIHRoZVxuLy8gc3Vic2NyaXB0aW9uIGlzIGNyZWF0ZWQgYW5kIGFuIGluY29uc2lzdGVudCBzdGF0ZSBtYXkgYmUgb2JzZXJ2ZWRcblxuLy8gTWF0Y2hlcyBsb2dpYyBpbiBSZWFjdCdzIGBzaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnRgIGZpbGVcbmV4cG9ydCBjb25zdCBjYW5Vc2VET00gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xuKVxuXG5leHBvcnQgY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTVxuICA/IFJlYWN0LnVzZUxheW91dEVmZmVjdFxuICA6IFJlYWN0LnVzZUVmZmVjdFxuIiwiZnVuY3Rpb24gaXMoeDogdW5rbm93biwgeTogdW5rbm93bikge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBOiBhbnksIG9iakI6IGFueSkge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHJldHVybiB0cnVlXG5cbiAgaWYgKFxuICAgIHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fFxuICAgIG9iakEgPT09IG51bGwgfHxcbiAgICB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHxcbiAgICBvYmpCID09PSBudWxsXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKVxuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpXG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHxcbiAgICAgICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiLy8gQ29waWVkIGRpcmVjdGx5IGZyb206XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJpZGd3YXkvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvYmxvYi9tYWluL3NyYy9pbmRleC5qc1xuLy8gaHR0cHM6Ly91bnBrZy5jb20vYnJvd3NlL0B0eXBlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljc0AzLjMuMS9pbmRleC5kLnRzXG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbmltcG9ydCB0eXBlICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBGb3J3YXJkUmVmLCBNZW1vLCBpc01lbW8gfSBmcm9tICcuLi91dGlscy9yZWFjdC1pcydcblxuY29uc3QgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlLFxufSBhcyBjb25zdFxuXG5jb25zdCBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWUsXG59IGFzIGNvbnN0XG5cbmNvbnN0IEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbn0gYXMgY29uc3RcblxuY29uc3QgTUVNT19TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlLFxufSBhcyBjb25zdFxuXG5jb25zdCBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1MsXG59IGFzIGNvbnN0XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50OiBhbnkpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTXG4gIH1cblxuICAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTXG59XG5cbmV4cG9ydCB0eXBlIE5vblJlYWN0U3RhdGljczxcbiAgUyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PixcbiAgQyBleHRlbmRzIHtcbiAgICBba2V5OiBzdHJpbmddOiB0cnVlXG4gIH0gPSB7fVxuPiA9IHtcbiAgW2tleSBpbiBFeGNsdWRlPFxuICAgIGtleW9mIFMsXG4gICAgUyBleHRlbmRzIFJlYWN0Lk1lbW9FeG90aWNDb21wb25lbnQ8YW55PlxuICAgICAgPyBrZXlvZiB0eXBlb2YgTUVNT19TVEFUSUNTIHwga2V5b2YgQ1xuICAgICAgOiBTIGV4dGVuZHMgUmVhY3QuRm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudDxhbnk+XG4gICAgICA/IGtleW9mIHR5cGVvZiBGT1JXQVJEX1JFRl9TVEFUSUNTIHwga2V5b2YgQ1xuICAgICAgOiBrZXlvZiB0eXBlb2YgUkVBQ1RfU1RBVElDUyB8IGtleW9mIHR5cGVvZiBLTk9XTl9TVEFUSUNTIHwga2V5b2YgQ1xuICA+XTogU1trZXldXG59XG5cbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG5jb25zdCBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbmNvbnN0IGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbmNvbnN0IGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbmNvbnN0IGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG5jb25zdCBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzPFxuICBUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+LFxuICBTIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+LFxuICBDIGV4dGVuZHMge1xuICAgIFtrZXk6IHN0cmluZ106IHRydWVcbiAgfSA9IHt9XG4+KHRhcmdldENvbXBvbmVudDogVCwgc291cmNlQ29tcG9uZW50OiBTKTogVCAmIE5vblJlYWN0U3RhdGljczxTLCBDPiB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBrZXlzOiAoc3RyaW5nIHwgc3ltYm9sKVtdID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpXG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KVxuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgaWYgKFxuICAgICAgICAhS05PV05fU1RBVElDU1trZXkgYXMga2V5b2YgdHlwZW9mIEtOT1dOX1NUQVRJQ1NdICYmXG4gICAgICAgICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleSBhcyBrZXlvZiB0eXBlb2Ygc291cmNlU3RhdGljc10pICYmXG4gICAgICAgICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleSBhcyBrZXlvZiB0eXBlb2YgdGFyZ2V0U3RhdGljc10pXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IhKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50IGFzIGFueVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBSZWFjdCB9IGZyb20gJy4uL3V0aWxzL3JlYWN0J1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnRUeXBlLCBpc0NvbnRleHRDb25zdW1lciB9IGZyb20gJy4uL3V0aWxzL3JlYWN0LWlzJ1xuXG5pbXBvcnQgdHlwZSB7IFN0b3JlIH0gZnJvbSAncmVkdXgnXG5cbmltcG9ydCB0eXBlIHtcbiAgQ29ubmVjdGVkQ29tcG9uZW50LFxuICBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcixcbiAgSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHMsXG4gIFJlc29sdmVUaHVua3MsXG4gIERpc3BhdGNoUHJvcCxcbiAgQ29ubmVjdFByb3BzTWF5YmVXaXRob3V0Q29udGV4dCxcbn0gZnJvbSAnLi4vdHlwZXMnXG5cbmltcG9ydCB0eXBlIHtcbiAgTWFwU3RhdGVUb1Byb3BzUGFyYW0sXG4gIE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtLFxuICBNZXJnZVByb3BzLFxuICBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3QsXG4gIFNlbGVjdG9yRmFjdG9yeU9wdGlvbnMsXG59IGZyb20gJy4uL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5J1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi4vY29ubmVjdC9zZWxlY3RvckZhY3RvcnknXG5pbXBvcnQgeyBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMnXG5pbXBvcnQgeyBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMnXG5pbXBvcnQgeyBtZXJnZVByb3BzRmFjdG9yeSB9IGZyb20gJy4uL2Nvbm5lY3QvbWVyZ2VQcm9wcydcblxuaW1wb3J0IHR5cGUgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nXG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpcHRpb24gfSBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nXG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCdcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJ1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICcuLi91dGlscy9ob2lzdFN0YXRpY3MnXG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJ1xuXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWN0UmVkdXhDb250ZXh0VmFsdWUsXG4gIFJlYWN0UmVkdXhDb250ZXh0SW5zdGFuY2UsXG59IGZyb20gJy4vQ29udGV4dCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0J1xuXG5pbXBvcnQgdHlwZSB7IHVTRVMgfSBmcm9tICcuLi91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZSdcbmltcG9ydCB7IG5vdEluaXRpYWxpemVkIH0gZnJvbSAnLi4vdXRpbHMvdXNlU3luY0V4dGVybmFsU3RvcmUnXG5cbmxldCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IG5vdEluaXRpYWxpemVkIGFzIHVTRVNcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplQ29ubmVjdCA9IChmbjogdVNFUykgPT4ge1xuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZuXG59XG5cbi8vIERlZmluZSBzb21lIGNvbnN0YW50IGFycmF5cyBqdXN0IHRvIGF2b2lkIHJlLWNyZWF0aW5nIHRoZXNlXG5jb25zdCBFTVBUWV9BUlJBWTogW3Vua25vd24sIG51bWJlcl0gPSBbbnVsbCwgMF1cbmNvbnN0IE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXVxuXG4vLyBBdHRlbXB0cyB0byBzdHJpbmdpZnkgd2hhdGV2ZXIgbm90LXJlYWxseS1hLWNvbXBvbmVudCB2YWx1ZSB3ZSB3ZXJlIGdpdmVuXG4vLyBmb3IgbG9nZ2luZyBpbiBhbiBlcnJvciBtZXNzYWdlXG5jb25zdCBzdHJpbmdpZnlDb21wb25lbnQgPSAoQ29tcDogdW5rbm93bikgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApXG4gIH1cbn1cblxudHlwZSBFZmZlY3RGdW5jID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkIHwgUmV0dXJuVHlwZTxSZWFjdC5FZmZlY3RDYWxsYmFjaz5cblxuLy8gVGhpcyBpcyBcImp1c3RcIiBhIGB1c2VMYXlvdXRFZmZlY3RgLCBidXQgd2l0aCB0d28gbW9kaWZpY2F0aW9uczpcbi8vIC0gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gYHVzZUVmZmVjdGAgaW4gU1NSIHRvIGF2b2lkIGFubm95aW5nIHdhcm5pbmdzXG4vLyAtIHdlIGV4dHJhY3QgdGhpcyB0byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIGNsb3Npbmcgb3ZlciB2YWx1ZXNcbi8vICAgYW5kIGNhdXNpbmcgbWVtb3J5IGxlYWtzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoXG4gIGVmZmVjdEZ1bmM6IEVmZmVjdEZ1bmMsXG4gIGVmZmVjdEFyZ3M6IGFueVtdLFxuICBkZXBlbmRlbmNpZXM/OiBSZWFjdC5EZXBlbmRlbmN5TGlzdCxcbikge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcylcbn1cblxuLy8gRWZmZWN0IGNhbGxiYWNrLCBleHRyYWN0ZWQ6IGFzc2lnbiB0aGUgbGF0ZXN0IHByb3BzIHZhbHVlcyB0byByZWZzIGZvciBsYXRlciB1c2FnZVxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhcbiAgbGFzdFdyYXBwZXJQcm9wczogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDx1bmtub3duPixcbiAgbGFzdENoaWxkUHJvcHM6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8dW5rbm93bj4sXG4gIHJlbmRlcklzU2NoZWR1bGVkOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGJvb2xlYW4+LFxuICB3cmFwcGVyUHJvcHM6IHVua25vd24sXG4gIC8vIGFjdHVhbENoaWxkUHJvcHM6IHVua25vd24sXG4gIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGU6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8dW5rbm93bj4sXG4gIG5vdGlmeU5lc3RlZFN1YnM6ICgpID0+IHZvaWQsXG4pIHtcbiAgLy8gV2Ugd2FudCB0byBjYXB0dXJlIHRoZSB3cmFwcGVyIHByb3BzIGFuZCBjaGlsZCBwcm9wcyB3ZSB1c2VkIGZvciBsYXRlciBjb21wYXJpc29uc1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHNcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlXG5cbiAgLy8gSWYgdGhlIHJlbmRlciB3YXMgZnJvbSBhIHN0b3JlIHVwZGF0ZSwgY2xlYXIgb3V0IHRoYXQgcmVmZXJlbmNlIGFuZCBjYXNjYWRlIHRoZSBzdWJzY3JpYmVyIHVwZGF0ZVxuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbFxuICAgIG5vdGlmeU5lc3RlZFN1YnMoKVxuICB9XG59XG5cbi8vIEVmZmVjdCBjYWxsYmFjaywgZXh0cmFjdGVkOiBzdWJzY3JpYmUgdG8gdGhlIFJlZHV4IHN0b3JlIG9yIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yLFxuLy8gY2hlY2sgZm9yIHVwZGF0ZXMgYWZ0ZXIgZGlzcGF0Y2hlZCBhY3Rpb25zLCBhbmQgdHJpZ2dlciByZS1yZW5kZXJzLlxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhcbiAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBib29sZWFuLFxuICBzdG9yZTogU3RvcmUsXG4gIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLFxuICBjaGlsZFByb3BzU2VsZWN0b3I6IChzdGF0ZTogdW5rbm93biwgcHJvcHM6IHVua25vd24pID0+IHVua25vd24sXG4gIGxhc3RXcmFwcGVyUHJvcHM6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8dW5rbm93bj4sXG4gIGxhc3RDaGlsZFByb3BzOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PHVua25vd24+LFxuICByZW5kZXJJc1NjaGVkdWxlZDogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxib29sZWFuPixcbiAgaXNNb3VudGVkOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGJvb2xlYW4+LFxuICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PHVua25vd24+LFxuICBub3RpZnlOZXN0ZWRTdWJzOiAoKSA9PiB2b2lkLFxuICAvLyBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxhbnk+LFxuICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXI6ICgpID0+IHZvaWQsXG4pIHtcbiAgLy8gSWYgd2UncmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIHN0b3JlLCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiAoKSA9PiB7fVxuXG4gIC8vIENhcHR1cmUgdmFsdWVzIGZvciBjaGVja2luZyBpZiBhbmQgd2hlbiB0aGlzIGNvbXBvbmVudCB1bm1vdW50c1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZVxuICBsZXQgbGFzdFRocm93bkVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsXG5cbiAgLy8gV2UnbGwgcnVuIHRoaXMgY2FsbGJhY2sgZXZlcnkgdGltZSBhIHN0b3JlIHN1YnNjcmlwdGlvbiB1cGRhdGUgcHJvcGFnYXRlcyB0byB0aGlzIGNvbXBvbmVudFxuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgLy8gRG9uJ3QgcnVuIHN0YWxlIGxpc3RlbmVycy5cbiAgICAgIC8vIFJlZHV4IGRvZXNuJ3QgZ3VhcmFudGVlIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gdW50aWwgbmV4dCBkaXNwYXRjaC5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE8gV2UncmUgY3VycmVudGx5IGNhbGxpbmcgZ2V0U3RhdGUgb3Vyc2VsdmVzIGhlcmUsIHJhdGhlciB0aGFuIGxldHRpbmcgYHVTRVNgIGRvIGl0XG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKClcblxuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvclxuICAgIHRyeSB7XG4gICAgICAvLyBBY3R1YWxseSBydW4gdGhlIHNlbGVjdG9yIHdpdGggdGhlIG1vc3QgcmVjZW50IHN0b3JlIHN0YXRlIGFuZCB3cmFwcGVyIHByb3BzXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlXG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKFxuICAgICAgICBsYXRlc3RTdG9yZVN0YXRlLFxuICAgICAgICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQsXG4gICAgICApXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlXG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlIGFzIEVycm9yIHwgbnVsbFxuICAgIH1cblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgaGF2ZW4ndCBjaGFuZ2VkLCBub3RoaW5nIHRvIGRvIGhlcmUgLSBjYXNjYWRlIHRoZSBzdWJzY3JpcHRpb24gdXBkYXRlXG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2F2ZSByZWZlcmVuY2VzIHRvIHRoZSBuZXcgY2hpbGQgcHJvcHMuICBOb3RlIHRoYXQgd2UgdHJhY2sgdGhlIFwiY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGVcIlxuICAgICAgLy8gYXMgYSByZWYgaW5zdGVhZCBvZiBhIHVzZVN0YXRlL3VzZVJlZHVjZXIgYmVjYXVzZSB3ZSBuZWVkIGEgd2F5IHRvIGRldGVybWluZSBpZiB0aGF0IHZhbHVlIGhhc1xuICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuICBJZiB0aGlzIHdlbnQgaW50byB1c2VTdGF0ZS91c2VSZWR1Y2VyLCB3ZSBjb3VsZG4ndCBjbGVhciBvdXQgdGhlIHZhbHVlIHdpdGhvdXRcbiAgICAgIC8vIGZvcmNpbmcgYW5vdGhlciByZS1yZW5kZXIsIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wc1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wc1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWVcblxuICAgICAgLy8gVE9ETyBUaGlzIGlzIGhhY2t5IGFuZCBub3QgaG93IGB1U0VTYCBpcyBtZWFudCB0byBiZSB1c2VkXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBSZWFjdCBgdXNlU3luY0V4dGVybmFsU3RvcmVgIHN1YnNjcmliZXJcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gQWN0dWFsbHkgc3Vic2NyaWJlIHRvIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3RvciAob3Igc3RvcmUpXG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzXG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKVxuXG4gIC8vIFB1bGwgZGF0YSBmcm9tIHRoZSBzdG9yZSBhZnRlciBmaXJzdCByZW5kZXIgaW4gY2FzZSB0aGUgc3RvcmUgaGFzXG4gIC8vIGNoYW5nZWQgc2luY2Ugd2UgYmVnYW4uXG4gIGNoZWNrRm9yVXBkYXRlcygpXG5cbiAgY29uc3QgdW5zdWJzY3JpYmVXcmFwcGVyID0gKCkgPT4ge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZVxuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpXG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsXG5cbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgd2UgY2F1Z2h0IGFuIGVycm9yIGR1ZSB0byBhIGJhZCBtYXBTdGF0ZSBmdW5jdGlvbiwgYnV0IHRoZVxuICAgICAgLy8gcGFyZW50IHJlLXJlbmRlcmVkIHdpdGhvdXQgdGhpcyBjb21wb25lbnQgYW5kIHdlJ3JlIGFib3V0IHRvIHVubW91bnQuXG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYXMgbG9uZyBhcyB3ZSBkbyB0b3AtZG93biBzdWJzY3JpcHRpb25zIGNvcnJlY3RseSwgYnV0XG4gICAgICAvLyBpZiB3ZSBldmVyIGRvIHRob3NlIHdyb25nLCB0aGlzIHRocm93IHdpbGwgc3VyZmFjZSB0aGUgZXJyb3IgaW4gb3VyIHRlc3RzLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aHJvdyB0aGUgZXJyb3IgZnJvbSBoZXJlIHNvIGl0IGRvZXNuJ3QgZ2V0IGxvc3QuXG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyXG59XG5cbi8vIFJlZHVjZXIgaW5pdGlhbCBzdGF0ZSBjcmVhdGlvbiBmb3Igb3VyIHVwZGF0ZSByZWR1Y2VyXG5jb25zdCBpbml0U3RhdGVVcGRhdGVzID0gKCkgPT4gRU1QVFlfQVJSQVlcblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0UHJvcHMge1xuICAvKiogQSBjdXN0b20gQ29udGV4dCBpbnN0YW5jZSB0aGF0IHRoZSBjb21wb25lbnQgY2FuIHVzZSB0byBhY2Nlc3MgdGhlIHN0b3JlIGZyb20gYW4gYWx0ZXJuYXRlIFByb3ZpZGVyIHVzaW5nIHRoYXQgc2FtZSBDb250ZXh0IGluc3RhbmNlICovXG4gIGNvbnRleHQ/OiBSZWFjdFJlZHV4Q29udGV4dEluc3RhbmNlXG4gIC8qKiBBIFJlZHV4IHN0b3JlIGluc3RhbmNlIHRvIGJlIHVzZWQgZm9yIHN1YnNjcmlwdGlvbnMgaW5zdGVhZCBvZiB0aGUgc3RvcmUgZnJvbSBhIFByb3ZpZGVyICovXG4gIHN0b3JlPzogU3RvcmVcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ29ubmVjdFByb3BzIGV4dGVuZHMgQ29ubmVjdFByb3BzIHtcbiAgcmVhY3RSZWR1eEZvcndhcmRlZFJlZj86IFJlYWN0LkZvcndhcmRlZFJlZjx1bmtub3duPlxufVxuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhOiB1bmtub3duLCBiOiB1bmtub3duKSB7XG4gIHJldHVybiBhID09PSBiXG59XG5cbi8qKlxuICogSW5mZXJzIHRoZSB0eXBlIG9mIHByb3BzIHRoYXQgYSBjb25uZWN0b3Igd2lsbCBpbmplY3QgaW50byBhIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IHR5cGUgQ29ubmVjdGVkUHJvcHM8VENvbm5lY3Rvcj4gPVxuICBUQ29ubmVjdG9yIGV4dGVuZHMgSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8XG4gICAgaW5mZXIgVEluamVjdGVkUHJvcHMsXG4gICAgYW55XG4gID5cbiAgICA/IHVua25vd24gZXh0ZW5kcyBUSW5qZWN0ZWRQcm9wc1xuICAgICAgPyBUQ29ubmVjdG9yIGV4dGVuZHMgSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXI8aW5mZXIgVEluamVjdGVkUHJvcHM+XG4gICAgICAgID8gVEluamVjdGVkUHJvcHNcbiAgICAgICAgOiBuZXZlclxuICAgICAgOiBUSW5qZWN0ZWRQcm9wc1xuICAgIDogbmV2ZXJcblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0T3B0aW9uczxcbiAgU3RhdGUgPSB1bmtub3duLFxuICBUU3RhdGVQcm9wcyA9IHt9LFxuICBUT3duUHJvcHMgPSB7fSxcbiAgVE1lcmdlZFByb3BzID0ge31cbj4ge1xuICBmb3J3YXJkUmVmPzogYm9vbGVhblxuICBjb250ZXh0PzogdHlwZW9mIFJlYWN0UmVkdXhDb250ZXh0XG4gIGFyZVN0YXRlc0VxdWFsPzogKFxuICAgIG5leHRTdGF0ZTogU3RhdGUsXG4gICAgcHJldlN0YXRlOiBTdGF0ZSxcbiAgICBuZXh0T3duUHJvcHM6IFRPd25Qcm9wcyxcbiAgICBwcmV2T3duUHJvcHM6IFRPd25Qcm9wc1xuICApID0+IGJvb2xlYW5cblxuICBhcmVPd25Qcm9wc0VxdWFsPzogKFxuICAgIG5leHRPd25Qcm9wczogVE93blByb3BzLFxuICAgIHByZXZPd25Qcm9wczogVE93blByb3BzXG4gICkgPT4gYm9vbGVhblxuXG4gIGFyZVN0YXRlUHJvcHNFcXVhbD86IChcbiAgICBuZXh0U3RhdGVQcm9wczogVFN0YXRlUHJvcHMsXG4gICAgcHJldlN0YXRlUHJvcHM6IFRTdGF0ZVByb3BzXG4gICkgPT4gYm9vbGVhblxuICBhcmVNZXJnZWRQcm9wc0VxdWFsPzogKFxuICAgIG5leHRNZXJnZWRQcm9wczogVE1lcmdlZFByb3BzLFxuICAgIHByZXZNZXJnZWRQcm9wczogVE1lcmdlZFByb3BzXG4gICkgPT4gYm9vbGVhblxufVxuXG4vKipcbiAqIENvbm5lY3RzIGEgUmVhY3QgY29tcG9uZW50IHRvIGEgUmVkdXggc3RvcmUuXG4gKlxuICogLSBXaXRob3V0IGFyZ3VtZW50cywganVzdCB3cmFwcyB0aGUgY29tcG9uZW50LCB3aXRob3V0IGNoYW5naW5nIHRoZSBiZWhhdmlvciAvIHByb3BzXG4gKlxuICogLSBJZiAyIHBhcmFtcyBhcmUgcGFzc2VkICgzcmQgcGFyYW0sIG1lcmdlUHJvcHMsIGlzIHNraXBwZWQpLCBkZWZhdWx0IGJlaGF2aW9yXG4gKiBpcyB0byBvdmVycmlkZSBvd25Qcm9wcyAoYXMgc3RhdGVkIGluIHRoZSBkb2NzKSwgc28gd2hhdCByZW1haW5zIGlzIGV2ZXJ5dGhpbmcgdGhhdCdzXG4gKiBub3QgYSBzdGF0ZSBvciBkaXNwYXRjaCBwcm9wXG4gKlxuICogLSBXaGVuIDNyZCBwYXJhbSBpcyBwYXNzZWQsIHdlIGRvbid0IGtub3cgaWYgb3duUHJvcHMgcHJvcGFnYXRlIGFuZCB3aGV0aGVyIHRoZXlcbiAqIHNob3VsZCBiZSB2YWxpZCBjb21wb25lbnQgcHJvcHMsIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiBtZXJnZVByb3BzIGltcGxlbWVudGF0aW9uLlxuICogQXMgc3VjaCwgaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBleHRlbmQgb3duUHJvcHMgaW50ZXJmYWNlIGZyb20gc3RhdGUgb3JcbiAqIGRpc3BhdGNoIHByb3BzIG9yIGJvdGggd2hlbiBhcHBsaWNhYmxlXG4gKlxuICogQHBhcmFtIG1hcFN0YXRlVG9Qcm9wc1xuICogQHBhcmFtIG1hcERpc3BhdGNoVG9Qcm9wc1xuICogQHBhcmFtIG1lcmdlUHJvcHNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdDxEZWZhdWx0U3RhdGUgPSB1bmtub3duPiB7XG4gIC8vIHRzbGludDpkaXNhYmxlOm5vLXVubmVjZXNzYXJ5LWdlbmVyaWNzXG4gICgpOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcjxEaXNwYXRjaFByb3A+XG5cbiAgLyoqIG1hcFN0YXRlIG9ubHkgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIG5vX2Rpc3BhdGNoID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT5cbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8VFN0YXRlUHJvcHMgJiBEaXNwYXRjaFByb3AsIFRPd25Qcm9wcz5cblxuICAvKiogbWFwRGlzcGF0Y2ggb25seSAoYXMgYSBmdW5jdGlvbikgKi9cbiAgPG5vX3N0YXRlID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9PihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3Q8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cblxuICAvKiogbWFwRGlzcGF0Y2ggb25seSAoYXMgYW4gb2JqZWN0KSAqL1xuICA8bm9fc3RhdGUgPSB7fSwgVERpc3BhdGNoUHJvcHMgPSB7fSwgVE93blByb3BzID0ge30+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFxuICAgIFJlc29sdmVUaHVua3M8VERpc3BhdGNoUHJvcHM+LFxuICAgIFRPd25Qcm9wc1xuICA+XG5cbiAgLyoqIG1hcFN0YXRlIGFuZCBtYXBEaXNwYXRjaCAoYXMgYSBmdW5jdGlvbikqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgVERpc3BhdGNoUHJvcHMgPSB7fSwgVE93blByb3BzID0ge30sIFN0YXRlID0gRGVmYXVsdFN0YXRlPihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IE1hcFN0YXRlVG9Qcm9wc1BhcmFtPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc05vbk9iamVjdDxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuICApOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wczxcbiAgICBUU3RhdGVQcm9wcyAmIFREaXNwYXRjaFByb3BzLFxuICAgIFRPd25Qcm9wc1xuICA+XG5cbiAgLyoqIG1hcFN0YXRlIGFuZCBtYXBEaXNwYXRjaCAobnVsbGlzaCkgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBudWxsIHwgdW5kZWZpbmVkXG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHM+XG5cbiAgLyoqIG1hcFN0YXRlIGFuZCBtYXBEaXNwYXRjaCAoYXMgYW4gb2JqZWN0KSAqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgVERpc3BhdGNoUHJvcHMgPSB7fSwgVE93blByb3BzID0ge30sIFN0YXRlID0gRGVmYXVsdFN0YXRlPihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IE1hcFN0YXRlVG9Qcm9wc1BhcmFtPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFxuICAgIFRTdGF0ZVByb3BzICYgUmVzb2x2ZVRodW5rczxURGlzcGF0Y2hQcm9wcz4sXG4gICAgVE93blByb3BzXG4gID5cblxuICAvKiogbWVyZ2VQcm9wcyBvbmx5ICovXG4gIDxub19zdGF0ZSA9IHt9LCBub19kaXNwYXRjaCA9IHt9LCBUT3duUHJvcHMgPSB7fSwgVE1lcmdlZFByb3BzID0ge30+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWVyZ2VQcm9wczogTWVyZ2VQcm9wczx1bmRlZmluZWQsIERpc3BhdGNoUHJvcCwgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRNZXJnZWRQcm9wcywgVE93blByb3BzPlxuXG4gIC8qKiBtYXBTdGF0ZSBhbmQgbWVyZ2VQcm9wcyAqL1xuICA8XG4gICAgVFN0YXRlUHJvcHMgPSB7fSxcbiAgICBub19kaXNwYXRjaCA9IHt9LFxuICAgIFRPd25Qcm9wcyA9IHt9LFxuICAgIFRNZXJnZWRQcm9wcyA9IHt9LFxuICAgIFN0YXRlID0gRGVmYXVsdFN0YXRlXG4gID4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG1lcmdlUHJvcHM6IE1lcmdlUHJvcHM8VFN0YXRlUHJvcHMsIERpc3BhdGNoUHJvcCwgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRNZXJnZWRQcm9wcywgVE93blByb3BzPlxuXG4gIC8qKiBtYXBEaXNwYXRjaCAoYXMgYSBvYmplY3QpIGFuZCBtZXJnZVByb3BzICovXG4gIDxub19zdGF0ZSA9IHt9LCBURGlzcGF0Y2hQcm9wcyA9IHt9LCBUT3duUHJvcHMgPSB7fSwgVE1lcmdlZFByb3BzID0ge30+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICAgIG1lcmdlUHJvcHM6IE1lcmdlUHJvcHM8dW5kZWZpbmVkLCBURGlzcGF0Y2hQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRNZXJnZWRQcm9wcywgVE93blByb3BzPlxuXG4gIC8qKiBtYXBTdGF0ZSBhbmQgb3B0aW9ucyAqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgbm9fZGlzcGF0Y2ggPSB7fSwgVE93blByb3BzID0ge30sIFN0YXRlID0gRGVmYXVsdFN0YXRlPihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IE1hcFN0YXRlVG9Qcm9wc1BhcmFtPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWVyZ2VQcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBDb25uZWN0T3B0aW9uczxTdGF0ZSwgVFN0YXRlUHJvcHMsIFRPd25Qcm9wcz5cbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8RGlzcGF0Y2hQcm9wICYgVFN0YXRlUHJvcHMsIFRPd25Qcm9wcz5cblxuICAvKiogbWFwRGlzcGF0Y2ggKGFzIGEgZnVuY3Rpb24pIGFuZCBvcHRpb25zICovXG4gIDxUU3RhdGVQcm9wcyA9IHt9LCBURGlzcGF0Y2hQcm9wcyA9IHt9LCBUT3duUHJvcHMgPSB7fT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG1hcERpc3BhdGNoVG9Qcm9wczogTWFwRGlzcGF0Y2hUb1Byb3BzTm9uT2JqZWN0PFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICAgIG1lcmdlUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogQ29ubmVjdE9wdGlvbnM8e30sIFRTdGF0ZVByb3BzLCBUT3duUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG5cbiAgLyoqIG1hcERpc3BhdGNoIChhcyBhbiBvYmplY3QpIGFuZCBvcHRpb25zKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9PihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgICBtZXJnZVByb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM6IENvbm5lY3RPcHRpb25zPHt9LCBUU3RhdGVQcm9wcywgVE93blByb3BzPlxuICApOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wczxcbiAgICBSZXNvbHZlVGh1bmtzPFREaXNwYXRjaFByb3BzPixcbiAgICBUT3duUHJvcHNcbiAgPlxuXG4gIC8qKiBtYXBTdGF0ZSwgIG1hcERpc3BhdGNoIChhcyBhIGZ1bmN0aW9uKSwgYW5kIG9wdGlvbnMgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3Q8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4sXG4gICAgbWVyZ2VQcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBDb25uZWN0T3B0aW9uczxTdGF0ZSwgVFN0YXRlUHJvcHMsIFRPd25Qcm9wcz5cbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8XG4gICAgVFN0YXRlUHJvcHMgJiBURGlzcGF0Y2hQcm9wcyxcbiAgICBUT3duUHJvcHNcbiAgPlxuXG4gIC8qKiBtYXBTdGF0ZSwgIG1hcERpc3BhdGNoIChhcyBhbiBvYmplY3QpLCBhbmQgb3B0aW9ucyAqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgVERpc3BhdGNoUHJvcHMgPSB7fSwgVE93blByb3BzID0ge30sIFN0YXRlID0gRGVmYXVsdFN0YXRlPihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IE1hcFN0YXRlVG9Qcm9wc1BhcmFtPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICAgIG1lcmdlUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogQ29ubmVjdE9wdGlvbnM8U3RhdGUsIFRTdGF0ZVByb3BzLCBUT3duUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFxuICAgIFRTdGF0ZVByb3BzICYgUmVzb2x2ZVRodW5rczxURGlzcGF0Y2hQcm9wcz4sXG4gICAgVE93blByb3BzXG4gID5cblxuICAvKiogbWFwU3RhdGUsIG1hcERpc3BhdGNoLCBtZXJnZVByb3BzLCBhbmQgb3B0aW9ucyAqL1xuICA8XG4gICAgVFN0YXRlUHJvcHMgPSB7fSxcbiAgICBURGlzcGF0Y2hQcm9wcyA9IHt9LFxuICAgIFRPd25Qcm9wcyA9IHt9LFxuICAgIFRNZXJnZWRQcm9wcyA9IHt9LFxuICAgIFN0YXRlID0gRGVmYXVsdFN0YXRlXG4gID4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgICBtZXJnZVByb3BzOiBNZXJnZVByb3BzPFxuICAgICAgVFN0YXRlUHJvcHMsXG4gICAgICBURGlzcGF0Y2hQcm9wcyxcbiAgICAgIFRPd25Qcm9wcyxcbiAgICAgIFRNZXJnZWRQcm9wc1xuICAgID4sXG4gICAgb3B0aW9ucz86IENvbm5lY3RPcHRpb25zPFN0YXRlLCBUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+XG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRNZXJnZWRQcm9wcywgVE93blByb3BzPlxuICAvLyB0c2xpbnQ6ZW5hYmxlOm5vLXVubmVjZXNzYXJ5LWdlbmVyaWNzXG59XG5cbmxldCBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gZmFsc2VcblxuLyoqXG4gKiBDb25uZWN0cyBhIFJlYWN0IGNvbXBvbmVudCB0byBhIFJlZHV4IHN0b3JlLlxuICpcbiAqIC0gV2l0aG91dCBhcmd1bWVudHMsIGp1c3Qgd3JhcHMgdGhlIGNvbXBvbmVudCwgd2l0aG91dCBjaGFuZ2luZyB0aGUgYmVoYXZpb3IgLyBwcm9wc1xuICpcbiAqIC0gSWYgMiBwYXJhbXMgYXJlIHBhc3NlZCAoM3JkIHBhcmFtLCBtZXJnZVByb3BzLCBpcyBza2lwcGVkKSwgZGVmYXVsdCBiZWhhdmlvclxuICogaXMgdG8gb3ZlcnJpZGUgb3duUHJvcHMgKGFzIHN0YXRlZCBpbiB0aGUgZG9jcyksIHNvIHdoYXQgcmVtYWlucyBpcyBldmVyeXRoaW5nIHRoYXQnc1xuICogbm90IGEgc3RhdGUgb3IgZGlzcGF0Y2ggcHJvcFxuICpcbiAqIC0gV2hlbiAzcmQgcGFyYW0gaXMgcGFzc2VkLCB3ZSBkb24ndCBrbm93IGlmIG93blByb3BzIHByb3BhZ2F0ZSBhbmQgd2hldGhlciB0aGV5XG4gKiBzaG91bGQgYmUgdmFsaWQgY29tcG9uZW50IHByb3BzLCBiZWNhdXNlIGl0IGRlcGVuZHMgb24gbWVyZ2VQcm9wcyBpbXBsZW1lbnRhdGlvbi5cbiAqIEFzIHN1Y2gsIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZXh0ZW5kIG93blByb3BzIGludGVyZmFjZSBmcm9tIHN0YXRlIG9yXG4gKiBkaXNwYXRjaCBwcm9wcyBvciBib3RoIHdoZW4gYXBwbGljYWJsZVxuICpcbiAqIEBwYXJhbSBtYXBTdGF0ZVRvUHJvcHMgQSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHZhbHVlcyBmcm9tIHN0YXRlXG4gKiBAcGFyYW0gbWFwRGlzcGF0Y2hUb1Byb3BzIFNldHVwIGZvciBkaXNwYXRjaGluZyBhY3Rpb25zXG4gKiBAcGFyYW0gbWVyZ2VQcm9wcyBPcHRpb25hbCBjYWxsYmFjayB0byBtZXJnZSBzdGF0ZSBhbmQgZGlzcGF0Y2ggcHJvcHMgdG9nZXRoZXJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSBjb25uZWN0aW9uXG4gKlxuICovXG5mdW5jdGlvbiBjb25uZWN0PFxuICBUU3RhdGVQcm9wcyA9IHt9LFxuICBURGlzcGF0Y2hQcm9wcyA9IHt9LFxuICBUT3duUHJvcHMgPSB7fSxcbiAgVE1lcmdlZFByb3BzID0ge30sXG4gIFN0YXRlID0gdW5rbm93blxuPihcbiAgbWFwU3RhdGVUb1Byb3BzPzogTWFwU3RhdGVUb1Byb3BzUGFyYW08VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+LFxuICBtYXBEaXNwYXRjaFRvUHJvcHM/OiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgbWVyZ2VQcm9wcz86IE1lcmdlUHJvcHM8VFN0YXRlUHJvcHMsIFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHMsIFRNZXJnZWRQcm9wcz4sXG4gIHtcbiAgICAvLyBUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLCBzbyBUUyBkb2Vzbid0IGxpa2UgdXMgZGVzdHJ1Y3R1cmluZyB0aGlzIHRvIGNoZWNrIGl0cyBleGlzdGVuY2UuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHB1cmUsXG4gICAgYXJlU3RhdGVzRXF1YWwgPSBzdHJpY3RFcXVhbCxcbiAgICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAgIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuXG4gICAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gICAgZm9yd2FyZFJlZiA9IGZhbHNlLFxuXG4gICAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gICAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0LFxuICB9OiBDb25uZWN0T3B0aW9uczx1bmtub3duLCB1bmtub3duLCB1bmtub3duLCB1bmtub3duPiA9IHt9LFxuKTogdW5rbm93biB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHB1cmUgIT09IHVuZGVmaW5lZCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWVcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCcsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHRcblxuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpXG4gIGNvbnN0IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcylcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKVxuXG4gIGNvbnN0IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKVxuXG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IDxUUHJvcHMsPihcbiAgICBXcmFwcGVkQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFRQcm9wcz4sXG4gICkgPT4ge1xuICAgIHR5cGUgV3JhcHBlZENvbXBvbmVudFByb3BzID0gVFByb3BzICZcbiAgICAgIENvbm5lY3RQcm9wc01heWJlV2l0aG91dENvbnRleHQ8VFByb3BzPlxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiNfX1BVUkVfXyovIGlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KVxuICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID1cbiAgICAgIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnXG5cbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWBcblxuICAgIGNvbnN0IHNlbGVjdG9yRmFjdG9yeU9wdGlvbnM6IFNlbGVjdG9yRmFjdG9yeU9wdGlvbnM8XG4gICAgICBhbnksXG4gICAgICBhbnksXG4gICAgICBhbnksXG4gICAgICBhbnksXG4gICAgICBTdGF0ZVxuICAgID4gPSB7XG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgICBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsLFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbjxUT3duUHJvcHM+KFxuICAgICAgcHJvcHM6IEludGVybmFsQ29ubmVjdFByb3BzICYgVE93blByb3BzLFxuICAgICkge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9XG4gICAgICAgIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAgIC8vIERpc3Rpbmd1aXNoIGJldHdlZW4gYWN0dWFsIFwiZGF0YVwiIHByb3BzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZXIgY29tcG9uZW50LFxuICAgICAgICAgIC8vIGFuZCB2YWx1ZXMgbmVlZGVkIHRvIGNvbnRyb2wgYmVoYXZpb3IgKGZvcndhcmRlZCByZWZzLCBhbHRlcm5hdGUgY29udGV4dCBpbnN0YW5jZXMpLlxuICAgICAgICAgIC8vIFRvIG1haW50YWluIHRoZSB3cmFwcGVyUHJvcHMgb2JqZWN0IHJlZmVyZW5jZSwgbWVtb2l6ZSB0aGlzIGRlc3RydWN0dXJpbmcuXG4gICAgICAgICAgY29uc3QgeyByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCAuLi53cmFwcGVyUHJvcHMgfSA9IHByb3BzXG4gICAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdXG4gICAgICAgIH0sIFtwcm9wc10pXG5cbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZTogUmVhY3RSZWR1eENvbnRleHRJbnN0YW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvLyBVc2VycyBtYXkgb3B0aW9uYWxseSBwYXNzIGluIGEgY3VzdG9tIGNvbnRleHQgaW5zdGFuY2UgdG8gdXNlIGluc3RlYWQgb2Ygb3VyIFJlYWN0UmVkdXhDb250ZXh0LlxuICAgICAgICAvLyBNZW1vaXplIHRoZSBjaGVjayB0aGF0IGRldGVybWluZXMgd2hpY2ggY29udGV4dCBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLlxuICAgICAgICBsZXQgUmVzdWx0Q29udGV4dCA9IENvbnRleHRcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC8qI19fUFVSRV9fKi8gaXNDb250ZXh0Q29uc3VtZXIoXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgPHByb3BzQ29udGV4dC5Db25zdW1lciAvPixcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1lvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIGFzIGBwcm9wcy5jb250ZXh0YCcsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc3VsdENvbnRleHRcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKVxuXG4gICAgICAvLyBSZXRyaWV2ZSB0aGUgc3RvcmUgYW5kIGFuY2VzdG9yIHN1YnNjcmlwdGlvbiB2aWEgY29udGV4dCwgaWYgYXZhaWxhYmxlXG4gICAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHRUb1VzZSlcblxuICAgICAgLy8gVGhlIHN0b3JlIF9tdXN0XyBleGlzdCBhcyBlaXRoZXIgYSBwcm9wIG9yIGluIGNvbnRleHQuXG4gICAgICAvLyBXZSdsbCBjaGVjayB0byBzZWUgaWYgaXQgX2xvb2tzXyBsaWtlIGEgUmVkdXggc3RvcmUgZmlyc3QuXG4gICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBwYXNzIHRocm91Z2ggYSBgc3RvcmVgIHByb3AgdGhhdCBpcyBqdXN0IGEgcGxhaW4gdmFsdWUuXG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPVxuICAgICAgICBCb29sZWFuKHByb3BzLnN0b3JlKSAmJlxuICAgICAgICBCb29sZWFuKHByb3BzLnN0b3JlIS5nZXRTdGF0ZSkgJiZcbiAgICAgICAgQm9vbGVhbihwcm9wcy5zdG9yZSEuZGlzcGF0Y2gpXG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9XG4gICAgICAgIEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZSEuc3RvcmUpXG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAhZGlkU3RvcmVDb21lRnJvbVByb3BzICYmXG4gICAgICAgICFkaWRTdG9yZUNvbWVGcm9tQ29udGV4dFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIGAgK1xuICAgICAgICAgICAgYFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgYCArXG4gICAgICAgICAgICBgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIGAgK1xuICAgICAgICAgICAgYFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmAsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gQmFzZWQgb24gdGhlIHByZXZpb3VzIGNoZWNrLCBvbmUgb2YgdGhlc2UgbXVzdCBiZSB0cnVlXG4gICAgICBjb25zdCBzdG9yZTogU3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHNcbiAgICAgICAgPyBwcm9wcy5zdG9yZSFcbiAgICAgICAgOiBjb250ZXh0VmFsdWUhLnN0b3JlXG5cbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHRcbiAgICAgICAgPyBjb250ZXh0VmFsdWUhLmdldFNlcnZlclN0YXRlXG4gICAgICAgIDogc3RvcmUuZ2V0U3RhdGVcblxuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBjaGlsZCBwcm9wcyBzZWxlY3RvciBuZWVkcyB0aGUgc3RvcmUgcmVmZXJlbmNlIGFzIGFuIGlucHV0LlxuICAgICAgICAvLyBSZS1jcmVhdGUgdGhpcyBzZWxlY3RvciB3aGVuZXZlciB0aGUgc3RvcmUgY2hhbmdlcy5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpXG4gICAgICB9LCBbc3RvcmVdKVxuXG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWVxuXG4gICAgICAgIC8vIFRoaXMgU3Vic2NyaXB0aW9uJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyB1bmRlZmluZWQgOiBjb250ZXh0VmFsdWUhLnN1YnNjcmlwdGlvbixcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIGBub3RpZnlOZXN0ZWRTdWJzYCBpcyBkdXBsaWNhdGVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZCBpblxuICAgICAgICAvLyB0aGUgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcCwgd2hlcmUgYHN1YnNjcmlwdGlvbmAgd2lsbCB0aGVuIGJlIG51bGwuIFRoaXMgY2FuXG4gICAgICAgIC8vIHByb2JhYmx5IGJlIGF2b2lkZWQgaWYgU3Vic2NyaXB0aW9uJ3MgbGlzdGVuZXJzIGxvZ2ljIGlzIGNoYW5nZWQgdG8gbm90IGNhbGwgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRoYXQgaGF2ZSBiZWVuIHVuc3Vic2NyaWJlZCBpbiB0aGUgIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AuXG4gICAgICAgIGNvbnN0IG5vdGlmeU5lc3RlZFN1YnMgPVxuICAgICAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQoc3Vic2NyaXB0aW9uKVxuXG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXVxuICAgICAgfSwgW3N0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZV0pXG5cbiAgICAgIC8vIERldGVybWluZSB3aGF0IHtzdG9yZSwgc3Vic2NyaXB0aW9ufSB2YWx1ZSBzaG91bGQgYmUgcHV0IGludG8gbmVzdGVkIGNvbnRleHQsIGlmIG5lY2Vzc2FyeSxcbiAgICAgIC8vIGFuZCBtZW1vaXplIHRoYXQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udGV4dCB1cGRhdGVzLlxuICAgICAgY29uc3Qgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wb25lbnQgaXMgZGlyZWN0bHkgc3Vic2NyaWJlZCB0byBhIHN0b3JlIGZyb20gcHJvcHMuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBkZXNjZW5kYW50cyByZWFkaW5nIGZyb20gdGhpcyBzdG9yZSAtIHBhc3MgZG93biB3aGF0ZXZlclxuICAgICAgICAgIC8vIHRoZSBleGlzdGluZyBjb250ZXh0IHZhbHVlIGlzIGZyb20gdGhlIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yLlxuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWUhXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIHB1dCB0aGlzIGNvbXBvbmVudCdzIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBpbnRvIGNvbnRleHQsIHNvIHRoYXRcbiAgICAgICAgLy8gY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdvbid0IHVwZGF0ZSB1bnRpbCBhZnRlciB0aGlzIGNvbXBvbmVudCBpcyBkb25lXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgfSBhcyBSZWFjdFJlZHV4Q29udGV4dFZhbHVlXG4gICAgICB9LCBbZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWUsIHN1YnNjcmlwdGlvbl0pXG5cbiAgICAgIC8vIFNldCB1cCByZWZzIHRvIGNvb3JkaW5hdGUgdmFsdWVzIGJldHdlZW4gdGhlIHN1YnNjcmlwdGlvbiBlZmZlY3QgYW5kIHRoZSByZW5kZXIgbG9naWNcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmPHVua25vd24+KClcbiAgICAgIGNvbnN0IGxhc3RXcmFwcGVyUHJvcHMgPSBSZWFjdC51c2VSZWYod3JhcHBlclByb3BzKVxuICAgICAgY29uc3QgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSA9IFJlYWN0LnVzZVJlZjx1bmtub3duPigpXG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSlcbiAgICAgIGNvbnN0IGlzUHJvY2Vzc2luZ0Rpc3BhdGNoID0gUmVhY3QudXNlUmVmKGZhbHNlKVxuICAgICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKVxuXG4gICAgICBjb25zdCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmPEVycm9yPigpXG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWVcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sIFtdKVxuXG4gICAgICBjb25zdCBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVHJpY2t5IGxvZ2ljIGhlcmU6XG4gICAgICAgICAgLy8gLSBUaGlzIHJlbmRlciBtYXkgaGF2ZSBiZWVuIHRyaWdnZXJlZCBieSBhIFJlZHV4IHN0b3JlIHVwZGF0ZSB0aGF0IHByb2R1Y2VkIG5ldyBjaGlsZCBwcm9wc1xuICAgICAgICAgIC8vIC0gSG93ZXZlciwgd2UgbWF5IGhhdmUgZ290dGVuIG5ldyB3cmFwcGVyIHByb3BzIGFmdGVyIHRoYXRcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5ldyBjaGlsZCBwcm9wcywgYW5kIHRoZSBzYW1lIHdyYXBwZXIgcHJvcHMsIHdlIGtub3cgd2Ugc2hvdWxkIHVzZSB0aGUgbmV3IGNoaWxkIHByb3BzIGFzLWlzLlxuICAgICAgICAgIC8vIEJ1dCwgaWYgd2UgaGF2ZSBuZXcgd3JhcHBlciBwcm9wcywgdGhvc2UgbWlnaHQgY2hhbmdlIHRoZSBjaGlsZCBwcm9wcywgc28gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGluZ3MuXG4gICAgICAgICAgLy8gU28sIHdlJ2xsIHVzZSB0aGUgY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGUgb25seSBpZiB0aGUgd3JhcHBlciBwcm9wcyBhcmUgdGhlIHNhbWUgYXMgbGFzdCB0aW1lLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJlxuICAgICAgICAgICAgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHJlYWRpbmcgdGhlIHN0b3JlIGRpcmVjdGx5IGluIHJlbmRlcigpIGhlcmUuIEJhZCBpZGVhP1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgQmFkIFRoaW5ncyAoVE0pIHRvIGhhcHBlbiBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIHRoaXMgYmVjYXVzZSBvbiByZW5kZXJzIF9ub3RfIGNhdXNlZCBieSBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRoZSBsYXRlc3Qgc3RvcmUgc3RhdGVcbiAgICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlLlxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RvclxuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKVxuXG4gICAgICAvLyBXZSBuZWVkIHRoaXMgdG8gZXhlY3V0ZSBzeW5jaHJvbm91c2x5IGV2ZXJ5IHRpbWUgd2UgcmUtcmVuZGVyLiBIb3dldmVyLCBSZWFjdCB3YXJuc1xuICAgICAgLy8gYWJvdXQgdXNlTGF5b3V0RWZmZWN0IGluIFNTUiwgc28gd2UgdHJ5IHRvIGRldGVjdCBlbnZpcm9ubWVudCBhbmQgZmFsbCBiYWNrIHRvXG4gICAgICAvLyBqdXN0IHVzZUVmZmVjdCBpbnN0ZWFkIHRvIGF2b2lkIHRoZSB3YXJuaW5nLCBzaW5jZSBuZWl0aGVyIHdpbGwgcnVuIGFueXdheS5cblxuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKHJlYWN0TGlzdGVuZXI6ICgpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZVVwZGF0ZXMoXG4gICAgICAgICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICAgICAgaXNNb3VudGVkLFxuICAgICAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgICAgICAgICByZWFjdExpc3RlbmVyLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVcbiAgICAgIH0sIFtzdWJzY3JpcHRpb25dKVxuXG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW1xuICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgIHdyYXBwZXJQcm9wcyxcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgIF0pXG5cbiAgICAgIGxldCBhY3R1YWxDaGlsZFByb3BzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuXG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGVcbiAgICAgICAgICAgID8gKCkgPT4gY2hpbGRQcm9wc1NlbGVjdG9yKGdldFNlcnZlclN0YXRlKCksIHdyYXBwZXJQcm9wcylcbiAgICAgICAgICAgIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICApXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1zZW1pXG4gICAgICAgICAgOyhcbiAgICAgICAgICAgIGVyciBhcyBFcnJvclxuICAgICAgICAgICkubWVzc2FnZSArPSBgXFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcXG4ke2xhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFja31cXG5cXG5gXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZFxuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHNcbiAgICAgIH0pXG5cbiAgICAgIC8vIE5vdyB0aGF0IGFsbCB0aGF0J3MgZG9uZSwgd2UgY2FuIGZpbmFsbHkgdHJ5IHRvIGFjdHVhbGx5IHJlbmRlciB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAgLy8gV2UgbWVtb2l6ZSB0aGUgZWxlbWVudHMgZm9yIHRoZSByZW5kZXJlZCBjaGlsZCBjb21wb25lbnQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgICAgY29uc3QgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIDxXcmFwcGVkQ29tcG9uZW50XG4gICAgICAgICAgICB7Li4uYWN0dWFsQ2hpbGRQcm9wc31cbiAgICAgICAgICAgIHJlZj17cmVhY3RSZWR1eEZvcndhcmRlZFJlZn1cbiAgICAgICAgICAvPlxuICAgICAgICApXG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pXG5cbiAgICAgIC8vIElmIFJlYWN0IHNlZXMgdGhlIGV4YWN0IHNhbWUgZWxlbWVudCByZWZlcmVuY2UgYXMgbGFzdCB0aW1lLCBpdCBiYWlscyBvdXQgb2YgcmUtcmVuZGVyaW5nXG4gICAgICAvLyB0aGF0IGNoaWxkLCBzYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIFJlYWN0Lm1lbW8oKSBvciByZXR1cm5lZCBmYWxzZSBmcm9tIHNob3VsZENvbXBvbmVudFVwZGF0ZS5cbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGlzIHN1YnNjcmliZWQgdG8gc3RvcmUgdXBkYXRlcywgd2UgbmVlZCB0byBwYXNzIGl0cyBvd25cbiAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgZG93biB0byBvdXIgZGVzY2VuZGFudHMuIFRoYXQgbWVhbnMgcmVuZGVyaW5nIHRoZSBzYW1lXG4gICAgICAgICAgLy8gQ29udGV4dCBpbnN0YW5jZSwgYW5kIHB1dHRpbmcgYSBkaWZmZXJlbnQgdmFsdWUgaW50byB0aGUgY29udGV4dC5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPENvbnRleHRUb1VzZS5Qcm92aWRlciB2YWx1ZT17b3ZlcnJpZGRlbkNvbnRleHRWYWx1ZX0+XG4gICAgICAgICAgICAgIHtyZW5kZXJlZFdyYXBwZWRDb21wb25lbnR9XG4gICAgICAgICAgICA8L0NvbnRleHRUb1VzZS5Qcm92aWRlcj5cbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKVxuXG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZFxuICAgIH1cblxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pXG5cbiAgICB0eXBlIENvbm5lY3RlZFdyYXBwZXJDb21wb25lbnQgPSB0eXBlb2YgX0Nvbm5lY3QgJiB7XG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiB0eXBlb2YgV3JhcHBlZENvbXBvbmVudFxuICAgIH1cblxuICAgIC8vIEFkZCBhIGhhY2t5IGNhc3QgdG8gZ2V0IHRoZSByaWdodCBvdXRwdXQgdHlwZVxuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdCBhcyB1bmtub3duIGFzIENvbm5lY3RlZENvbXBvbmVudDxcbiAgICAgIHR5cGVvZiBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgV3JhcHBlZENvbXBvbmVudFByb3BzXG4gICAgPlxuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnRcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gQ29ubmVjdEZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWVcblxuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlZixcbiAgICAgICkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiA8Q29ubmVjdCB7Li4ucHJvcHN9IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY9e3JlZn0gLz5cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IF9mb3J3YXJkZWQgYXMgQ29ubmVjdGVkV3JhcHBlckNvbXBvbmVudFxuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWVcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudFxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gaG9pc3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBob2lzdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudClcbiAgfVxuXG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Rcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdCBhcyBDb25uZWN0XG4iLCJpbXBvcnQgdHlwZSB7IENvbnRleHQsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgUmVhY3QgfSBmcm9tICcuLi91dGlscy9yZWFjdCdcbmltcG9ydCB0eXBlIHsgQWN0aW9uLCBTdG9yZSwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHR5cGUgeyBEZXZNb2RlQ2hlY2tGcmVxdWVuY3kgfSBmcm9tICcuLi9ob29rcy91c2VTZWxlY3RvcidcbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbidcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0J1xuaW1wb3J0IHR5cGUgeyBSZWFjdFJlZHV4Q29udGV4dFZhbHVlIH0gZnJvbSAnLi9Db250ZXh0J1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvdmlkZXJQcm9wczxcbiAgQSBleHRlbmRzIEFjdGlvbjxzdHJpbmc+ID0gVW5rbm93bkFjdGlvbixcbiAgUyA9IHVua25vd25cbj4ge1xuICAvKipcbiAgICogVGhlIHNpbmdsZSBSZWR1eCBzdG9yZSBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgc3RvcmU6IFN0b3JlPFMsIEE+XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHNlcnZlciBzdGF0ZSBzbmFwc2hvdC4gV2lsbCBiZSB1c2VkIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvbiByZW5kZXIgaWYgYXZhaWxhYmxlLCB0byBlbnN1cmUgdGhhdCB0aGUgVUkgb3V0cHV0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgSFRNTCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlci5cbiAgICovXG4gIHNlcnZlclN0YXRlPzogU1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjb250ZXh0IHRvIGJlIHVzZWQgaW50ZXJuYWxseSBpbiByZWFjdC1yZWR1eC4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB0byBjcmVhdGUgYSBjb250ZXh0IHRvIGJlIHVzZWQuXG4gICAqIElmIHRoaXMgaXMgdXNlZCwgeW91J2xsIG5lZWQgdG8gY3VzdG9taXplIGBjb25uZWN0YCBieSBzdXBwbHlpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlZCB0byB0aGUgUHJvdmlkZXIuXG4gICAqIFNldCB0aGUgaW5pdGlhbCB2YWx1ZSB0byBudWxsLCBhbmQgdGhlIGhvb2tzIHdpbGwgZXJyb3JcbiAgICogaWYgdGhpcyBpcyBub3Qgb3ZlcndyaXR0ZW4gYnkgUHJvdmlkZXIuXG4gICAqL1xuICBjb250ZXh0PzogQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlPFMsIEE+IHwgbnVsbD5cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgZnJlcXVlbmN5IG9mIHN0YWJpbGl0eSBjaGVja3MgZm9yIGFsbCBzZWxlY3RvcnMuXG4gICAqIFRoaXMgc2V0dGluZyBvdmVycmlkZXMgdGhlIGdsb2JhbCBjb25maWd1cmF0aW9uIGZvclxuICAgKiB0aGUgYHVzZVNlbGVjdG9yYCBzdGFiaWxpdHkgY2hlY2ssIGFsbG93aW5nIHlvdSB0byBzcGVjaWZ5IGhvdyBvZnRlblxuICAgKiB0aGVzZSBjaGVja3Mgc2hvdWxkIG9jY3VyIGluIGRldmVsb3BtZW50IG1vZGUuXG4gICAqXG4gICAqIEBzaW5jZSA4LjEuMFxuICAgKi9cbiAgc3RhYmlsaXR5Q2hlY2s/OiBEZXZNb2RlQ2hlY2tGcmVxdWVuY3lcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgZnJlcXVlbmN5IG9mIGlkZW50aXR5IGZ1bmN0aW9uIGNoZWNrcyBmb3IgYWxsIHNlbGVjdG9ycy5cbiAgICogVGhpcyBzZXR0aW5nIG92ZXJyaWRlcyB0aGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yXG4gICAqIHRoZSBgdXNlU2VsZWN0b3JgIGlkZW50aXR5IGZ1bmN0aW9uIGNoZWNrLCBhbGxvd2luZyB5b3UgdG8gc3BlY2lmeSBob3cgb2Z0ZW5cbiAgICogdGhlc2UgY2hlY2tzIHNob3VsZCBvY2N1ciBpbiBkZXZlbG9wbWVudCBtb2RlLlxuICAgKlxuICAgKiAqKk5vdGUqKjogUHJldmlvdXNseSByZWZlcnJlZCB0byBhcyBgbm9vcENoZWNrYC5cbiAgICpcbiAgICogQHNpbmNlIDkuMC4wXG4gICAqL1xuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s/OiBEZXZNb2RlQ2hlY2tGcmVxdWVuY3lcblxuICBjaGlsZHJlbjogUmVhY3ROb2RlXG59XG5cbmZ1bmN0aW9uIFByb3ZpZGVyPEEgZXh0ZW5kcyBBY3Rpb248c3RyaW5nPiA9IFVua25vd25BY3Rpb24sIFMgPSB1bmtub3duPih7XG4gIHN0b3JlLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgc2VydmVyU3RhdGUsXG4gIHN0YWJpbGl0eUNoZWNrID0gJ29uY2UnLFxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSAnb25jZScsXG59OiBQcm92aWRlclByb3BzPEEsIFM+KSB7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSlcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgIH1cbiAgfSwgW3N0b3JlLCBzZXJ2ZXJTdGF0ZSwgc3RhYmlsaXR5Q2hlY2ssIGlkZW50aXR5RnVuY3Rpb25DaGVja10pXG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSlcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlXG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vic1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKVxuXG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKClcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpXG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSwgW2NvbnRleHRWYWx1ZSwgcHJldmlvdXNTdGF0ZV0pXG5cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHRcblxuICAvLyBAdHMtaWdub3JlICdBbnlBY3Rpb24nIGlzIGFzc2lnbmFibGUgdG8gdGhlIGNvbnN0cmFpbnQgb2YgdHlwZSAnQScsIGJ1dCAnQScgY291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBkaWZmZXJlbnQgc3VidHlwZVxuICByZXR1cm4gPENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+e2NoaWxkcmVufTwvQ29udGV4dC5Qcm92aWRlcj5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvdmlkZXJcbiIsImltcG9ydCB0eXBlIHsgQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24sIFN0b3JlIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgdHlwZSB7IFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnXG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCdcbmltcG9ydCB7XG4gIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2ssXG4gIHVzZVJlZHV4Q29udGV4dCBhcyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0LFxufSBmcm9tICcuL3VzZVJlZHV4Q29udGV4dCdcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHlwZSB0aGF0IGV4dHJhY3RzIHRoZSBhY3Rpb24gdHlwZSBmcm9tIGEgZ2l2ZW4gUmVkdXggc3RvcmUuXG4gKlxuICogQHRlbXBsYXRlIFN0b3JlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBSZWR1eCBzdG9yZS5cbiAqXG4gKiBAc2luY2UgOS4xLjBcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBFeHRyYWN0U3RvcmVBY3Rpb25UeXBlPFN0b3JlVHlwZSBleHRlbmRzIFN0b3JlPiA9XG4gIFN0b3JlVHlwZSBleHRlbmRzIFN0b3JlPGFueSwgaW5mZXIgQWN0aW9uVHlwZT4gPyBBY3Rpb25UeXBlIDogbmV2ZXJcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY3VzdG9tIGhvb2sgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIFJlZHV4IHN0b3JlLlxuICpcbiAqIEB0ZW1wbGF0ZSBTdG9yZVR5cGUgLSBUaGUgc3BlY2lmaWMgdHlwZSBvZiB0aGUgUmVkdXggc3RvcmUgdGhhdCBnZXRzIHJldHVybmVkLlxuICpcbiAqIEBzaW5jZSA5LjEuMFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVN0b3JlPFN0b3JlVHlwZSBleHRlbmRzIFN0b3JlPiB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBSZWR1eCBzdG9yZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIFJlZHV4IHN0b3JlIGluc3RhbmNlLlxuICAgKi9cbiAgKCk6IFN0b3JlVHlwZVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBSZWR1eCBzdG9yZSBpbnN0YW5jZSB3aXRoIHNwZWNpZmljIHN0YXRlIGFuZCBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBSZWR1eCBzdG9yZSB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdGUgYW5kIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHRlbXBsYXRlIFN0YXRlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBzdGF0ZSB1c2VkIGluIHRoZSBzdG9yZS5cbiAgICogQHRlbXBsYXRlIEFjdGlvblR5cGUgLSBUaGUgc3BlY2lmaWMgdHlwZSBvZiB0aGUgYWN0aW9ucyB1c2VkIGluIHRoZSBzdG9yZS5cbiAgICovXG4gIDxcbiAgICBTdGF0ZVR5cGUgZXh0ZW5kcyBSZXR1cm5UeXBlPFN0b3JlVHlwZVsnZ2V0U3RhdGUnXT4gPSBSZXR1cm5UeXBlPFxuICAgICAgU3RvcmVUeXBlWydnZXRTdGF0ZSddXG4gICAgPixcbiAgICBBY3Rpb25UeXBlIGV4dGVuZHMgQWN0aW9uID0gRXh0cmFjdFN0b3JlQWN0aW9uVHlwZTxTdG9yZT5cbiAgPigpOiBTdG9yZTxTdGF0ZVR5cGUsIEFjdGlvblR5cGU+XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBcInByZS10eXBlZFwiIHZlcnNpb24gb2Yge0BsaW5rY29kZSB1c2VTdG9yZSB1c2VTdG9yZX1cbiAgICogd2hlcmUgdGhlIHR5cGUgb2YgdGhlIFJlZHV4IGBzdG9yZWAgaXMgcHJlZGVmaW5lZC5cbiAgICpcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIHNldCB0aGUgYHN0b3JlYCB0eXBlIG9uY2UsIGVsaW1pbmF0aW5nIHRoZSBuZWVkIHRvXG4gICAqIHNwZWNpZnkgaXQgd2l0aCBldmVyeSB7QGxpbmtjb2RlIHVzZVN0b3JlIHVzZVN0b3JlfSBjYWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByZS10eXBlZCBgdXNlU3RvcmVgIHdpdGggdGhlIHN0b3JlIHR5cGUgYWxyZWFkeSBkZWZpbmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBleHBvcnQgY29uc3QgdXNlQXBwU3RvcmUgPSB1c2VTdG9yZS53aXRoVHlwZXM8QXBwU3RvcmU+KClcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZVN0b3JlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBSZWR1eCBzdG9yZSB0aGF0IGdldHMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBzaW5jZSA5LjEuMFxuICAgKi9cbiAgd2l0aFR5cGVzOiA8XG4gICAgT3ZlcnJpZGVTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZVR5cGVcbiAgPigpID0+IFVzZVN0b3JlPE92ZXJyaWRlU3RvcmVUeXBlPlxufVxuXG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVN0b3JlYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vazxcbiAgU3RhdGVUeXBlID0gdW5rbm93bixcbiAgQWN0aW9uVHlwZSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvblxuPihcbiAgLy8gQHRzLWlnbm9yZVxuICBjb250ZXh0PzogQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlPFxuICAgIFN0YXRlVHlwZSxcbiAgICBBY3Rpb25UeXBlXG4gID4gfCBudWxsPiA9IFJlYWN0UmVkdXhDb250ZXh0XG4pIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0ID1cbiAgICBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dFxuICAgICAgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0XG4gICAgICA6IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuICBjb25zdCB1c2VTdG9yZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQoKVxuICAgIHJldHVybiBzdG9yZVxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUsXG4gIH0pXG5cbiAgcmV0dXJuIHVzZVN0b3JlIGFzIFVzZVN0b3JlPFN0b3JlPFN0YXRlVHlwZSwgQWN0aW9uVHlwZT4+XG59XG5cbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggc3RvcmUuXG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHJlZHV4IHN0b3JlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBFeGFtcGxlQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKClcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTdG9yZSA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU3RvcmVIb29rKClcbiIsImltcG9ydCB0eXBlIHsgQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24sIERpc3BhdGNoLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnXG5cbmltcG9ydCB0eXBlIHsgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuaW1wb3J0IHsgY3JlYXRlU3RvcmVIb29rLCB1c2VTdG9yZSBhcyB1c2VEZWZhdWx0U3RvcmUgfSBmcm9tICcuL3VzZVN0b3JlJ1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjdXN0b20gaG9vayB0aGF0IHByb3ZpZGVzIGEgZGlzcGF0Y2ggZnVuY3Rpb25cbiAqIGZyb20gdGhlIFJlZHV4IHN0b3JlLlxuICpcbiAqIEB0ZW1wbGF0ZSBEaXNwYXRjaFR5cGUgLSBUaGUgc3BlY2lmaWMgdHlwZSBvZiB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24uXG4gKlxuICogQHNpbmNlIDkuMS4wXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRGlzcGF0Y2g8XG4gIERpc3BhdGNoVHlwZSBleHRlbmRzIERpc3BhdGNoPFVua25vd25BY3Rpb24+ID0gRGlzcGF0Y2g8VW5rbm93bkFjdGlvbj5cbj4ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24gZnJvbSB0aGUgUmVkdXggc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBkaXNwYXRjaCBmdW5jdGlvbiBmcm9tIHRoZSBSZWR1eCBzdG9yZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIEFwcERpc3BhdGNoIC0gVGhlIHNwZWNpZmljIHR5cGUgb2YgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uLlxuICAgKi9cbiAgPEFwcERpc3BhdGNoIGV4dGVuZHMgRGlzcGF0Y2hUeXBlID0gRGlzcGF0Y2hUeXBlPigpOiBBcHBEaXNwYXRjaFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgXCJwcmUtdHlwZWRcIiB2ZXJzaW9uIG9mIHtAbGlua2NvZGUgdXNlRGlzcGF0Y2ggdXNlRGlzcGF0Y2h9XG4gICAqIHdoZXJlIHRoZSB0eXBlIG9mIHRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGlzIHByZWRlZmluZWQuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIGBkaXNwYXRjaGAgdHlwZSBvbmNlLCBlbGltaW5hdGluZyB0aGUgbmVlZCB0b1xuICAgKiBzcGVjaWZ5IGl0IHdpdGggZXZlcnkge0BsaW5rY29kZSB1c2VEaXNwYXRjaCB1c2VEaXNwYXRjaH0gY2FsbC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcmUtdHlwZWQgYHVzZURpc3BhdGNoYCB3aXRoIHRoZSBkaXNwYXRjaCB0eXBlIGFscmVhZHkgZGVmaW5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogZXhwb3J0IGNvbnN0IHVzZUFwcERpc3BhdGNoID0gdXNlRGlzcGF0Y2gud2l0aFR5cGVzPEFwcERpc3BhdGNoPigpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGVtcGxhdGUgT3ZlcnJpZGVEaXNwYXRjaFR5cGUgLSBUaGUgc3BlY2lmaWMgdHlwZSBvZiB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzaW5jZSA5LjEuMFxuICAgKi9cbiAgd2l0aFR5cGVzOiA8XG4gICAgT3ZlcnJpZGVEaXNwYXRjaFR5cGUgZXh0ZW5kcyBEaXNwYXRjaFR5cGVcbiAgPigpID0+IFVzZURpc3BhdGNoPE92ZXJyaWRlRGlzcGF0Y2hUeXBlPlxufVxuXG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VEaXNwYXRjaGAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZURpc3BhdGNoYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vazxcbiAgU3RhdGVUeXBlID0gdW5rbm93bixcbiAgQWN0aW9uVHlwZSBleHRlbmRzIEFjdGlvbiA9IFVua25vd25BY3Rpb25cbj4oXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dD86IENvbnRleHQ8UmVhY3RSZWR1eENvbnRleHRWYWx1ZTxcbiAgICBTdGF0ZVR5cGUsXG4gICAgQWN0aW9uVHlwZVxuICA+IHwgbnVsbD4gPSBSZWFjdFJlZHV4Q29udGV4dFxuKSB7XG4gIGNvbnN0IHVzZVN0b3JlID1cbiAgICBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KVxuXG4gIGNvbnN0IHVzZURpc3BhdGNoID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKVxuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaFxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbih1c2VEaXNwYXRjaCwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gsXG4gIH0pXG5cbiAgcmV0dXJuIHVzZURpc3BhdGNoIGFzIFVzZURpc3BhdGNoPERpc3BhdGNoPEFjdGlvblR5cGU+PlxufVxuXG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHJlZHV4IGBkaXNwYXRjaGAgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge2FueXxmdW5jdGlvbn0gcmVkdXggc3RvcmUncyBgZGlzcGF0Y2hgIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IHVzZURpc3BhdGNoIH0gZnJvbSAncmVhY3QtcmVkdXgnXG4gKlxuICogZXhwb3J0IGNvbnN0IENvdW50ZXJDb21wb25lbnQgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gKiAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKVxuICogICBjb25zdCBpbmNyZWFzZUNvdW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdpbmNyZWFzZS1jb3VudGVyJyB9KSwgW10pXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxzcGFuPnt2YWx1ZX08L3NwYW4+XG4gKiAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2luY3JlYXNlQ291bnRlcn0+SW5jcmVhc2UgY291bnRlcjwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApXG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCB1c2VEaXNwYXRjaCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGlzcGF0Y2hIb29rKClcbiIsImltcG9ydCBjb25uZWN0IGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0J1xuZXhwb3J0IHR5cGUge1xuICBDb25uZWN0LFxuICBDb25uZWN0UHJvcHMsXG4gIENvbm5lY3RlZFByb3BzLFxufSBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdCdcblxuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuL3V0aWxzL3NoYWxsb3dFcXVhbCdcblxuaW1wb3J0IFByb3ZpZGVyIGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcidcbmltcG9ydCB7IGRlZmF1bHROb29wQmF0Y2ggfSBmcm9tICcuL3V0aWxzL2JhdGNoJ1xuXG5leHBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0J1xuZXhwb3J0IHR5cGUgeyBSZWFjdFJlZHV4Q29udGV4dFZhbHVlIH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbnRleHQnXG5cbmV4cG9ydCB0eXBlIHsgUHJvdmlkZXJQcm9wcyB9IGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcidcblxuZXhwb3J0IHR5cGUge1xuICBNYXBEaXNwYXRjaFRvUHJvcHMsXG4gIE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnksXG4gIE1hcERpc3BhdGNoVG9Qcm9wc0Z1bmN0aW9uLFxuICBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3QsXG4gIE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtLFxuICBNYXBTdGF0ZVRvUHJvcHMsXG4gIE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnksXG4gIE1hcFN0YXRlVG9Qcm9wc1BhcmFtLFxuICBNZXJnZVByb3BzLFxuICBTZWxlY3RvcixcbiAgU2VsZWN0b3JGYWN0b3J5LFxufSBmcm9tICcuL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5J1xuXG5leHBvcnQgeyBjcmVhdGVEaXNwYXRjaEhvb2ssIHVzZURpc3BhdGNoIH0gZnJvbSAnLi9ob29rcy91c2VEaXNwYXRjaCdcbmV4cG9ydCB0eXBlIHsgVXNlRGlzcGF0Y2ggfSBmcm9tICcuL2hvb2tzL3VzZURpc3BhdGNoJ1xuXG5leHBvcnQgeyBjcmVhdGVTZWxlY3Rvckhvb2ssIHVzZVNlbGVjdG9yIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3RvcidcbmV4cG9ydCB0eXBlIHsgVXNlU2VsZWN0b3IgfSBmcm9tICcuL2hvb2tzL3VzZVNlbGVjdG9yJ1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZUhvb2ssIHVzZVN0b3JlIH0gZnJvbSAnLi9ob29rcy91c2VTdG9yZSdcbmV4cG9ydCB0eXBlIHsgVXNlU3RvcmUgfSBmcm9tICcuL2hvb2tzL3VzZVN0b3JlJ1xuXG5leHBvcnQgdHlwZSB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdXRpbHMvU3Vic2NyaXB0aW9uJ1xuXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIEFzIG9mIFJlYWN0IDE4LCBiYXRjaGluZyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIFJlYWN0RE9NIGFuZCBSZWFjdCBOYXRpdmUuXG4gKiBUaGlzIGlzIG5vdyBhIG5vLW9wIHRoYXQgaW1tZWRpYXRlbHkgcnVucyB0aGUgY2FsbGJhY2suXG4gKi9cbmNvbnN0IGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaFxuXG5leHBvcnQgeyBQcm92aWRlciwgYmF0Y2gsIGNvbm5lY3QsIHNoYWxsb3dFcXVhbCB9XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4yLjAnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogbnVsbFxufTtcblxudmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0ge1xuICBjdXJyZW50OiBudWxsLFxuICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLlxuICBpc0JhdGNoaW5nTGVnYWN5OiBmYWxzZSxcbiAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6IGZhbHNlXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnZnVuY3Rpb24nICYmIHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpO1xuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbmFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIik7XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICB7XG4gICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKGlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgYGlmYCBzdGF0ZW1lbnQgaGVyZSBwcmV2ZW50cyBhdXRvLWRpc2FibGluZyBvZiB0aGUgc2FmZVxuICAgICAgICAgIC8vIGNvZXJjaW9uIEVTTGludCBydWxlLCBzbyB3ZSBtdXN0IG1hbnVhbGx5IGRpc2FibGUgaXQgYmVsb3cuXG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgaWYgKG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1hcHBlZENoaWxkLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gIC8vIFRPRE86IFNlY29uZCBhcmd1bWVudCB1c2VkIHRvIGJlIGFuIG9wdGlvbmFsIGBjYWxjdWxhdGVDaGFuZ2VkQml0c2BcbiAgLy8gZnVuY3Rpb24uIFdhcm4gdG8gcmVzZXJ2ZSBmb3IgZnV0dXJlIHVzZT9cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsLFxuICAgIC8vIEFkZCB0aGVzZSB0byB1c2Ugc2FtZSBoaWRkZW4gY2xhc3MgaW4gVk0gYXMgU2VydmVyQ29udGV4dFxuICAgIF9kZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgX2dsb2JhbE5hbWU6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAvLyBUaGlzIG1pZ2h0IHRocm93IGVpdGhlciBiZWNhdXNlIGl0J3MgbWlzc2luZyBvciB0aHJvd3MuIElmIHNvLCB3ZSB0cmVhdCBpdFxuICAgIC8vIGFzIHN0aWxsIHVuaW5pdGlhbGl6ZWQgYW5kIHRyeSBhZ2FpbiBuZXh0IHRpbWUuIFdoaWNoIGlzIHRoZSBzYW1lIGFzIHdoYXRcbiAgICAvLyBoYXBwZW5zIGlmIHRoZSBjdG9yIG9yIGFueSB3cmFwcGVycyBwcm9jZXNzaW5nIHRoZSBjdG9yIHRocm93cy4gVGhpcyBtaWdodFxuICAgIC8vIGVuZCB1cCBmaXhpbmcgaXQgaWYgdGhlIHJlc29sdXRpb24gd2FzIGEgY29uY3VycmVuY3kgYnVnLlxuXG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3Q7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEluIGNhc2UsIHdlJ3JlIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIHRoZW4gd2UncmUgd2FpdGluZyBmb3IgdGhlIHRoZW5hYmxlXG4gICAgICAvLyB0byByZXNvbHZlLiBTZXQgaXQgYXMgcGVuZGluZyBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICB2YXIgbW9kdWxlT2JqZWN0ID0gcGF5bG9hZC5fcmVzdWx0O1xuXG4gICAge1xuICAgICAgaWYgKG1vZHVsZU9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5cIiArICdEaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0PycsIG1vZHVsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKCEoJ2RlZmF1bHQnIGluIG1vZHVsZU9iamVjdCkpIHtcbiAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiBVbmluaXRpYWxpemVkLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHsuLi59KTtcbiAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICBpZiAoIXJlbmRlci5uYW1lICYmICFyZW5kZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFJlYWN0Lm1lbW8oKHByb3BzKSA9PiB7Li4ufSk7XG4gICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgaWYgKCF0eXBlLm5hbWUgJiYgIXR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAge1xuICAgIGlmIChkaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuICAgIH1cbiAgfSAvLyBXaWxsIHJlc3VsdCBpbiBhIG51bGwgYWNjZXNzIGVycm9yIGlmIGFjY2Vzc2VkIG91dHNpZGUgcmVuZGVyIHBoYXNlLiBXZVxuICAvLyBpbnRlbnRpb25hbGx5IGRvbid0IHRocm93IG91ciBvd24gZXJyb3IgYmVjYXVzZSB0aGlzIGlzIGluIGEgaG90IHBhdGguXG4gIC8vIEFsc28gaGVscHMgZW5zdXJlIHRoaXMgaXMgaW5saW5lZC5cblxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVRyYW5zaXRpb24oKTtcbn1cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG59XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNjb3BlLCBvcHRpb25zKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSB7fTtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2NvcGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gZmFsc2U7XG52YXIgZW5xdWV1ZVRhc2tJbXBsID0gbnVsbDtcbmZ1bmN0aW9uIGVucXVldWVUYXNrKHRhc2spIHtcbiAgaWYgKGVucXVldWVUYXNrSW1wbCA9PT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICAvLyByZWFkIHJlcXVpcmUgb2ZmIHRoZSBtb2R1bGUgb2JqZWN0IHRvIGdldCBhcm91bmQgdGhlIGJ1bmRsZXJzLlxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGRldGVjdCBhIHJlcXVpcmUgYW5kIGJ1bmRsZSBhIE5vZGUgcG9seWZpbGwuXG4gICAgICB2YXIgcmVxdWlyZVN0cmluZyA9ICgncmVxdWlyZScgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcbiAgICAgIHZhciBub2RlUmVxdWlyZSA9IG1vZHVsZSAmJiBtb2R1bGVbcmVxdWlyZVN0cmluZ107IC8vIGFzc3VtaW5nIHdlJ3JlIGluIG5vZGUsIGxldCdzIHRyeSB0byBnZXQgbm9kZSdzXG4gICAgICAvLyB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZSwgYnlwYXNzaW5nIGZha2UgdGltZXJzIGlmIGFueS5cblxuICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG4gICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgLy8gd2UncmUgaW4gYSBicm93c2VyXG4gICAgICAvLyB3ZSBjYW4ndCB1c2UgcmVndWxhciB0aW1lcnMgYmVjYXVzZSB0aGV5IG1heSBzdGlsbCBiZSBmYWtlZFxuICAgICAgLy8gc28gd2UgdHJ5IE1lc3NhZ2VDaGFubmVsK3Bvc3RNZXNzYWdlIGluc3RlYWRcbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBlcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgJyArICdzbyBlbnF1ZXVpbmcgdGFza3MgdmlhIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pIHdpbGwgZmFpbC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzICcgKyAnaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh1bmRlZmluZWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5xdWV1ZVRhc2tJbXBsKHRhc2spO1xufVxuXG52YXIgYWN0U2NvcGVEZXB0aCA9IDA7XG52YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdChjYWxsYmFjaykge1xuICB7XG4gICAgLy8gYGFjdGAgY2FsbHMgY2FuIGJlIG5lc3RlZCwgc28gd2UgdHJhY2sgdGhlIGRlcHRoLiBUaGlzIHJlcHJlc2VudHMgdGhlXG4gICAgLy8gbnVtYmVyIG9mIGBhY3RgIHNjb3BlcyBvbiB0aGUgc3RhY2suXG4gICAgdmFyIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICBhY3RTY29wZURlcHRoKys7XG5cbiAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGBhY3RgIHNjb3BlLiBJbml0aWFsaXplIHRoZSBxdWV1ZS4gVGhlIHJlY29uY2lsZXJcbiAgICAgIC8vIHdpbGwgZGV0ZWN0IHRoZSBxdWV1ZSBhbmQgdXNlIGl0IGluc3RlYWQgb2YgU2NoZWR1bGVyLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgIH1cblxuICAgIHZhciBwcmV2SXNCYXRjaGluZ0xlZ2FjeSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3k7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLiBPbmx5XG4gICAgICAvLyBzZXQgdG8gYHRydWVgIHdoaWxlIHRoZSBnaXZlbiBjYWxsYmFjayBpcyBleGVjdXRlZCwgbm90IGZvciB1cGRhdGVzXG4gICAgICAvLyB0cmlnZ2VyZWQgZHVyaW5nIGFuIGFzeW5jIGV2ZW50LCBiZWNhdXNlIHRoaXMgaXMgaG93IHRoZSBsZWdhY3lcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBhY3RgIGJlaGF2ZWQuXG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7IC8vIFJlcGxpY2F0ZSBiZWhhdmlvciBvZiBvcmlnaW5hbCBgYWN0YCBpbXBsZW1lbnRhdGlvbiBpbiBsZWdhY3kgbW9kZSxcbiAgICAgIC8vIHdoaWNoIGZsdXNoZWQgdXBkYXRlcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgc2NvcGUgZnVuY3Rpb24gZXhpdHMsIGV2ZW5cbiAgICAgIC8vIGlmIGl0J3MgYW4gYXN5bmMgZnVuY3Rpb24uXG5cbiAgICAgIGlmICghcHJldklzQmF0Y2hpbmdMZWdhY3kgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcblxuICAgICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0aGVuYWJsZVJlc3VsdCA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIGFuIGFzeW5jIGZ1bmN0aW9uIChpLmUuIHJldHVybmVkIGEgcHJvbWlzZSkuIFdhaXRcbiAgICAgIC8vIGZvciBpdCB0byByZXNvbHZlIGJlZm9yZSBleGl0aW5nIHRoZSBjdXJyZW50IHNjb3BlLlxuXG4gICAgICB2YXIgd2FzQXdhaXRlZCA9IGZhbHNlO1xuICAgICAgdmFyIHRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgd2FzQXdhaXRlZCA9IHRydWU7XG4gICAgICAgICAgdGhlbmFibGVSZXN1bHQudGhlbihmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcblxuICAgICAgICAgICAgaWYgKGFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gV2UndmUgZXhpdGVkIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBSZWN1cnNpdmVseSBmbHVzaCB0aGVcbiAgICAgICAgICAgICAgLy8gcXVldWUgdW50aWwgdGhlcmUncyBubyByZW1haW5pbmcgd29yay5cbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLlxuICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAge1xuICAgICAgICBpZiAoIWRpZFdhcm5Ob0F3YWl0QWN0ICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge30pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF3YXNBd2FpdGVkKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBlcnJvcignWW91IGNhbGxlZCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aXRob3V0IGF3YWl0LiAnICsgJ1RoaXMgY291bGQgbGVhZCB0byB1bmV4cGVjdGVkIHRlc3RpbmcgYmVoYXZpb3VyLCAnICsgJ2ludGVybGVhdmluZyBtdWx0aXBsZSBhY3QgY2FsbHMgYW5kIG1peGluZyB0aGVpciAnICsgJ3Njb3Blcy4gJyArICdZb3Ugc2hvdWxkIC0gYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLik7Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBub3QgYW4gYXN5bmMgZnVuY3Rpb24uIEV4aXQgdGhlIGN1cnJlbnQgc2NvcGVcbiAgICAgIC8vIGltbWVkaWF0ZWx5LCB3aXRob3V0IGF3YWl0aW5nLlxuXG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgIC8vIEV4aXRpbmcgdGhlIG91dGVybW9zdCBhY3Qgc2NvcGUuIEZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgdmFyIF9xdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKF9xdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZsdXNoQWN0UXVldWUoX3F1ZXVlKTtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSAvLyBSZXR1cm4gYSB0aGVuYWJsZS4gSWYgdGhlIHVzZXIgYXdhaXRzIGl0LCB3ZSdsbCBmbHVzaCBhZ2FpbiBpblxuICAgICAgICAvLyBjYXNlIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuXG5cbiAgICAgICAgdmFyIF90aGVuYWJsZSA9IHtcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBDb25maXJtIHdlIGhhdmVuJ3QgcmUtZW50ZXJlZCBhbm90aGVyIGBhY3RgIHNjb3BlLCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB0aGUgdXNlciBkb2VzIHNvbWV0aGluZyB3ZWlyZCBsaWtlIGF3YWl0IHRoZSB0aGVuYWJsZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbHVzaCB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBubyByZW1haW5pbmcgd29yay5cbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgICByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoZW5hYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmVzdGVkIGBhY3RgIHNjb3BlLCB0aGUgcmV0dXJuZWQgdGhlbmFibGVcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgcmVzb2x2ZXMuIFRoZSBvdXRlciBzY29wZSB3aWxsIGZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgdmFyIF90aGVuYWJsZTIgPSB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoZW5hYmxlMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpIHtcbiAge1xuICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEpIHtcbiAgICAgIGVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIG92ZXJsYXBwaW5nIGFjdCgpIGNhbGxzLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gJyk7XG4gICAgfVxuXG4gICAgYWN0U2NvcGVEZXB0aCA9IHByZXZBY3RTY29wZURlcHRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCkge1xuICB7XG4gICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcblxuICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZC4gRmluaXNoLlxuICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gS2VlcCBmbHVzaGluZyB3b3JrIHVudGlsIHRoZXJlJ3Mgbm9uZSBsZWZ0LlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0ZsdXNoaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQWN0UXVldWUocXVldWUpIHtcbiAge1xuICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgLy8gUHJldmVudCByZS1lbnRyYW5jZS5cbiAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIH0gd2hpbGUgKGNhbGxiYWNrICE9PSBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIHF1ZXVlID0gcXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG5leHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBzdGFydFRyYW5zaXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2FjdCA9IGFjdDtcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VEZWZlcnJlZFZhbHVlID0gdXNlRGVmZXJyZWRWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJZCA9IHVzZUlkO1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gdXNlSW5zZXJ0aW9uRWZmZWN0O1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbjtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG4vLyBmb3IgQ29tbW9uSlMgaW50ZXJvcC5cblxudmFyIHVzZVJlZiA9IFJlYWN0LnVzZVJlZixcbiAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8sXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7IC8vIFNhbWUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUsIGJ1dCBzdXBwb3J0cyBzZWxlY3RvciBhbmQgaXNFcXVhbCBhcmd1bWVudHMuXG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICAvLyBVc2UgdGhpcyB0byB0cmFjayB0aGUgcmVuZGVyZWQgc25hcHNob3QuXG4gIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgaW5zdDtcblxuICBpZiAoaW5zdFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgaW5zdCA9IHtcbiAgICAgIGhhc1ZhbHVlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfTtcbiAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICB9IGVsc2Uge1xuICAgIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gIH1cblxuICB2YXIgX3VzZU1lbW8gPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUcmFjayB0aGUgbWVtb2l6ZWQgc3RhdGUgdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMgdGhhdCBhcmUgbG9jYWwgdG8gdGhpc1xuICAgIC8vIG1lbW9pemVkIGluc3RhbmNlIG9mIGEgZ2V0U25hcHNob3QgZnVuY3Rpb24uIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGFcbiAgICAvLyB1c2VSZWYgaG9vaywgYmVjYXVzZSB0aGF0IHN0YXRlIHdvdWxkIGJlIHNoYXJlZCBhY3Jvc3MgYWxsIGNvbmN1cnJlbnRcbiAgICAvLyBjb3BpZXMgb2YgdGhlIGhvb2svY29tcG9uZW50LlxuICAgIHZhciBoYXNNZW1vID0gZmFsc2U7XG4gICAgdmFyIG1lbW9pemVkU25hcHNob3Q7XG4gICAgdmFyIG1lbW9pemVkU2VsZWN0aW9uO1xuXG4gICAgdmFyIG1lbW9pemVkU2VsZWN0b3IgPSBmdW5jdGlvbiAobmV4dFNuYXBzaG90KSB7XG4gICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgdGhlIGhvb2sgaXMgY2FsbGVkLCB0aGVyZSBpcyBubyBtZW1vaXplZCByZXN1bHQuXG4gICAgICAgIGhhc01lbW8gPSB0cnVlO1xuICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuXG4gICAgICAgIHZhciBfbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG5cbiAgICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHNlbGVjdG9yIGhhcyBjaGFuZ2VkLCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIHNlbGVjdGlvblxuICAgICAgICAgIC8vIG1heSBiZSBlcXVhbCB0byB0aGUgbmV3IHNlbGVjdGlvbi4gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmV1c2UgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCB2YWx1ZSBpZiBwb3NzaWJsZSwgdG8gcHJlc2VydmUgZG93bnN0cmVhbSBtZW1vaXphdGlvbnMuXG4gICAgICAgICAgaWYgKGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgX25leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBfbmV4dFNlbGVjdGlvbjtcbiAgICAgICAgcmV0dXJuIF9uZXh0U2VsZWN0aW9uO1xuICAgICAgfSAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cblxuXG4gICAgICAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cbiAgICAgIHZhciBwcmV2U25hcHNob3QgPSBtZW1vaXplZFNuYXBzaG90O1xuICAgICAgdmFyIHByZXZTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgICAgaWYgKG9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSkge1xuICAgICAgICAvLyBUaGUgc25hcHNob3QgaXMgdGhlIHNhbWUgYXMgbGFzdCB0aW1lLiBSZXVzZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH0gLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuXG5cbiAgICAgIC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cbiAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTsgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuXG4gICAgICAvLyBJZiBhIGN1c3RvbSBpc0VxdWFsIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byBjaGVjayBpZiB0aGUgZGF0YVxuICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcbiAgICAgIC8vIG91dCBvZiByZW5kZXJpbmcuXG4gICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkICYmIGlzRXF1YWwocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG4gICAgICByZXR1cm4gbmV4dFNlbGVjdGlvbjtcbiAgICB9OyAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG5cblxuICAgIC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cbiAgICB2YXIgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQgPyBudWxsIDogZ2V0U2VydmVyU25hcHNob3Q7XG5cbiAgICB2YXIgZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yID0gbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gW2dldFNuYXBzaG90V2l0aFNlbGVjdG9yLCBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3Rvcl07XG4gIH0sIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXSksXG4gICAgICBnZXRTZWxlY3Rpb24gPSBfdXNlTWVtb1swXSxcbiAgICAgIGdldFNlcnZlclNlbGVjdGlvbiA9IF91c2VNZW1vWzFdO1xuXG4gIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb24pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGluc3QuaGFzVmFsdWUgPSB0cnVlO1xuICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2xvY2FsU3RvcmFnZSA9IHJlcXVpcmUoJy4vbG9jYWxTdG9yYWdlJyk7XG5cbnZhciBfbG9jYWxTdG9yYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvY2FsU3RvcmFnZSk7XG5cbnZhciBfc3luY1N0b3JhZ2UgPSByZXF1aXJlKCcuL3N5bmNTdG9yYWdlJyk7XG5cbnZhciBfc3luY1N0b3JhZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3luY1N0b3JhZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbG9jYWxTdG9yYWdlOiBfbG9jYWxTdG9yYWdlMi5kZWZhdWx0LCBzeW5jU3RvcmFnZTogX3N5bmNTdG9yYWdlMi5kZWZhdWx0IH07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JhZ2UnKTtcblxudmFyIF9jcmVhdGVTdG9yYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JhZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVN0b3JhZ2UyLmRlZmF1bHQpKCdsb2NhbCcpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVN0b3JhZ2U7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JhZ2UodHlwZSkge1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IGZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZVt0eXBlXS5nZXQoa2V5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBTdG9yYWdlIHJldHVybnMgdGhlIHZhbHVlIGluIGFuIE9iamVjdCBvZiB3aXRoIGl0cyBvcmlnaW5hbCBrZXkuIFVud3JhcCB0aGVcbiAgICAgICAgICAgIC8vIHZhbHVlIGZyb20gdGhlIHJldHVybmVkIE9iamVjdCB0byBtYXRjaCB0aGUgYGdldEl0ZW1gIEFQSS5cbiAgICAgICAgICAgIHJlc29sdmUodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjaHJvbWUuc3RvcmFnZVt0eXBlXS5yZW1vdmUoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldEl0ZW06IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2VbdHlwZV0uc2V0KF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JhZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3RvcmFnZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlU3RvcmFnZTIuZGVmYXVsdCkoJ3N5bmMnKTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIHBlcnNpc3RSZWR1Y2VyIH0gZnJvbSAnLi9wZXJzaXN0UmVkdWNlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBlcnNpc3RDb21iaW5lUmVkdWNlcnMgfSBmcm9tICcuL3BlcnNpc3RDb21iaW5lUmVkdWNlcnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwZXJzaXN0U3RvcmUgfSBmcm9tICcuL3BlcnNpc3RTdG9yZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZU1pZ3JhdGUgfSBmcm9tICcuL2NyZWF0ZU1pZ3JhdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjcmVhdGVUcmFuc2Zvcm0gfSBmcm9tICcuL2NyZWF0ZVRyYW5zZm9ybSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldFN0b3JlZFN0YXRlIH0gZnJvbSAnLi9nZXRTdG9yZWRTdGF0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZVBlcnNpc3RvaWQgfSBmcm9tICcuL2NyZWF0ZVBlcnNpc3RvaWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwdXJnZVN0b3JlZFN0YXRlIH0gZnJvbSAnLi9wdXJnZVN0b3JlZFN0YXRlJztcbmV4cG9ydCAqIGZyb20gJy4vY29uc3RhbnRzJztcbiIsInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IEZMVVNILCBQQVVTRSwgUEVSU0lTVCwgUFVSR0UsIFJFSFlEUkFURSwgREVGQVVMVF9WRVJTSU9OLCBSRVNZTkMsIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGF1dG9NZXJnZUxldmVsMSBmcm9tICcuL3N0YXRlUmVjb25jaWxlci9hdXRvTWVyZ2VMZXZlbDEnO1xuaW1wb3J0IGNyZWF0ZVBlcnNpc3RvaWQgZnJvbSAnLi9jcmVhdGVQZXJzaXN0b2lkJztcbmltcG9ydCBkZWZhdWx0R2V0U3RvcmVkU3RhdGUgZnJvbSAnLi9nZXRTdG9yZWRTdGF0ZSc7XG5pbXBvcnQgcHVyZ2VTdG9yZWRTdGF0ZSBmcm9tICcuL3B1cmdlU3RvcmVkU3RhdGUnO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gNTAwMDtcbi8qXG4gIEBUT0RPIGFkZCB2YWxpZGF0aW9uIC8gaGFuZGxpbmcgZm9yOlxuICAtIHBlcnNpc3RpbmcgYSByZWR1Y2VyIHdoaWNoIGhhcyBuZXN0ZWQgX3BlcnNpc3RcbiAgLSBoYW5kbGluZyBhY3Rpb25zIHRoYXQgZmlyZSBiZWZvcmUgcmV5ZHJhdGUgaXMgY2FsbGVkXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVyc2lzdFJlZHVjZXIoY29uZmlnLCBiYXNlUmVkdWNlcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghY29uZmlnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcgaXMgcmVxdWlyZWQgZm9yIHBlcnNpc3RSZWR1Y2VyJyk7XG4gICAgICAgIGlmICghY29uZmlnLmtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5IGlzIHJlcXVpcmVkIGluIHBlcnNpc3RvciBjb25maWcnKTtcbiAgICAgICAgaWYgKCFjb25maWcuc3RvcmFnZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZHV4LXBlcnNpc3Q6IGNvbmZpZy5zdG9yYWdlIGlzIHJlcXVpcmVkLiBUcnkgdXNpbmcgb25lIG9mIHRoZSBwcm92aWRlZCBzdG9yYWdlIGVuZ2luZXMgYGltcG9ydCBzdG9yYWdlIGZyb20gJ3JlZHV4LXBlcnNpc3QvbGliL3N0b3JhZ2UnYFwiKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcudmVyc2lvbiA6IERFRkFVTFRfVkVSU0lPTjtcbiAgICBjb25zdCBzdGF0ZVJlY29uY2lsZXIgPSBjb25maWcuc3RhdGVSZWNvbmNpbGVyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBhdXRvTWVyZ2VMZXZlbDFcbiAgICAgICAgOiBjb25maWcuc3RhdGVSZWNvbmNpbGVyO1xuICAgIGNvbnN0IGdldFN0b3JlZFN0YXRlID0gY29uZmlnLmdldFN0b3JlZFN0YXRlIHx8IGRlZmF1bHRHZXRTdG9yZWRTdGF0ZTtcbiAgICBjb25zdCB0aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy50aW1lb3V0IDogREVGQVVMVF9USU1FT1VUO1xuICAgIGxldCBfcGVyc2lzdG9pZCA9IG51bGw7XG4gICAgbGV0IF9wdXJnZSA9IGZhbHNlO1xuICAgIGxldCBfcGF1c2VkID0gdHJ1ZTtcbiAgICBjb25zdCBjb25kaXRpb25hbFVwZGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHBlcnNpc3RvaWQgb25seSBpZiB3ZSBhcmUgcmVoeWRyYXRlZCBhbmQgbm90IHBhdXNlZFxuICAgICAgICBzdGF0ZS5fcGVyc2lzdC5yZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICBfcGVyc2lzdG9pZCAmJlxuICAgICAgICAgICAgIV9wYXVzZWQgJiZcbiAgICAgICAgICAgIF9wZXJzaXN0b2lkLnVwZGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBfYSA9IHN0YXRlIHx8IHt9LCB7IF9wZXJzaXN0IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiX3BlcnNpc3RcIl0pO1xuICAgICAgICBjb25zdCByZXN0U3RhdGUgPSByZXN0O1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFBFUlNJU1QpIHtcbiAgICAgICAgICAgIGxldCBfc2VhbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBfcmVoeWRyYXRlID0gKHBheWxvYWQsIGVycikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRldiB3YXJuaW5nIGlmIHdlIGFyZSBhbHJlYWR5IHNlYWxlZFxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF9zZWFsZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHJlZHV4LXBlcnNpc3Q6IHJlaHlkcmF0ZSBmb3IgXCIke2NvbmZpZy5rZXl9XCIgY2FsbGVkIGFmdGVyIHRpbWVvdXQuYCwgcGF5bG9hZCwgZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHJlaHlkcmF0ZSBpZiB3ZSBhcmUgbm90IGFscmVhZHkgc2VhbGVkXG4gICAgICAgICAgICAgICAgaWYgKCFfc2VhbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5yZWh5ZHJhdGUoY29uZmlnLmtleSwgcGF5bG9hZCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgX3NlYWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRpbWVvdXQgJiZcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgIV9zZWFsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWh5ZHJhdGUodW5kZWZpbmVkLCBuZXcgRXJyb3IoYHJlZHV4LXBlcnNpc3Q6IHBlcnNpc3QgdGltZWQgb3V0IGZvciBwZXJzaXN0IGtleSBcIiR7Y29uZmlnLmtleX1cImApKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIC8vIEBOT1RFIFBFUlNJU1QgcmVzdW1lcyBpZiBwYXVzZWQuXG4gICAgICAgICAgICBfcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBATk9URSBvbmx5IGV2ZXIgY3JlYXRlIHBlcnNpc3RvaWQgb25jZSwgZW5zdXJlIHdlIGNhbGwgaXQgYXQgbGVhc3Qgb25jZSwgZXZlbiBpZiBfcGVyc2lzdCBoYXMgYWxyZWFkeSBiZWVuIHNldFxuICAgICAgICAgICAgaWYgKCFfcGVyc2lzdG9pZClcbiAgICAgICAgICAgICAgICBfcGVyc2lzdG9pZCA9IGNyZWF0ZVBlcnNpc3RvaWQoY29uZmlnKTtcbiAgICAgICAgICAgIC8vIEBOT1RFIFBFUlNJU1QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgbm9vcCBhZnRlciB0aGUgZmlyc3RcbiAgICAgICAgICAgIGlmIChfcGVyc2lzdCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gY2FsbCB0aGUgYmFzZSByZWR1Y2VyIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gdXNlcyBvZiBwZXJzaXN0UmVkdWNlciB3aGljaCBuZWVkIHRvIGJlIGF3YXJlIG9mIHRoZSBQRVJTSVNUIGFjdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VSZWR1Y2VyKHJlc3RTdGF0ZSwgYWN0aW9uKSksIHsgX3BlcnNpc3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbi5yZWh5ZHJhdGUgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgYWN0aW9uLnJlZ2lzdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVkdXgtcGVyc2lzdDogZWl0aGVyIHJlaHlkcmF0ZSBvciByZWdpc3RlciBpcyBub3QgYSBmdW5jdGlvbiBvbiB0aGUgUEVSU0lTVCBhY3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgYWN0aW9uIGlzIGJlaW5nIHJlcGxheWVkLiBUaGlzIGlzIGFuIHVuZXhwbG9yZWQgdXNlIGNhc2UsIHBsZWFzZSBvcGVuIGFuIGlzc3VlIGFuZCB3ZSB3aWxsIGZpZ3VyZSBvdXQgYSByZXNvbHV0aW9uLicpO1xuICAgICAgICAgICAgYWN0aW9uLnJlZ2lzdGVyKGNvbmZpZy5rZXkpO1xuICAgICAgICAgICAgZ2V0U3RvcmVkU3RhdGUoY29uZmlnKS50aGVuKHJlc3RvcmVkU3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0b3JlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlncmF0ZSA9IGNvbmZpZy5taWdyYXRlIHx8ICgocywgXykgPT4gUHJvbWlzZS5yZXNvbHZlKHMpKTtcbiAgICAgICAgICAgICAgICAgICAgbWlncmF0ZShyZXN0b3JlZFN0YXRlLCB2ZXJzaW9uKS50aGVuKG1pZ3JhdGVkU3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlaHlkcmF0ZShtaWdyYXRlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbWlncmF0ZUVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtaWdyYXRlRXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlZHV4LXBlcnNpc3Q6IG1pZ3JhdGlvbiBlcnJvcicsIG1pZ3JhdGVFcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlaHlkcmF0ZSh1bmRlZmluZWQsIG1pZ3JhdGVFcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIF9yZWh5ZHJhdGUodW5kZWZpbmVkLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlUmVkdWNlcihyZXN0U3RhdGUsIGFjdGlvbikpLCB7IF9wZXJzaXN0OiB7IHZlcnNpb24sIHJlaHlkcmF0ZWQ6IGZhbHNlIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09IFBVUkdFKSB7XG4gICAgICAgICAgICBfcHVyZ2UgPSB0cnVlO1xuICAgICAgICAgICAgYWN0aW9uLnJlc3VsdChwdXJnZVN0b3JlZFN0YXRlKGNvbmZpZykpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZVJlZHVjZXIocmVzdFN0YXRlLCBhY3Rpb24pKSwgeyBfcGVyc2lzdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gUkVTWU5DKSB7XG4gICAgICAgICAgICBnZXRTdG9yZWRTdGF0ZShjb25maWcpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdG9yZWRTdGF0ZSA9PiBhY3Rpb24ucmVoeWRyYXRlKGNvbmZpZy5rZXksIHJlc3RvcmVkU3RhdGUsIHVuZGVmaW5lZCksIGVyciA9PiBhY3Rpb24ucmVoeWRyYXRlKGNvbmZpZy5rZXksIHVuZGVmaW5lZCwgZXJyKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBhY3Rpb24ucmVzdWx0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZVJlZHVjZXIocmVzdFN0YXRlLCBhY3Rpb24pKSwgeyBfcGVyc2lzdDogeyB2ZXJzaW9uLCByZWh5ZHJhdGVkOiBmYWxzZSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSBGTFVTSCkge1xuICAgICAgICAgICAgYWN0aW9uLnJlc3VsdChfcGVyc2lzdG9pZCAmJiBfcGVyc2lzdG9pZC5mbHVzaCgpKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VSZWR1Y2VyKHJlc3RTdGF0ZSwgYWN0aW9uKSksIHsgX3BlcnNpc3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09IFBBVVNFKSB7XG4gICAgICAgICAgICBfcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gUkVIWURSQVRFKSB7XG4gICAgICAgICAgICAvLyBub29wIG9uIHJlc3RTdGF0ZSBpZiBwdXJnaW5nXG4gICAgICAgICAgICBpZiAoX3B1cmdlKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RTdGF0ZSksIHsgX3BlcnNpc3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3BlcnNpc3QpLCB7IHJlaHlkcmF0ZWQ6IHRydWUgfSkgfSk7XG4gICAgICAgICAgICAvLyBATk9URSBpZiBrZXkgZG9lcyBub3QgbWF0Y2gsIHdpbGwgY29udGludWUgdG8gZGVmYXVsdCBlbHNlIGJlbG93XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmtleSA9PT0gY29uZmlnLmtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZHVjZWRTdGF0ZSA9IGJhc2VSZWR1Y2VyKHJlc3RTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmJvdW5kU3RhdGUgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHJlY29uY2lsZSBzdGF0ZSBpZiBzdGF0ZVJlY29uY2lsZXIgYW5kIGluYm91bmRTdGF0ZSBhcmUgYm90aCBkZWZpbmVkXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb25jaWxlZFJlc3QgPSBzdGF0ZVJlY29uY2lsZXIgIT09IGZhbHNlICYmIGluYm91bmRTdGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdGVSZWNvbmNpbGVyKGluYm91bmRTdGF0ZSwgc3RhdGUsIHJlZHVjZWRTdGF0ZSwgY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICA6IHJlZHVjZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVjb25jaWxlZFJlc3QpLCB7IF9wZXJzaXN0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9wZXJzaXN0KSwgeyByZWh5ZHJhdGVkOiB0cnVlIH0pIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25hbFVwZGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgYWxyZWFkeSBoYW5kbGVkIFBFUlNJU1QsIHN0cmFpZ2h0IHBhc3N0aHJvdWdoXG4gICAgICAgIGlmICghX3BlcnNpc3QpXG4gICAgICAgICAgICByZXR1cm4gYmFzZVJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgIC8vIHJ1biBiYXNlIHJlZHVjZXI6XG4gICAgICAgIC8vIGlzIHN0YXRlIG1vZGlmaWVkID8gcmV0dXJuIG9yaWdpbmFsIDogcmV0dXJuIHVwZGF0ZWRcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBiYXNlUmVkdWNlcihyZXN0U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gcmVzdFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uYWxVcGRhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdTdGF0ZSksIHsgX3BlcnNpc3QgfSkpO1xuICAgIH07XG59XG4iLCJleHBvcnQgY29uc3QgS0VZX1BSRUZJWCA9ICdwZXJzaXN0Oic7XG5leHBvcnQgY29uc3QgRkxVU0ggPSAncGVyc2lzdC9GTFVTSCc7XG5leHBvcnQgY29uc3QgUkVIWURSQVRFID0gJ3BlcnNpc3QvUkVIWURSQVRFJztcbmV4cG9ydCBjb25zdCBSRVNZTkMgPSAncGVyc2lzdC9SRVNZTkMnO1xuZXhwb3J0IGNvbnN0IFBBVVNFID0gJ3BlcnNpc3QvUEFVU0UnO1xuZXhwb3J0IGNvbnN0IFBFUlNJU1QgPSAncGVyc2lzdC9QRVJTSVNUJztcbmV4cG9ydCBjb25zdCBQVVJHRSA9ICdwZXJzaXN0L1BVUkdFJztcbmV4cG9ydCBjb25zdCBSRUdJU1RFUiA9ICdwZXJzaXN0L1JFR0lTVEVSJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZFUlNJT04gPSAtMTtcbiIsIi8qXG4gIGF1dG9NZXJnZUxldmVsMTpcbiAgICAtIG1lcmdlcyAxIGxldmVsIG9mIHN1YnN0YXRlXG4gICAgLSBza2lwcyBzdWJzdGF0ZSBpZiBhbHJlYWR5IG1vZGlmaWVkXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b01lcmdlTGV2ZWwxKGluYm91bmRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSwgcmVkdWNlZFN0YXRlLCB7IGRlYnVnIH0pIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHJlZHVjZWRTdGF0ZSk7XG4gICAgLy8gb25seSByZWh5ZHJhdGUgaWYgaW5ib3VuZFN0YXRlIGV4aXN0cyBhbmQgaXMgYW4gb2JqZWN0XG4gICAgaWYgKGluYm91bmRTdGF0ZSAmJiB0eXBlb2YgaW5ib3VuZFN0YXRlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5ib3VuZFN0YXRlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgX3BlcnNpc3QgZGF0YVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19wZXJzaXN0JylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBpZiByZWR1Y2VyIG1vZGlmaWVzIHN1YnN0YXRlLCBza2lwIGF1dG8gcmVoeWRyYXRpb25cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXRlW2tleV0gIT09IHJlZHVjZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWR1eC1wZXJzaXN0L3N0YXRlUmVjb25jaWxlcjogc3ViIHN0YXRlIGZvciBrZXkgYCVzYCBtb2RpZmllZCwgc2tpcHBpbmcuJywga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaGFyZCBzZXQgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGluYm91bmRTdGF0ZVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgZGVidWcgJiZcbiAgICAgICAgaW5ib3VuZFN0YXRlICYmXG4gICAgICAgIHR5cGVvZiBpbmJvdW5kU3RhdGUgPT09ICdvYmplY3QnKVxuICAgICAgICBjb25zb2xlLmxvZyhgcmVkdXgtcGVyc2lzdC9zdGF0ZVJlY29uY2lsZXI6IHJlaHlkcmF0ZWQga2V5cyAnJHtPYmplY3Qua2V5cyhpbmJvdW5kU3RhdGUpLmpvaW4oJywgJyl9J2ApO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IEtFWV9QUkVGSVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVQZXJzaXN0b2lkKGNvbmZpZykge1xuICAgIC8vIGRlZmF1bHRzXG4gICAgY29uc3QgYmxhY2tsaXN0ID0gY29uZmlnLmJsYWNrbGlzdCB8fCBudWxsO1xuICAgIGNvbnN0IHdoaXRlbGlzdCA9IGNvbmZpZy53aGl0ZWxpc3QgfHwgbnVsbDtcbiAgICBjb25zdCB0cmFuc2Zvcm1zID0gY29uZmlnLnRyYW5zZm9ybXMgfHwgW107XG4gICAgY29uc3QgdGhyb3R0bGUgPSBjb25maWcudGhyb3R0bGUgfHwgMDtcbiAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7Y29uZmlnLmtleVByZWZpeCAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmtleVByZWZpeCA6IEtFWV9QUkVGSVh9JHtjb25maWcua2V5fWA7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGNvbmZpZy5zdG9yYWdlO1xuICAgIGxldCBzZXJpYWxpemU7XG4gICAgaWYgKGNvbmZpZy5zZXJpYWxpemUgPT09IGZhbHNlKSB7XG4gICAgICAgIHNlcmlhbGl6ZSA9ICh4KSA9PiB4O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnLnNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzZXJpYWxpemUgPSBjb25maWcuc2VyaWFsaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplID0gZGVmYXVsdFNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY29uc3Qgd3JpdGVGYWlsSGFuZGxlciA9IGNvbmZpZy53cml0ZUZhaWxIYW5kbGVyIHx8IG51bGw7XG4gICAgLy8gaW5pdGlhbGl6ZSBzdGF0ZWZ1bCB2YWx1ZXNcbiAgICBsZXQgbGFzdFN0YXRlID0ge307XG4gICAgY29uc3Qgc3RhZ2VkU3RhdGUgPSB7fTtcbiAgICBjb25zdCBrZXlzVG9Qcm9jZXNzID0gW107XG4gICAgbGV0IHRpbWVJdGVyYXRvciA9IG51bGw7XG4gICAgbGV0IHdyaXRlUHJvbWlzZSA9IG51bGw7XG4gICAgY29uc3QgdXBkYXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIGFkZCBhbnkgY2hhbmdlZCBrZXlzIHRvIHRoZSBxdWV1ZVxuICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXNzV2hpdGVsaXN0QmxhY2tsaXN0KGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBpcyBrZXlzcGFjZSBpZ25vcmVkPyBub29wXG4gICAgICAgICAgICBpZiAobGFzdFN0YXRlW2tleV0gPT09IHN0YXRlW2tleV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB2YWx1ZSB1bmNoYW5nZWQ/IG5vb3BcbiAgICAgICAgICAgIGlmIChrZXlzVG9Qcm9jZXNzLmluZGV4T2Yoa2V5KSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBpcyBrZXkgYWxyZWFkeSBxdWV1ZWQ/IG5vb3BcbiAgICAgICAgICAgIGtleXNUb1Byb2Nlc3MucHVzaChrZXkpOyAvLyBhZGQga2V5IHRvIHF1ZXVlXG4gICAgICAgIH0pO1xuICAgICAgICAvL2lmIGFueSBrZXkgaXMgbWlzc2luZyBpbiB0aGUgbmV3IHN0YXRlIHdoaWNoIHdhcyBwcmVzZW50IGluIHRoZSBsYXN0U3RhdGUsXG4gICAgICAgIC8vYWRkIGl0IGZvciBwcm9jZXNzaW5nIHRvb1xuICAgICAgICBPYmplY3Qua2V5cyhsYXN0U3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwYXNzV2hpdGVsaXN0QmxhY2tsaXN0KGtleSkgJiZcbiAgICAgICAgICAgICAgICBrZXlzVG9Qcm9jZXNzLmluZGV4T2Yoa2V5KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBsYXN0U3RhdGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5c1RvUHJvY2Vzcy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzdGFydCB0aGUgdGltZSBpdGVyYXRvciBpZiBub3QgcnVubmluZyAocmVhZDogdGhyb3R0bGUpXG4gICAgICAgIGlmICh0aW1lSXRlcmF0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVJdGVyYXRvciA9IHNldEludGVydmFsKHByb2Nlc3NOZXh0S2V5LCB0aHJvdHRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTmV4dEtleSgpIHtcbiAgICAgICAgaWYgKGtleXNUb1Byb2Nlc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGltZUl0ZXJhdG9yKVxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZUl0ZXJhdG9yKTtcbiAgICAgICAgICAgIHRpbWVJdGVyYXRvciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1RvUHJvY2Vzcy5zaGlmdCgpO1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRTdGF0ZSA9IHRyYW5zZm9ybXMucmVkdWNlKChzdWJTdGF0ZSwgdHJhbnNmb3JtZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci5pbihzdWJTdGF0ZSwga2V5LCBsYXN0U3RhdGUpO1xuICAgICAgICB9LCBsYXN0U3RhdGVba2V5XSk7XG4gICAgICAgIGlmIChlbmRTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YWdlZFN0YXRlW2tleV0gPSBzZXJpYWxpemUoZW5kU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlZHV4LXBlcnNpc3QvY3JlYXRlUGVyc2lzdG9pZDogZXJyb3Igc2VyaWFsaXppbmcgc3RhdGUnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9pZiB0aGUgZW5kU3RhdGUgaXMgdW5kZWZpbmVkLCBubyBuZWVkIHRvIHBlcnNpc3QgdGhlIGV4aXN0aW5nIHNlcmlhbGl6ZWQgY29udGVudFxuICAgICAgICAgICAgZGVsZXRlIHN0YWdlZFN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXNUb1Byb2Nlc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB3cml0ZVN0YWdlZFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdGFnZWRTdGF0ZSgpIHtcbiAgICAgICAgLy8gY2xlYW51cCBhbnkgcmVtb3ZlZCBrZXlzIGp1c3QgYmVmb3JlIHdyaXRlLlxuICAgICAgICBPYmplY3Qua2V5cyhzdGFnZWRTdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhZ2VkU3RhdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdyaXRlUHJvbWlzZSA9IHN0b3JhZ2VcbiAgICAgICAgICAgIC5zZXRJdGVtKHN0b3JhZ2VLZXksIHNlcmlhbGl6ZShzdGFnZWRTdGF0ZSkpXG4gICAgICAgICAgICAuY2F0Y2gob25Xcml0ZUZhaWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXNzV2hpdGVsaXN0QmxhY2tsaXN0KGtleSkge1xuICAgICAgICBpZiAod2hpdGVsaXN0ICYmIHdoaXRlbGlzdC5pbmRleE9mKGtleSkgPT09IC0xICYmIGtleSAhPT0gJ19wZXJzaXN0JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uV3JpdGVGYWlsKGVycikge1xuICAgICAgICAvLyBAVE9ETyBhZGQgZmFpbCBoYW5kbGVycyAodHlwaWNhbGx5IHN0b3JhZ2UgZnVsbClcbiAgICAgICAgaWYgKHdyaXRlRmFpbEhhbmRsZXIpXG4gICAgICAgICAgICB3cml0ZUZhaWxIYW5kbGVyKGVycik7XG4gICAgICAgIGlmIChlcnIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RvcmluZyBkYXRhJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgd2hpbGUgKGtleXNUb1Byb2Nlc3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBwcm9jZXNzTmV4dEtleSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZVByb21pc2UgfHwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvLyByZXR1cm4gYHBlcnNpc3RvaWRgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBmbHVzaCxcbiAgICB9O1xufVxuLy8gQE5PVEUgaW4gdGhlIGZ1dHVyZSB0aGlzIG1heSBiZSBleHBvc2VkIHZpYSBjb25maWdcbmZ1bmN0aW9uIGRlZmF1bHRTZXJpYWxpemUoZGF0YSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbiIsImltcG9ydCB7IEtFWV9QUkVGSVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTdG9yZWRTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1zID0gY29uZmlnLnRyYW5zZm9ybXMgfHwgW107XG4gICAgY29uc3Qgc3RvcmFnZUtleSA9IGAke2NvbmZpZy5rZXlQcmVmaXggIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5rZXlQcmVmaXggOiBLRVlfUFJFRklYfSR7Y29uZmlnLmtleX1gO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBjb25maWcuc3RvcmFnZTtcbiAgICBjb25zdCBkZWJ1ZyA9IGNvbmZpZy5kZWJ1ZztcbiAgICBsZXQgZGVzZXJpYWxpemU7XG4gICAgaWYgKGNvbmZpZy5kZXNlcmlhbGl6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVzZXJpYWxpemUgPSAoeCkgPT4geDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5kZXNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlc2VyaWFsaXplID0gZGVmYXVsdERlc2VyaWFsaXplO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpLnRoZW4oKHNlcmlhbGl6ZWQpID0+IHtcbiAgICAgICAgaWYgKCFzZXJpYWxpemVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3U3RhdGUgPSBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYXdTdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gdHJhbnNmb3Jtcy5yZWR1Y2VSaWdodCgoc3ViU3RhdGUsIHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIub3V0KHN1YlN0YXRlLCBrZXksIHJhd1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVzZXJpYWxpemUocmF3U3RhdGVba2V5XSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHJlZHV4LXBlcnNpc3QvZ2V0U3RvcmVkU3RhdGU6IEVycm9yIHJlc3RvcmluZyBkYXRhICR7c2VyaWFsaXplZH1gLCBlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdERlc2VyaWFsaXplKHNlcmlhbCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbCk7XG59XG4iLCJpbXBvcnQgeyBLRVlfUFJFRklYIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHVyZ2VTdG9yZWRTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gY29uZmlnLnN0b3JhZ2U7XG4gICAgY29uc3Qgc3RvcmFnZUtleSA9IGAke2NvbmZpZy5rZXlQcmVmaXggIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5rZXlQcmVmaXggOiBLRVlfUFJFRklYfSR7Y29uZmlnLmtleX1gO1xuICAgIHJldHVybiBzdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSwgd2FybklmUmVtb3ZlRXJyb3IpO1xufVxuZnVuY3Rpb24gd2FybklmUmVtb3ZlRXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlZHV4LXBlcnNpc3QvcHVyZ2VTdG9yZWRTdGF0ZTogRXJyb3IgcHVyZ2luZyBkYXRhIHN0b3JlZCBzdGF0ZScsIGVycik7XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHBlcnNpc3RSZWR1Y2VyIGZyb20gJy4vcGVyc2lzdFJlZHVjZXInO1xuaW1wb3J0IGF1dG9NZXJnZUxldmVsMiBmcm9tICcuL3N0YXRlUmVjb25jaWxlci9hdXRvTWVyZ2VMZXZlbDInO1xuLy8gY29tYmluZVJlZHVjZXJzICsgcGVyc2lzdFJlZHVjZXIgd2l0aCBzdGF0ZVJlY29uY2lsZXIgZGVmYXVsdGVkIHRvIGF1dG9NZXJnZUxldmVsMlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVyc2lzdENvbWJpbmVSZWR1Y2Vycyhjb25maWcsIHJlZHVjZXJzKSB7XG4gICAgY29uZmlnLnN0YXRlUmVjb25jaWxlciA9XG4gICAgICAgIGNvbmZpZy5zdGF0ZVJlY29uY2lsZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhdXRvTWVyZ2VMZXZlbDJcbiAgICAgICAgICAgIDogY29uZmlnLnN0YXRlUmVjb25jaWxlcjtcbiAgICByZXR1cm4gcGVyc2lzdFJlZHVjZXIoY29uZmlnLCBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpKTtcbn1cbiIsIi8qXG4gIGF1dG9NZXJnZUxldmVsMjpcbiAgICAtIG1lcmdlcyAyIGxldmVsIG9mIHN1YnN0YXRlXG4gICAgLSBza2lwcyBzdWJzdGF0ZSBpZiBhbHJlYWR5IG1vZGlmaWVkXG4gICAgLSB0aGlzIGlzIGVzc2VudGlhbGx5IHJlZHV4LXBlcmlzdCB2NCBiZWhhdmlvclxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9NZXJnZUxldmVsMihpbmJvdW5kU3RhdGUsIG9yaWdpbmFsU3RhdGUsIHJlZHVjZWRTdGF0ZSwgeyBkZWJ1ZyB9KSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCByZWR1Y2VkU3RhdGUpO1xuICAgIC8vIG9ubHkgcmVoeWRyYXRlIGlmIGluYm91bmRTdGF0ZSBleGlzdHMgYW5kIGlzIGFuIG9iamVjdFxuICAgIGlmIChpbmJvdW5kU3RhdGUgJiYgdHlwZW9mIGluYm91bmRTdGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluYm91bmRTdGF0ZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gaWdub3JlIF9wZXJzaXN0IGRhdGFcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfcGVyc2lzdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gaWYgcmVkdWNlciBtb2RpZmllcyBzdWJzdGF0ZSwgc2tpcCBhdXRvIHJlaHlkcmF0aW9uXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGF0ZVtrZXldICE9PSByZWR1Y2VkU3RhdGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdC9zdGF0ZVJlY29uY2lsZXI6IHN1YiBzdGF0ZSBmb3Iga2V5IGAlc2AgbW9kaWZpZWQsIHNraXBwaW5nLicsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUGxhaW5Fbm91Z2hPYmplY3QocmVkdWNlZFN0YXRlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIHBsYWluIGVub3VnaCBzaGFsbG93IG1lcmdlIHRoZSBuZXcgdmFsdWVzIChoZW5jZSBcIkxldmVsMlwiKVxuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ld1N0YXRlW2tleV0pLCBpbmJvdW5kU3RhdGVba2V5XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGhhcmQgc2V0XG4gICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gaW5ib3VuZFN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBkZWJ1ZyAmJlxuICAgICAgICBpbmJvdW5kU3RhdGUgJiZcbiAgICAgICAgdHlwZW9mIGluYm91bmRTdGF0ZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGNvbnNvbGUubG9nKGByZWR1eC1wZXJzaXN0L3N0YXRlUmVjb25jaWxlcjogcmVoeWRyYXRlZCBrZXlzICcke09iamVjdC5rZXlzKGluYm91bmRTdGF0ZSkuam9pbignLCAnKX0nYCk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuZnVuY3Rpb24gaXNQbGFpbkVub3VnaE9iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobykgJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBGTFVTSCwgUEFVU0UsIFBFUlNJU1QsIFBVUkdFLCBSRVNZTkMsIFJFR0lTVEVSLCBSRUhZRFJBVEUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IFtdLFxuICAgIGJvb3RzdHJhcHBlZDogZmFsc2UsXG59O1xuY29uc3QgcGVyc2lzdG9yUmVkdWNlciA9IChzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgZmlyc3RJbmRleCA9IHN0YXRlLnJlZ2lzdHJ5LmluZGV4T2YoYWN0aW9uLmtleSk7XG4gICAgY29uc3QgcmVnaXN0cnkgPSBbLi4uc3RhdGUucmVnaXN0cnldO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUdJU1RFUjpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyByZWdpc3RyeTogWy4uLnN0YXRlLnJlZ2lzdHJ5LCBhY3Rpb24ua2V5XSB9KTtcbiAgICAgICAgY2FzZSBSRUhZRFJBVEU6XG4gICAgICAgICAgICByZWdpc3RyeS5zcGxpY2UoZmlyc3RJbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgcmVnaXN0cnksIGJvb3RzdHJhcHBlZDogcmVnaXN0cnkubGVuZ3RoID09PSAwIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwZXJzaXN0U3RvcmUoc3RvcmUsIG9wdGlvbnMsIGNiKSB7XG4gICAgLy8gaGVscCBjYXRjaCBpbmNvcnJlY3QgdXNhZ2Ugb2YgcGFzc2luZyBQZXJzaXN0Q29uZmlnIGluIGFzIFBlcnNpc3Rvck9wdGlvbnNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBvcHRpb25zVG9UZXN0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgYmFubmVkS2V5cyA9IFtcbiAgICAgICAgICAgICdibGFja2xpc3QnLFxuICAgICAgICAgICAgJ3doaXRlbGlzdCcsXG4gICAgICAgICAgICAndHJhbnNmb3JtcycsXG4gICAgICAgICAgICAnc3RvcmFnZScsXG4gICAgICAgICAgICAna2V5UHJlZml4JyxcbiAgICAgICAgICAgICdtaWdyYXRlJyxcbiAgICAgICAgXTtcbiAgICAgICAgYmFubmVkS2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1Rlc3Rba10pXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgcmVkdXgtcGVyc2lzdDogaW52YWxpZCBvcHRpb24gcGFzc2VkIHRvIHBlcnNpc3RTdG9yZTogXCIke2t9XCIuIFlvdSBtYXkgYmUgaW5jb3JyZWN0bHkgcGFzc2luZyBwZXJzaXN0Q29uZmlnIGludG8gcGVyc2lzdFN0b3JlLCB3aGVyZWFzIGl0IHNob3VsZCBiZSBwYXNzZWQgaW50byBwZXJzaXN0UmVkdWNlci5gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBib29zdHJhcHBlZENiID0gY2IgfHwgZmFsc2U7XG4gICAgY29uc3QgX3BTdG9yZSA9IGNyZWF0ZVN0b3JlKHBlcnNpc3RvclJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgb3B0aW9ucyAmJiBvcHRpb25zLmVuaGFuY2VyID8gb3B0aW9ucy5lbmhhbmNlciA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAoa2V5KSA9PiB7XG4gICAgICAgIF9wU3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogUkVHSVNURVIsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVoeWRyYXRlID0gKGtleSwgcGF5bG9hZCwgZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlaHlkcmF0ZUFjdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFJFSFlEUkFURSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgIH07XG4gICAgICAgIC8vIGRpc3BhdGNoIHRvIGBzdG9yZWAgdG8gcmVoeWRyYXRlIGFuZCBgcGVyc2lzdG9yYCB0byB0cmFjayByZXN1bHRcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2gocmVoeWRyYXRlQWN0aW9uKTtcbiAgICAgICAgX3BTdG9yZS5kaXNwYXRjaChyZWh5ZHJhdGVBY3Rpb24pO1xuICAgICAgICBpZiAodHlwZW9mIGJvb3N0cmFwcGVkQ2IgPT09IFwiZnVuY3Rpb25cIiAmJiBwZXJzaXN0b3IuZ2V0U3RhdGUoKS5ib290c3RyYXBwZWQpIHtcbiAgICAgICAgICAgIGJvb3N0cmFwcGVkQ2IoKTtcbiAgICAgICAgICAgIGJvb3N0cmFwcGVkQ2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGVyc2lzdG9yID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfcFN0b3JlKSwgeyBwdXJnZTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFBVUkdFLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogKHB1cmdlUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwdXJnZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpO1xuICAgICAgICB9LCBmbHVzaDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IEZMVVNILFxuICAgICAgICAgICAgICAgIHJlc3VsdDogKGZsdXNoUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmbHVzaFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpO1xuICAgICAgICB9LCBwYXVzZTogKCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFBBVVNFLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHBlcnNpc3Q6ICgpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKHsgdHlwZTogUEVSU0lTVCwgcmVnaXN0ZXIsIHJlaHlkcmF0ZSB9KTtcbiAgICAgICAgfSwgcmVzeW5jOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBSRVNZTkMsXG4gICAgICAgICAgICAgICAgICAgIHJlaHlkcmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiAoKSA9PiByZXNvbHZlKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSB9KTtcbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMubWFudWFsUGVyc2lzdCkpIHtcbiAgICAgICAgcGVyc2lzdG9yLnBlcnNpc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcnNpc3Rvcjtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IERFRkFVTFRfVkVSU0lPTiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZU1pZ3JhdGUobWlncmF0aW9ucywgY29uZmlnKSB7XG4gICAgY29uc3QgeyBkZWJ1ZyB9ID0gY29uZmlnIHx8IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGN1cnJlbnRWZXJzaW9uKSB7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWR1eC1wZXJzaXN0OiBubyBpbmJvdW5kIHN0YXRlLCBza2lwcGluZyBtaWdyYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmJvdW5kVmVyc2lvbiA9IHN0YXRlLl9wZXJzaXN0ICYmIHN0YXRlLl9wZXJzaXN0LnZlcnNpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBzdGF0ZS5fcGVyc2lzdC52ZXJzaW9uXG4gICAgICAgICAgICA6IERFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgaWYgKGluYm91bmRWZXJzaW9uID09PSBjdXJyZW50VmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlZHV4LXBlcnNpc3Q6IHZlcnNpb25zIG1hdGNoLCBub29wIG1pZ3JhdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluYm91bmRWZXJzaW9uID4gY3VycmVudFZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlZHV4LXBlcnNpc3Q6IGRvd25ncmFkaW5nIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlncmF0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG1pZ3JhdGlvbnMpXG4gICAgICAgICAgICAubWFwKHZlciA9PiBwYXJzZUludCh2ZXIpKVxuICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gY3VycmVudFZlcnNpb24gPj0ga2V5ICYmIGtleSA+IGluYm91bmRWZXJzaW9uKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdDogbWlncmF0aW9uS2V5cycsIG1pZ3JhdGlvbktleXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWlncmF0ZWRTdGF0ZSA9IG1pZ3JhdGlvbktleXMucmVkdWNlKChzdGF0ZSwgdmVyc2lvbktleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdDogcnVubmluZyBtaWdyYXRpb24gZm9yIHZlcnNpb25LZXknLCB2ZXJzaW9uS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlncmF0aW9uc1t2ZXJzaW9uS2V5XShzdGF0ZSk7XG4gICAgICAgICAgICB9LCBzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1pZ3JhdGVkU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybShcbi8vIEBOT1RFIGluYm91bmQ6IHRyYW5zZm9ybSBzdGF0ZSBjb21pbmcgZnJvbSByZWR1eCBvbiBpdHMgd2F5IHRvIGJlaW5nIHNlcmlhbGl6ZWQgYW5kIHN0b3JlZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmluYm91bmQsIFxuLy8gQE5PVEUgb3V0Ym91bmQ6IHRyYW5zZm9ybSBzdGF0ZSBjb21pbmcgZnJvbSBzdG9yYWdlLCBvbiBpdHMgd2F5IHRvIGJlIHJlaHlkcmF0ZWQgaW50byByZWR1eFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbm91dGJvdW5kLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHdoaXRlbGlzdCA9IGNvbmZpZy53aGl0ZWxpc3QgfHwgbnVsbDtcbiAgICBjb25zdCBibGFja2xpc3QgPSBjb25maWcuYmxhY2tsaXN0IHx8IG51bGw7XG4gICAgZnVuY3Rpb24gd2hpdGVsaXN0QmxhY2tsaXN0Q2hlY2soa2V5KSB7XG4gICAgICAgIGlmICh3aGl0ZWxpc3QgJiYgd2hpdGVsaXN0LmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGluOiAoc3RhdGUsIGtleSwgZnVsbFN0YXRlKSA9PiAhd2hpdGVsaXN0QmxhY2tsaXN0Q2hlY2soa2V5KSAmJiBpbmJvdW5kXG4gICAgICAgICAgICA/IGluYm91bmQoc3RhdGUsIGtleSwgZnVsbFN0YXRlKVxuICAgICAgICAgICAgOiBzdGF0ZSxcbiAgICAgICAgb3V0OiAoc3RhdGUsIGtleSwgZnVsbFN0YXRlKSA9PiAhd2hpdGVsaXN0QmxhY2tsaXN0Q2hlY2soa2V5KSAmJiBvdXRib3VuZFxuICAgICAgICAgICAgPyBvdXRib3VuZChzdGF0ZSwga2V5LCBmdWxsU3RhdGUpXG4gICAgICAgICAgICA6IHN0YXRlLFxuICAgIH07XG59XG4iLCJpbXBvcnQgeSBmcm9tXCJwaWZ5XCI7dmFyIGw9KCk9Pnt0cnl7bGV0IGU9KGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQpLm1hdGNoKC8ob3BlcmF8Y2hyb21lfHNhZmFyaXxmaXJlZm94fG1zaWV8dHJpZGVudCg/PVxcLykpXFwvP1xccyooXFxkKykvaSl8fFtdO2lmKGVbMV09PT1cIkNocm9tZVwiKXJldHVybiBwYXJzZUludChlWzJdKTwxMDB8fGdsb2JhbFRoaXMuY2hyb21lLnJ1bnRpbWU/LmdldE1hbmlmZXN0KCk/Lm1hbmlmZXN0X3ZlcnNpb249PT0yfWNhdGNoe3JldHVybiExfXJldHVybiExfTt2YXIgbz1jbGFzc3sjYTsjZTtnZXQgcHJpbWFyeUNsaWVudCgpe3JldHVybiB0aGlzLiNlfSN0O2dldCBzZWNvbmRhcnlDbGllbnQoKXtyZXR1cm4gdGhpcy4jdH0jcjtnZXQgYXJlYSgpe3JldHVybiB0aGlzLiNyfWdldCBoYXNXZWJBcGkoKXt0cnl7cmV0dXJuIHR5cGVvZiB3aW5kb3c8XCJ1XCImJiEhd2luZG93LmxvY2FsU3RvcmFnZX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS5lcnJvcihlKSwhMX19I3M9bmV3IE1hcDsjaTtnZXQgY29waWVkS2V5U2V0KCl7cmV0dXJuIHRoaXMuI2l9aXNDb3BpZWQ9ZT0+dGhpcy5oYXNXZWJBcGkmJih0aGlzLmFsbENvcGllZHx8dGhpcy5jb3BpZWRLZXlTZXQuaGFzKGUpKTsjbj0hMTtnZXQgYWxsQ29waWVkKCl7cmV0dXJuIHRoaXMuI259Z2V0RXh0U3RvcmFnZUFwaT0oKT0+Z2xvYmFsVGhpcy5icm93c2VyPy5zdG9yYWdlfHxnbG9iYWxUaGlzLmNocm9tZT8uc3RvcmFnZTtnZXQgaGFzRXh0ZW5zaW9uQXBpKCl7dHJ5e3JldHVybiEhdGhpcy5nZXRFeHRTdG9yYWdlQXBpKCl9Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUuZXJyb3IoZSksITF9fWlzV2F0Y2hTdXBwb3J0ZWQ9KCk9PnRoaXMuaGFzRXh0ZW5zaW9uQXBpO2tleU5hbWVzcGFjZT1cIlwiO2lzVmFsaWRLZXk9ZT0+ZS5zdGFydHNXaXRoKHRoaXMua2V5TmFtZXNwYWNlKTtnZXROYW1lc3BhY2VkS2V5PWU9PmAke3RoaXMua2V5TmFtZXNwYWNlfSR7ZX1gO2dldFVubmFtZXNwYWNlZEtleT1lPT5lLnNsaWNlKHRoaXMua2V5TmFtZXNwYWNlLmxlbmd0aCk7Y29uc3RydWN0b3Ioe2FyZWE6ZT1cInN5bmNcIixhbGxDb3BpZWQ6dD0hMSxjb3BpZWRLZXlMaXN0OnM9W119PXt9KXt0aGlzLnNldENvcGllZEtleVNldChzKSx0aGlzLiNyPWUsdGhpcy4jbj10O3RyeXt0aGlzLmhhc1dlYkFwaSYmKHR8fHMubGVuZ3RoPjApJiYodGhpcy4jdD13aW5kb3cubG9jYWxTdG9yYWdlKX1jYXRjaHt9dHJ5e3RoaXMuaGFzRXh0ZW5zaW9uQXBpJiYodGhpcy4jYT10aGlzLmdldEV4dFN0b3JhZ2VBcGkoKSxsKCk/dGhpcy4jZT15KHRoaXMuI2FbdGhpcy5hcmVhXSx7ZXhjbHVkZTpbXCJnZXRCeXRlc0luVXNlXCJdLGVycm9yRmlyc3Q6ITF9KTp0aGlzLiNlPXRoaXMuI2FbdGhpcy5hcmVhXSl9Y2F0Y2h7fX1zZXRDb3BpZWRLZXlTZXQoZSl7dGhpcy4jaT1uZXcgU2V0KGUpfXJhd0dldEFsbD0oKT0+dGhpcy4jZT8uZ2V0KCk7Z2V0QWxsPWFzeW5jKCk9PntsZXQgZT1hd2FpdCB0aGlzLnJhd0dldEFsbCgpO3JldHVybiBPYmplY3QuZW50cmllcyhlKS5maWx0ZXIoKFt0XSk9PnRoaXMuaXNWYWxpZEtleSh0KSkucmVkdWNlKCh0LFtzLGFdKT0+KHRbdGhpcy5nZXRVbm5hbWVzcGFjZWRLZXkocyldPWEsdCkse30pfTtjb3B5PWFzeW5jIGU9PntsZXQgdD1lPT09dm9pZCAwO2lmKCF0JiYhdGhpcy5jb3BpZWRLZXlTZXQuaGFzKGUpfHwhdGhpcy5hbGxDb3BpZWR8fCF0aGlzLmhhc0V4dGVuc2lvbkFwaSlyZXR1cm4hMTtsZXQgcz10aGlzLmFsbENvcGllZD9hd2FpdCB0aGlzLnJhd0dldEFsbCgpOmF3YWl0IHRoaXMuI2UuZ2V0KCh0P1suLi50aGlzLmNvcGllZEtleVNldF06W2VdKS5tYXAodGhpcy5nZXROYW1lc3BhY2VkS2V5KSk7aWYoIXMpcmV0dXJuITE7bGV0IGE9ITE7Zm9yKGxldCByIGluIHMpe2xldCBpPXNbcl0sbj10aGlzLiN0Py5nZXRJdGVtKHIpO3RoaXMuI3Q/LnNldEl0ZW0ocixpKSxhfHw9aSE9PW59cmV0dXJuIGF9O3Jhd0dldD1hc3luYyBlPT50aGlzLmhhc0V4dGVuc2lvbkFwaT8oYXdhaXQgdGhpcy4jZS5nZXQoZSkpW2VdOnRoaXMuaXNDb3BpZWQoZSk/dGhpcy4jdD8uZ2V0SXRlbShlKTpudWxsO3Jhd1NldD1hc3luYyhlLHQpPT4odGhpcy5pc0NvcGllZChlKSYmdGhpcy4jdD8uc2V0SXRlbShlLHQpLHRoaXMuaGFzRXh0ZW5zaW9uQXBpJiZhd2FpdCB0aGlzLiNlLnNldCh7W2VdOnR9KSxudWxsKTtjbGVhcj1hc3luYyhlPSExKT0+e2UmJnRoaXMuI3Q/LmNsZWFyKCksYXdhaXQgdGhpcy4jZS5jbGVhcigpfTtyYXdSZW1vdmU9YXN5bmMgZT0+e3RoaXMuaXNDb3BpZWQoZSkmJnRoaXMuI3Q/LnJlbW92ZUl0ZW0oZSksdGhpcy5oYXNFeHRlbnNpb25BcGkmJmF3YWl0IHRoaXMuI2UucmVtb3ZlKGUpfTtyZW1vdmVBbGw9YXN5bmMoKT0+e2xldCBlPWF3YWl0IHRoaXMucmF3R2V0QWxsKCksdD1PYmplY3Qua2V5cyhlKTthd2FpdCBQcm9taXNlLmFsbCh0Lm1hcCh0aGlzLnJhd1JlbW92ZSkpfTt3YXRjaD1lPT57bGV0IHQ9dGhpcy5pc1dhdGNoU3VwcG9ydGVkKCk7cmV0dXJuIHQmJnRoaXMuI28oZSksdH07I289ZT0+e2ZvcihsZXQgdCBpbiBlKXtsZXQgcz10aGlzLmdldE5hbWVzcGFjZWRLZXkodCksYT10aGlzLiNzLmdldChzKT8uY2FsbGJhY2tTZXR8fG5ldyBTZXQ7aWYoYS5hZGQoZVt0XSksYS5zaXplPjEpY29udGludWU7bGV0IHI9KGksbik9PntpZihuIT09dGhpcy5hcmVhfHwhaVtzXSlyZXR1cm47bGV0IGg9dGhpcy4jcy5nZXQocyk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKGBTdG9yYWdlIGNvbW1zIGRvZXMgbm90IGV4aXN0IGZvciBuc0tleTogJHtzfWApO1Byb21pc2UuYWxsKFt0aGlzLnBhcnNlVmFsdWUoaVtzXS5uZXdWYWx1ZSksdGhpcy5wYXJzZVZhbHVlKGlbc10ub2xkVmFsdWUpXSkudGhlbigoW3AsZF0pPT57Zm9yKGxldCBtIG9mIGguY2FsbGJhY2tTZXQpbSh7bmV3VmFsdWU6cCxvbGRWYWx1ZTpkfSxuKX0pfTt0aGlzLiNhLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcihyKSx0aGlzLiNzLnNldChzLHtjYWxsYmFja1NldDphLGxpc3RlbmVyOnJ9KX19O3Vud2F0Y2g9ZT0+e2xldCB0PXRoaXMuaXNXYXRjaFN1cHBvcnRlZCgpO3JldHVybiB0JiZ0aGlzLiNjKGUpLHR9OyNjKGUpe2ZvcihsZXQgdCBpbiBlKXtsZXQgcz10aGlzLmdldE5hbWVzcGFjZWRLZXkodCksYT1lW3RdLHI9dGhpcy4jcy5nZXQocyk7ciYmKHIuY2FsbGJhY2tTZXQuZGVsZXRlKGEpLHIuY2FsbGJhY2tTZXQuc2l6ZT09PTAmJih0aGlzLiNzLmRlbGV0ZShzKSx0aGlzLiNhLm9uQ2hhbmdlZC5yZW1vdmVMaXN0ZW5lcihyLmxpc3RlbmVyKSkpfX11bndhdGNoQWxsPSgpPT50aGlzLiNoKCk7I2goKXt0aGlzLiNzLmZvckVhY2goKHtsaXN0ZW5lcjplfSk9PnRoaXMuI2Eub25DaGFuZ2VkLnJlbW92ZUxpc3RlbmVyKGUpKSx0aGlzLiNzLmNsZWFyKCl9YXN5bmMgZ2V0SXRlbShlKXtyZXR1cm4gdGhpcy5nZXQoZSl9YXN5bmMgc2V0SXRlbShlLHQpe2F3YWl0IHRoaXMuc2V0KGUsdCl9YXN5bmMgcmVtb3ZlSXRlbShlKXtyZXR1cm4gdGhpcy5yZW1vdmUoZSl9fSxnPWNsYXNzIGV4dGVuZHMgb3tnZXQ9YXN5bmMgZT0+e2xldCB0PXRoaXMuZ2V0TmFtZXNwYWNlZEtleShlKSxzPWF3YWl0IHRoaXMucmF3R2V0KHQpO3JldHVybiB0aGlzLnBhcnNlVmFsdWUocyl9O3NldD1hc3luYyhlLHQpPT57bGV0IHM9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpLGE9SlNPTi5zdHJpbmdpZnkodCk7cmV0dXJuIHRoaXMucmF3U2V0KHMsYSl9O3JlbW92ZT1hc3luYyBlPT57bGV0IHQ9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpO3JldHVybiB0aGlzLnJhd1JlbW92ZSh0KX07c2V0TmFtZXNwYWNlPWU9Pnt0aGlzLmtleU5hbWVzcGFjZT1lfTtwYXJzZVZhbHVlPWFzeW5jIGU9Pnt0cnl7aWYoZSE9PXZvaWQgMClyZXR1cm4gSlNPTi5wYXJzZShlKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKHQpfX19O2V4cG9ydHtvIGFzIEJhc2VTdG9yYWdlLGcgYXMgU3RvcmFnZX07XG4iLCJjb25zdCBwcm9jZXNzRnVuY3Rpb24gPSAoZnVuY3Rpb25fLCBvcHRpb25zLCBwcm94eSwgdW53cmFwcGVkKSA9PiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRjb25zdCBQID0gb3B0aW9ucy5wcm9taXNlTW9kdWxlO1xuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdGlvbnMubXVsdGlBcmdzKSB7XG5cdFx0XHRhcmd1bWVudHNfLnB1c2goKC4uLnJlc3VsdCkgPT4ge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5lcnJvckZpcnN0KSB7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdFswXSkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmd1bWVudHNfLnB1c2goKGVycm9yLCByZXN1bHQpID0+IHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmd1bWVudHNfLnB1c2gocmVzb2x2ZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXMgPT09IHByb3h5ID8gdW53cmFwcGVkIDogdGhpcztcblx0XHRSZWZsZWN0LmFwcGx5KGZ1bmN0aW9uXywgc2VsZiwgYXJndW1lbnRzXyk7XG5cdH0pO1xufTtcblxuY29uc3QgZmlsdGVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWZ5KGlucHV0LCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0ZXhjbHVkZTogWy8uKyg/OlN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2UsXG5cdFx0Li4ub3B0aW9ucyxcblx0fTtcblxuXHRjb25zdCBvYmplY3RUeXBlID0gdHlwZW9mIGlucHV0O1xuXHRpZiAoIShpbnB1dCAhPT0gbnVsbCAmJiAob2JqZWN0VHlwZSA9PT0gJ29iamVjdCcgfHwgb2JqZWN0VHlwZSA9PT0gJ2Z1bmN0aW9uJykpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW5wdXRcXGAgdG8gYmUgYSBcXGBGdW5jdGlvblxcYCBvciBcXGBPYmplY3RcXGAsIGdvdCBcXGAke2lucHV0ID09PSBudWxsID8gJ251bGwnIDogb2JqZWN0VHlwZX1cXGBgKTtcblx0fVxuXG5cdGNvbnN0IGZpbHRlciA9ICh0YXJnZXQsIGtleSkgPT4ge1xuXHRcdGxldCBjYWNoZWQgPSBmaWx0ZXJDYWNoZS5nZXQodGFyZ2V0KTtcblxuXHRcdGlmICghY2FjaGVkKSB7XG5cdFx0XHRjYWNoZWQgPSB7fTtcblx0XHRcdGZpbHRlckNhY2hlLnNldCh0YXJnZXQsIGNhY2hlZCk7XG5cdFx0fVxuXG5cdFx0aWYgKGtleSBpbiBjYWNoZWQpIHtcblx0XHRcdHJldHVybiBjYWNoZWRba2V5XTtcblx0XHR9XG5cblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyB8fCB0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuXHRcdGNvbnN0IHdyaXRhYmxlT3JDb25maWd1cmFibGVPd24gPSAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5jb25maWd1cmFibGUpO1xuXHRcdGNvbnN0IGluY2x1ZGVkID0gb3B0aW9ucy5pbmNsdWRlID8gb3B0aW9ucy5pbmNsdWRlLnNvbWUoZWxlbWVudCA9PiBtYXRjaChlbGVtZW50KSkgOiAhb3B0aW9ucy5leGNsdWRlLnNvbWUoZWxlbWVudCA9PiBtYXRjaChlbGVtZW50KSk7XG5cdFx0Y29uc3Qgc2hvdWxkRmlsdGVyID0gaW5jbHVkZWQgJiYgd3JpdGFibGVPckNvbmZpZ3VyYWJsZU93bjtcblx0XHRjYWNoZWRba2V5XSA9IHNob3VsZEZpbHRlcjtcblx0XHRyZXR1cm4gc2hvdWxkRmlsdGVyO1xuXHR9O1xuXG5cdGNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuXHRjb25zdCBwcm94eSA9IG5ldyBQcm94eShpbnB1dCwge1xuXHRcdGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJncykge1xuXHRcdFx0Y29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHRhcmdldCk7XG5cblx0XHRcdGlmIChjYWNoZWQpIHtcblx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuYXBwbHkoY2FjaGVkLCB0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGlmaWVkID0gb3B0aW9ucy5leGNsdWRlTWFpbiA/IHRhcmdldCA6IHByb2Nlc3NGdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMsIHByb3h5LCB0YXJnZXQpO1xuXHRcdFx0Y2FjaGUuc2V0KHRhcmdldCwgcGlmaWVkKTtcblx0XHRcdHJldHVybiBSZWZsZWN0LmFwcGx5KHBpZmllZCwgdGhpc0FyZywgYXJncyk7XG5cdFx0fSxcblxuXHRcdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdFx0Y29uc3QgcHJvcGVydHkgPSB0YXJnZXRba2V5XTtcblxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1leHRlbmQtbmF0aXZlL25vLXVzZS1leHRlbmQtbmF0aXZlXG5cdFx0XHRpZiAoIWZpbHRlcih0YXJnZXQsIGtleSkgfHwgcHJvcGVydHkgPT09IEZ1bmN0aW9uLnByb3RvdHlwZVtrZXldKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHByb3BlcnR5KTtcblxuXHRcdFx0aWYgKGNhY2hlZCkge1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNvbnN0IHBpZmllZCA9IHByb2Nlc3NGdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucywgcHJveHksIHRhcmdldCk7XG5cdFx0XHRcdGNhY2hlLnNldChwcm9wZXJ0eSwgcGlmaWVkKTtcblx0XHRcdFx0cmV0dXJuIHBpZmllZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdH0sXG5cdH0pO1xuXG5cdHJldHVybiBwcm94eTtcbn1cbiIsImltcG9ydCB7Y3JlYXRlU2xpY2UsIHR5cGUgUGF5bG9hZEFjdGlvbn0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHtTcGFjZUluZm8sIFVzZXJJbmZvLCBVc2VyUHJlZmVyZW5jZXN9IGZyb20gXCJ+bm90aW9uL25vdGlvbi1tb2RlbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlvblN0YXRlIHtcbiAgICBwcmVmZXJlbmNlczogVXNlclByZWZlcmVuY2VzO1xuICAgIHVzZXI6IFVzZXJJbmZvO1xuICAgIHNwYWNlczogU3BhY2VJbmZvW107XG59XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsU3RhdGU6IE5vdGlvblN0YXRlID0ge1xuICAgIHByZWZlcmVuY2VzOiBudWxsLFxuICAgIHVzZXI6IG51bGwsXG4gICAgc3BhY2VzOiBbXSxcbn07XG5cbmNvbnN0IG5vdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IFwibm90aW9uXCIsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICAgIHNldFVzZXI6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPFVzZXJJbmZvPikgPT4ge1xuICAgICAgICAgICAgc3RhdGUudXNlciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTcGFjZXM6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPFNwYWNlSW5mb1tdPikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc3BhY2VzID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByZWZlcmVuY2VzOiAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjxVc2VyUHJlZmVyZW5jZXM+KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5wcmVmZXJlbmNlcyA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgY29uc3Qge1xuICAgIHNldFVzZXIsXG4gICAgc2V0U3BhY2VzLFxuICAgIHNldFByZWZlcmVuY2VzXG59ID0gbm90aW9uU2xpY2UuYWN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgbm90aW9uU2xpY2UucmVkdWNlcjtcbiJdLCJuYW1lcyI6WyJjdXJyZW50Iiwib3JpZ2luYWwiLCJpc0RyYWZ0IiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwid2Vha01hcE1lbW9pemUiLCJjcmVhdGVTZWxlY3RvciIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yIiwiYXJncyIsImNvbXBvc2UiLCJpc1BsYWluT2JqZWN0Iiwibm9vcCIsImlzQWN0aW9uQ3JlYXRvciIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZSIsImlzQWN0aW9uIiwibGlzdGVuZXIiLCJjcmVhdGVOZXh0U3RhdGUiLCJpc0RyYWZ0YWJsZSIsInJlZHVjZXIiLCJjcmVhdGVBc3luY1RodW5rIiwiUmVkdWNlclR5cGUiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VyUGF0aCIsIl9hIiwiYXJnIiwidGFzayIsInJlc3VsdCIsImVudHJ5IiwiYWRkTWlkZGxld2FyZSIsIm1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJzZWxlY3RvciIsImNyZWF0ZVN0b3JlIiwiaW1tZXIiLCJpc1NldCIsIkltbWVyIiwiYmFzZSIsIlJlYWN0IiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJ1c2VSZWR1eENvbnRleHQiLCJ1c2VTZWxlY3RvciIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYiLCJ3cmFwcGVyUHJvcHMiLCJzdWJzY3JpcHRpb24iLCJub3RpZnlOZXN0ZWRTdWJzIiwidXNlU3RvcmUiLCJ1c2VEaXNwYXRjaCJdLCJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMubWFwIn0=
 globalThis.define=__define;  })(globalThis.define);